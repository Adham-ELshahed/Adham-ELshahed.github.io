{
    "title": "main_page",
    "Syntax": null,
    "About": null,
    "pages": [
        {
            "title": "Access Data-functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Access.Database",
                    "Syntax": "Access.Database(database as binary, optional options as nullable record) as table",
                    "About": "Returns a structural representation of an Access database, database. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties : A logical (true/false) that sets whether to generate navigation properties on the returned values (default is false).NavigationPropertyNameGenerator : A function that is used for the creation of names for navigation properties.",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...]",
                    "pages": []
                },
                {
                    "title": "ActiveDirectory.Domains",
                    "Syntax": "ActiveDirectory.Domains(optional forestRootDomainName as nullable text) as table",
                    "About": "Returns a list of Active Directory domains in the same forest as the specified domain or of the current machine's domain if none is specified.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AdobeAnalytics.Cubes",
                    "Syntax": "AdobeAnalytics.Cubes(optional options as nullable record) as table",
                    "About": "Returns a table of multidimensional packages from Adobe Analytics. An optional record parameter, options, may be specified to control the following options:HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).MaxRetryCount: The number of retries to perform when polling for the result of the query. The default value is 120.RetryInterval: The duration of time between retry attempts. The default value is 1 second.Implementation: Specifies Adobe Analytics API version. Valid values are: \"2.0\". Default uses API version 1.4.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AdoDotNet.DataSource",
                    "Syntax": "AdoDotNet.DataSource(providerName as text, connectionString as any, optional options as nullable record) as table",
                    "About": "Returns the schema collection for the ADO.NET data source with provider name providerName and connection string connectionString. connectionString can be text or a record of property value pairs. Property values can either be text or number. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:CommandTimeout : A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.SqlCompatibleWindowsAuth : A logical (true/false) that determines whether to produce SQL Server-compatible connection string options for Windows authentication. The default value is true.TypeMap",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AdoDotNet.Query",
                    "Syntax": "AdoDotNet.Query(providerName as text, connectionString as any, query as text, optional options as nullable record) as table",
                    "About": "Returns the result of running query with the connection string connectionString using the ADO.NET provider providerName. connectionString can be text or a record of property value pairs. Property values can either be text or number. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:CommandTimeout : A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.SqlCompatibleWindowsAuth : A logical (true/false) that determines whether to produce SQL Server-compatible connection string options for Windows authentication. The default value is true.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AnalysisServices.Database",
                    "Syntax": "AnalysisServices.Database(server as text, database as text, optional options as nullable record) as table",
                    "About": "Returns a table of multidimensional cubes or tabular models from the Analysis Services database database on server server. An optional record parameter, options, may be specified to control the following options:Query : A native MDX query used to retrieve data.TypedMeasureColumns : A logical value indicating if the types specified in the multidimensional or tabular model will be used for the types of the added measure columns. When set to false, the type \"number\" will be used for all measure columns. The default value for this option is false.Culture : A culture name specifying the culture for the data. This corresponds to the 'Locale Identifier' connection string property.CommandTimeout : A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is driver-dependent.ConnectionTimeout : A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.SubQueries : A number (0, 1 or 2) that sets the value of the \"SubQueries\" property in the connection string. This controls the behavior of calculated members on subselects or subcubes. (The default value is 2).Implementation",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AnalysisServices.Databases",
                    "Syntax": "AnalysisServices.Databases(server as text, optional options as nullable record) as table",
                    "About": "Returns databases on an Analysis Services instance, server. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:TypedMeasureColumns : A logical value indicating if the types specified in the multidimensional or tabular model will be used for the types of the added measure columns. When set to false, the type \"number\" will be used for all measure columns. The default value for this option is false.Culture : A culture name specifying the culture for the data. This corresponds to the 'Locale Identifier' connection string property.CommandTimeout : A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is driver-dependent.ConnectionTimeout : A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.SubQueries : A number (0, 1 or 2) that sets the value of the \"SubQueries\" property in the connection string. This controls the behavior of calculated members on subselects or subcubes. (The default value is 2).Implementation",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AzureStorage.BlobContents",
                    "Syntax": "Returns the content of the blob at the URL, url, from an Azure storage vault. options may be specified to control the following options:BlockSize : The number of bytes to read before waiting on the data consumer. The default value is 4 MB.RequestSize : The number of bytes to try to read in a single HTTP request to the server. The default value is 4 MB.ConcurrentRequests : The ConcurrentRequests option supports faster download of data by specifying the number of requests to be made in parallel, at the cost of memory utilization. The memory required is (ConcurrentRequest * RequestSize). The default value is 16.",
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AzureStorage.Blobs",
                    "Syntax": "Returns a navigational table containing a row for each container found at the account URL, account, from an Azure storage vault. Each row contains a link to the container blobs. options may be specified to control the following options:BlockSize : The number of bytes to read before waiting on the data consumer. The default value is 4 MB.RequestSize : The number of bytes to try to read in a single HTTP request to the server. The default value is 4 MB.ConcurrentRequests : The ConcurrentRequests option supports faster download of data by specifying the number of requests to be made in parallel, at the cost of memory utilization. The memory required is (ConcurrentRequest * RequestSize). The default value is 16.",
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AzureStorage. DataLake",
                    "Syntax": "AzureStorage.DataLake(endpoint as text, optional options as nullable record) as table.",
                    "About": "Returns a navigational table containing the documents found in the specified container and its subfolders at the account URL, endpoint, from an Azure Data Lake Storage filesystem. options may be specified to control the following options:BlockSize: The number of bytes to read before waiting on the data consumer. The default value is 4 MB.RequestSize: The number of bytes to try to read in a single HTTP request to the server. The default value is 4 MB.ConcurrentRequests: The ConcurrentRequests option supports faster download of data by specifying the number of requests to be made in parallel, at the cost of memory utilization. The memory required is (ConcurrentRequest * RequestSize). The default value is 16.HierarchicalNavigation: A logical (true/false) that controls whether the files are returned in a tree-like directory view or in a flat list. The default value is false.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AzureStorage.DataLakeContents",
                    "Syntax": "AzureStorage.DataLakeContents(url as text, optional options as nullable record) as binary.",
                    "About": "Returns the content of the file at the URL, url, from an Azure Data Lake Storage filesystem. options may be specified to control the following options:BlockSize: The number of bytes to read before waiting on the data consumer. The default value is 4 MB.RequestSize: The number of bytes to try to read in a single HTTP request to the server. The default value is 4 MB.ConcurrentRequests: The ConcurrentRequests option supports faster download of data by specifying the number of requests to be made in parallel, at the cost of memory utilization. The memory required is (ConcurrentRequest * RequestSize). The default value is 16.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "AzureStorage.Tables",
                    "Syntax": "AzureStorage.Tables(account as text, optional options as nullable record) as table.",
                    "About": "Returns a navigational table containing a row for each table found at the account URL, account, from an Azure storage vault. Each row contains a link to the azure table. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Timeout: A duration that controls how long to wait before abandoning the request to the server. The default value is source-specific.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cdm.AddMeasureColumn",
                    "Syntax": "Cube.AddMeasureColumn(**cube** as table, **column** as text, **measureSelector** as any) as table",
                    "About": "Adds a column with the name column to the cube that contains the results of the measure measureSelector applied in the row context of each row. Measure application is affected by changes to dimension granularity and slicing. Measure values will be adjusted after certain cube operations are performed.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cdm.Contents",
                    "Syntax": "Cdm.Contents(table as table) as table",
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Csv.Document",
                    "Syntax": "Csv.Document(source as any, optional columns as any, optional delimiter as any, optional extraValues as nullable number, optional encoding as nullable number) as table.",
                    "About": "Returns the contents of the CSV document as a table.columns can be null, the number of columns, a list of column names, a table type, or an options record.delimiter can be a single character, or a list of characters. Default: \",\".Refer to ExtraValues.Type for the supported values of extraValues.encoding specifies the text encoding type.If a record is specified for columns (and delimiter, extraValues, and encoding are null), the following record fields may be provided:Delimiter: The column delimiter. Default: \",\".Columns: Can be null, the number of columns, a list of column names, or a table type. If the number of columns is lower than the number found in the input, the additional columns will be ignored. If the number of columns is higher than the number found in the input, the additional columns will be null. When not specified, the number of columns will be determined by what is found in the input.Encoding: The text encoding of the file. Default: 65001 (UTF-8).CsvStyle: Specifies how quotes are handled. CsvStyle.QuoteAfterDelimiter (default): Quotes in a field are only significant immediately following the delimiter. CsvStyle.QuoteAlways: Quotes in a field are always significant, regardless of where they appear.QuoteStyle: Specifies how quoted line breaks are handled. QuoteStyle.None (default): All line breaks are treated as the end of the current row, even when they occur inside a quoted value. QuoteStyle.Csv: Quoted line breaks are treated as part of the data, not as the end of the current row.",
                    "Explain": "Process CSV text with column headers.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0csv = Text.Combine({\"OrderID,Item\", \"1,Fishing rod\", \"2,1 lb. worms\"}, \"#(cr)#(lf)\")in\u00a0\u00a0\u00a0\u00a0Table.PromoteHeaders(Csv.Document(csv))OutputPower Query MTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[OrderID = \"1\", Item = \"Fishing rod\"],\u00a0\u00a0\u00a0\u00a0[OrderID = \"2\", Item = \"1 lb. worms\"]",
                    "pages": []
                },
                {
                    "title": "Cube.AddAndExpandDimensionColumn",
                    "Syntax": "Cube.AddAndExpandDimensionColumn(**cube** as table, **dimensionSelector** as any, **attributeNames** as list, optional **newColumnNames** as any) as table.",
                    "About": "Merges the specified dimension table, dimensionSelector, into the cube's, cube, filter context and changes the dimensional granularity by expanding the specified set, attributeNames, of dimension attributes. The dimension attributes are added to the tabular view with columns named newColumnNames, or attributeNames if not specified.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.AddMeasureColumn",
                    "Syntax": "Cube.AddMeasureColumn(**cube** as table, **column** as text, **measureSelector** as any) as table",
                    "About": "Adds a column with the name column to the cube that contains the results of the measure measureSelector applied in the row context of each row. Measure application is affected by changes to dimension granularity and slicing. Measure values will be adjusted after certain cube operations are performed.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.ApplyParameters",
                    "Syntax": "Cube.ApplyParameter(cube as table, parameter as any, optional arguments as nullable list) as table.",
                    "About": "Returns a cube after applying parameter with arguments to cube.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.AttiributeMemberld",
                    "Syntax": "Cube.AttributeMemberId(attribute as any) as any.",
                    "About": "Returns the unique member identifier from a member property value. attribute. Returns null for any other values.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.AttiributeMemberProperty",
                    "Syntax": "Cube.AttributeMemberProperty(attribute as any, propertyName as text) as any.",
                    "About": "Returns the property propertyName of dimension attribute attribute.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.CollapseAndRemoveColumns",
                    "Syntax": "Cube.CollapseAndRemoveColumns(**cube** as table, **columnNames** as list) as table.",
                    "About": "Changes the dimensional granularity of the filter context for the cube by collapsing the attributes mapped to the specified columns columnNames. The columns are also removed from the tabular view of the cube.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.Dimensions",
                    "Syntax": "Cube.Dimensions(**cube** as table) as table.",
                    "About": "Returns a table containing the set of available dimensions within the cube. Each dimension is a table containing a set of dimension attributes and each dimension attribute is represented as a column in the dimension table. Dimensions can be expanded in the cube using Cube.AddAndExpandDimensionColumn.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.DisplayFolders",
                    "Syntax": "Cube.DisplayFolders(**cube** as table) as table.",
                    "About": "Returns a nested tree of tables representing the display folder hierarchy of the objects (for example, dimensions and measures) available for use in the cube.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.MeasureProperties",
                    "Syntax": "Cube.MeasureProperties(cube as table) as table.",
                    "About": "Returns a table containing the set of available properties for measures that are expanded in the cube.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.MeasureProperty",
                    "Syntax": "Cube.MeasureProperty(measure as any, propertyName as text) as any.",
                    "About": "Returns the property of a measure.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.Measures",
                    "Syntax": "Cube.Measures(**cube** as any) as table.",
                    "About": "Returns a table containing the set of available measures within the cube. Each measure is represented as a function. Measures can be applied to the cube using Cube.AddMeasureColumn.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.Parameters",
                    "Syntax": "Cube.Parameters(cube as table) as table.",
                    "About": "Returns a table containing the set of parameters that can be applied to cube. Each parameter is a function that can be invoked to get cube with the parameter and its arguments applied.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.Properties",
                    "Syntax": "Cube.Properties(cube as table) as table.",
                    "About": "Returns a table containing the set of available properties for dimensions that are expanded in the cube.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.PropertyKey",
                    "Syntax": "Cube.PropertyKey(property as any) as any.",
                    "About": "Returns the key of property property.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.ReplaceDimensions",
                    "Syntax": "Cube.ReplaceDimensions(cube as table, dimensions as table) as table.",
                    "About": "Replaces the set of dimensions returned by Cube.Dimensions. For example, this function can be used to add an ID column to a dimension attribute, so that the data source can group on the ID rather than the displayed value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Cube.Tranform",
                    "Syntax": "Cube.Transform(cube as table, transforms as list) as table.",
                    "About": "Applies the list cube functions, transforms, on the cube.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DB2.Database",
                    "Syntax": "DB2.Database(server as text, database as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views available in a Db2 database on server server in the database instance named database. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).Implementation: Specifies the internal database provider implementation to use. Valid values are: \"IBM\" and \"Microsoft\".BinaryCodePage: A number for the CCSID (Coded Character Set Identifier) to decode Db2 FOR BIT binary data into character strings. Applies to Implementation = \"Microsoft\". Set 0 to disable conversion (default). Set 1 to convert based on database encoding. Set other CCSID number to convert to application encoding.PackageCollection: Specifies a string value for package collection (default is \"NULLID\") to enable use of shared packages required to process SQL statements. Applies to Implementation = \"Microsoft\".UseDb2ConnectGateway: Specifies whether the connection is being made through a Db2 Connect gateway. Applies to Implementation = \"Microsoft\".",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"] \u00a0.",
                    "pages": []
                },
                {
                    "title": "DeltaLake.Table",
                    "Syntax": "DeltaLake.Table(directory as table, optional options as nullable record) as any.",
                    "About": "Returns the contents of the Delta Lake table.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Essbase.Cubes",
                    "Syntax": "Essbase.Cubes(url as text, optional options as nullable record) as table.",
                    "About": "Returns a table of cubes grouped by Essbase server from an Essbase instance at APS server url. An optional record parameter, options, may be specified to control the following options:CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Excel.CurrentWorkbook",
                    "Syntax": "Excel.CurrentWorkbook() as table.",
                    "About": "Returns the contents of the current Excel workbook. It returns tables, named ranges, and dynamic arrays. Unlike Excel.Workbook, it does not return sheets.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Excel.Workbook",
                    "Syntax": "Excel.Workbook(workbook as binary, optional useHeaders as any, optional delayTypes as nullable logical) as table.",
                    "About": "Returns the contents of the Excel workbook.useHeaders can be null, a logical (true/false) value indicating whether the first row of each returned table should be treated as a header, or an options record. Default: false.delayTypes can be null or a logical (true/false) value indicating whether the columns of each returned table should be left untyped. Default: false.If a record is specified for useHeaders (and delayTypes is null), the following record fields may be provided:UseHeaders: Can be null or a logical (true/false) value indicating whether the first row of each returned table should be treated as a header. Default: false.DelayTypes: Can be null or a logical (true/false) value indicating whether the columns of each returned table should be left untyped. Default: false.InferSheetDimensions: Can be null or a logical (true/false) value indicating whether the area of a worksheet that contains data should be inferred by reading the worksheet itself, rather than by reading the dimensions metadata from the file. This can be useful in cases where the dimensions metadata is incorrect. Note that this option is only supported for Open XML Excel files, not for legacy Excel files. Default: false.",
                    "Explain": "Return the contents of Sheet1 from an Excel workbook.UsagePower Query MExcel.Workbook(File.Contents(\"C:\\Book1.xlsx\"), null, true){[Item=\"Sheet1\"]}[Data]OutputPower Query MTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = \"ID\", Column2 = \"Name\", Column3 = \"Phone\"],\u00a0\u00a0\u00a0\u00a0[Column1 = 1, Column2 = \"Bob\", Column3 = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[Column1 = 3, Column2 = \"Pam\", Column3 = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[Column1 = 2, Column2 = \"Jim\", Column3 = \"987-6543\"]})",
                    "pages": []
                },
                {
                    "title": "Exchange.Contents",
                    "Syntax": "Exchange.Contents (optional mailboxAddress as nullable text) as table.",
                    "About": "Returns a table of contents from the Microsoft Exchange account mailboxAddress. If mailboxAddress is not specified, the default account for the credential will be used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "File.Contents",
                    "Syntax": "File.Contents(path as text, optional options as nullable record) as binary.",
                    "About": "Returns the contents of the file, path, as binary. The options parameter is currently intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Folder.Contents",
                    "Syntax": "Folder.Contents(path as text, optional options as nullable record) as table.",
                    "About": "Returns a table containing a row for each folder and file found in the folder path. Each row contains properties of the folder or file and a link to its content. The options parameter is currently intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Folder.Files",
                    "Syntax": "Folder.Files(path as text, optional options as nullable record) as table.",
                    "About": "Returns a table containing a row for each file found in the folder path and all its subfolders. Each row contains properties of the file and a link to its content. The options parameter is currently intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "GoogleAnalytics.Accounts",
                    "Syntax": "GoogleAnalytics.Accounts(optional options as nullable record) as table.",
                    "About": "Returns Google Analytics accounts that are accessible from the current credential.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Hdfs.Contents",
                    "Syntax": "Hdfs.Contents(url as text) as table.",
                    "About": "Returns a table containing a row for each folder and file found at the folder URL, url, from a Hadoop file system. Each row contains properties of the folder or file and a link to its content.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Hdfs.Files",
                    "Syntax": "Hdfs.Files(url as text) as table.",
                    "About": "Returns a table containing a row for each file found at the folder URL, url, and subfolders from a Hadoop file system. Each row contains properties of the file and a link to its content.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "HdInsight.Containers",
                    "Syntax": "HdInsight.Containers(account as text) as table.",
                    "About": "Returns a navigational table containing a row for each container found at the account URL, account, from an Azure storage vault. Each row contains a link to the container blobs.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "HdInsight.Contents",
                    "Syntax": "HdInsight.Contents(account as text) as table.",
                    "About": "Returns a navigational table containing a row for each container found at the account URL, account, from an Azure storage vault. Each row contains a link to the container blobs.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "HdInsight.Files",
                    "Syntax": "HdInsight.Files(account as text, containerName as text) as table.",
                    "About": "Returns a table containing a row for each blob file found at the container URL, account, from an Azure storage vault. Each row contains properties of the file and a link to its content.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Html.Table",
                    "Syntax": "Html.Table(html as any, columnNameSelectorPairs as list, optional options as nullable record) as table.",
                    "About": "Returns a table containing the results of running the specified CSS selectors against the provided html. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:RowSelector",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Identity.From",
                    "Syntax": "Identity.From(identityProvider as function, value as any) as record.",
                    "About": "Creates an identity.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Identity.IsMemberOf",
                    "Syntax": "Identity.IsMemberOf(identity as record, collection as record) as logical.",
                    "About": "Determines whether an identity is a member of an identity collection.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "IdentityProvider.Default",
                    "Syntax": "IdentityProvider.Default() as any.",
                    "About": "The default identity provider for the current host.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Informix.Database",
                    "Syntax": "Informix.Database(server as text, database as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views available in an Informix database on server server in the database instance named database. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "Json.Document",
                    "Syntax": "Json.Document(jsonText as any, optional encoding as nullable number) as any.",
                    "About": "Returns the contents of a JSON document. The contents may be directly passed to the function as text, or it may be the binary value returned by a function like File.Contents.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Json.FromValue",
                    "Syntax": "Json.FromValue(value as any, optional encoding as nullable number) as binary.",
                    "About": "Produces a JSON representation of a given value value with a text encoding specified by encoding. If encoding is omitted, UTF8 is used. Values are represented as follows:Null, text and logical values are represented as the corresponding JSON typesNumbers are represented as numbers in JSON, except that #infinity, -#infinity and #null are converted to nullLists are represented as JSON arraysRecords are represnted as JSON objectsTables are represented as an array of objectsDates, times, datetimes, datetimezones and durations are represented as ISO-8601 textBinary values are represented as base-64 encoded textTypes and functions produce an error",
                    "Explain": "Convert a complex value to JSON.UsagePower Query MText.FromBinary(Json.FromValue([A = {1, true, \"3\"}, B = #date(2012, 3, 25)]))Output\"{\"\"A\"\":[1,true,\"\"3\"\"],\"\"B\"\":\"\"2012-03-25\"\"}\"",
                    "pages": []
                },
                {
                    "title": "MySQL.Database",
                    "Syntax": "MySQL.Database(server as text, database as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables, views, and stored scalar functions available in a MySQL database on server server in the database instance named database. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:Encoding: A TextEncoding value that specifies the character set used to encode all queries sent to the server (default is null).CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.TreatTinyAsBoolean: A logical (true/false) that determines whether to force tinyint columns on the server as logical values. The default value is true.OldGuids: A logical (true/false) that sets whether char(36) columns (if false) or binary(16) columns (if true) will be treated as GUIDs. The default value is false.ReturnSingleDatabase: A logical (true/false) that sets whether to return all tables of all databases (if false) or to return tables and views of the specified database (if true). The default value is false.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "OData.Feed",
                    "Syntax": "OData.Feed(serviceUri as text, optional headers as nullable record, optional options as any) as any.",
                    "About": "Returns a table of OData feeds offered by an OData service from a uri serviceUri, headers headers. A boolean value specifying whether to use concurrent connections or an optional record parameter, options, may be specified to control the following options:Query: Programmatically add query parameters to the URL without having to worry about escaping.Headers: Specifying this value as a record will supply additional headers to an HTTP request.ExcludedFromCacheKey: Specifying this value as a list will exclude these HTTP header keys from being part of the calculation for caching data.ApiKeyName: If the target site has a notion of an API key, this parameter can be used to specify the name (not the value) of the key parameter that must be used in the URL. The actual key value is provided in the credential.Timeout: Specifying this value as a duration will change the timeout for an HTTP request. The default value is 600 seconds.EnableBatch: A logical (true/false) that sets whether to allow generation of an OData $batch request if the MaxUriLength is exceeded (default is false).`MaxUriLength: A number that indicates the max length of an allowed uri sent to an OData service. If exceeded and EnableBatch is true then the request will be made to an OData $batch endpoint, otherwise it will fail (default is 2048).Concurrent: A logical (true/false) when set to true, requests to the service will be made concurrently. When set to false, requests will be made sequentially. When not specified, the value will be determined by the service\u2019s AsynchronousRequestsSupported annotation. If the service does not specify whether AsynchronousRequestsSupported is supported, requests will be made sequentially.ODataVersion: A number (3 or 4) that specifies the OData protocol version to use for this OData service. When not specified, all supported versions will be requested. The service version will be determined by the OData-Version header returned by the service.FunctionOverloads: A logical (true/false) when set to true, function import overloads will be listed in the navigator as separate entries, when set to false, function import overloads will be listed as one union function in the navigator. Default value for V3: false. Default value for V4: true.MoreColumns: A logical (true/false) when set to true, adds a \"More Columns\" column to each entity feed containing open types and polymorphic types. This will contain the fields not declared in the base type. When false, this field is not present. Defaults to false.IncludeAnnotations: A comma separated list of namespace qualified term names or patterns to include with \"*\" as a wildcard. By default, none of the annotations are included.IncludeMetadataAnnotations: A comma separated list of namespace qualified term names or patterns to include on metadata document requests, with \"*\" as a wildcard. By default, includes the same annotations as IncludeAnnotations.OmitValues: Allows the OData service to avoid writing out certain values in responses. If acknowledged by the service, we will infer those values from the omitted fields. Options include:ODataOmitValues.Nulls: Allows the OData service to omit null values.Implementation: Specifies the implementation of the OData connector to use. Valid values are \"2.0\" or null.",
                    "Explain": "Connect to the TripPin OData service.UsagePower Query MOData.Feed(\"https://services.odata.org/V4/TripPinService\")Outputtable",
                    "pages": []
                },
                {
                    "title": "Odbc.DataSource",
                    "Syntax": "Odbc.DataSource(connectionString as any, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views from the ODBC data source specified by the connection string connectionString. connectionString can be text or a record of property value pairs. Property values can either be text or number. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is 15 seconds.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.SqlCompatibleWindowsAuth: A logical (true/false) that determines whether to produce SQL Server-compatible connection string options for Windows authentication. The default value is true.",
                    "Explain": "Return the SQL tables and views from the provided connection string.UsagePower Query MOdbc.DataSource(\"dsn=your_dsn\")OutputPower Query Mtable",
                    "pages": []
                },
                {
                    "title": "Odbc.InferOptions",
                    "Syntax": "Odbc.InferOptions(connectionString as any) as record.",
                    "About": "Returns the result of trying to infer SQL capbabilities with the connection string connectionString using ODBC. connectionString can be text or a record of property value pairs. Property values can either be text or number.",
                    "Explain": "Return the inferred SQL capabilities for a connection string.UsagePower Query MOdbc.InferOptions(\"dsn=your_dsn\")OutputPower Query Mrecord",
                    "pages": []
                },
                {
                    "title": "Odbc.Query",
                    "Syntax": "Odbc.Query(connectionString as any, query as text, optional options as nullable record) as table",
                    "About": "Returns the result of running query with the connection string connectionString using ODBC. connectionString can be text or a record of property value pairs. Property values can either be text or number. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is 15 seconds.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.SqlCompatibleWindowsAuth: A logical (true/false) that determines whether to produce SQL Server-compatible connection string options for Windows authentication. The default value is true.",
                    "Explain": "Return the result of running a simple query against the provided connection string.UsagePower Query MOdbc.Query(\"dsn=your_dsn\", \"select * from Customers\")OutputPower Query Mtable",
                    "pages": []
                },
                {
                    "title": "OleDb.DataSource",
                    "Syntax": "OleDb.DataSource(connectionString as any, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views from the OLE DB data source specified by the connection string connectionString. connectionString can be text or a record of property value pairs. Property values can either be text or number. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is true).ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.SqlCompatibleWindowsAuth: A logical (true/false) that determines whether to produce SQL Server-compatible connection string options for Windows authentication. The default value is true.",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "OleDb.Query",
                    "Syntax": "OleDb.Query(connectionString as any, query as text, optional options as nullable record) as table.",
                    "About": "Returns the result of running query with the connection string connectionString using OLE DB. connectionString can be text or a record of property value pairs. Property values can either be text or number. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.SqlCompatibleWindowsAuth: A logical (true/false) that determines whether to produce SQL Server-compatible connection string options for Windows authentication. The default value is true.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Oracle.Database",
                    "Syntax": "Oracle.Database(server as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views from the Oracle database on server server. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "Pdf.Tables",
                    "Syntax": "Pdf.Tables(pdf as binary, optional options as nullable record) as table.",
                    "About": "Returns any tables found in pdf. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Implementation: The version of the algorithm to use when identifying tables. Old versions are available only for backwards compatibility, to prevent old queries from being broken by algorithm updates. The newest version should always give the best results. Valid values are \"1.3\", \"1.2\", \"1.1\", or null.StartPage: Specifies the first page in the range of pages to examine. Default: 1.EndPage: Specifies the last page in the range of pages to examine. Default: the last page of the document.MultiPageTables: Controls whether similar tables on consecutive pages will be automatically combined into a single table. Default: true.EnforceBorderLines: Controls whether border lines are always enforced as cell boundaries (when true), or simply used as one hint among many for determining cell boundaries (when false). Default: false.",
                    "Explain": "Returns the tables contained in sample.pdf.UsagePower Query MPdf.Tables(File.Contents(\"c:\\sample.pdf\"))OutputPower Query M#table({\"Name\", \"Kind\", \"Data\"}, ...)",
                    "pages": []
                },
                {
                    "title": "PostgreSQL.Database",
                    "Syntax": "PostgreSQL.Database(server as text, database as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views available in a PostgreSQL database on server server in the database instance named database. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "RData.FromBinary",
                    "Syntax": "RData.FromBinary(stream as binary) as any.",
                    "About": "Returns a record of data frames from the RData file.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Salesforce.Data",
                    "Syntax": "Salesforce.Data(optional loginUrl as any, optional options as nullable record) as table.",
                    "About": "Returns the objects on the Salesforce account provided in the credentials. The account will be connected through the provided environment loginUrl. If no environment is provided then the account will connect to production (https://login.salesforce.com). An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is false).ApiVersion: The Salesforce API version to use for this query. When not specified, API version 29.0 is used.Timeout: A duration that controls how long to wait before abandoning the request to the server. The default value is source-specific.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Salesforce.Reports",
                    "Syntax": "Salesforce.Reports(optional loginUrl as nullable text, optional options as nullable record) as table.",
                    "About": "Returns the reports on the Salesforce account provided in the credentials. The account will be connected through the provided environment loginUrl. If no environment is provided then the account will connect to production (https://login.salesforce.com). An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:ApiVersion: The Salesforce API version to use for this query. When not specified, API version 29.0 is used.Timeout: A duration that controls how long to wait before abandoning the request to the server. The default value is source-specific.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SapBusinessWarehouse.Cubes",
                    "Syntax": "SapBusinessWarehouse.Cubes(server as text, systemNumberOrSystemId as text, clientId as text, optional optionsOrLogonGroup as any, optional options as nullable record) as table.",
                    "About": "Returns a table of InfoCubes and queries grouped by InfoArea from an SAP Business Warehouse instance at server server with system number systemNumberOrSystemId and Client ID clientId. An optional record parameter, optionsOrLogonGroup, may be specified to control options.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SapHana.Database",
                    "Syntax": "SapHana.Database(**server** as text, optional **options** as nullable record) as table.",
                    "About": "Returns a table of multidimensional packages from the SAP HANA database server. An optional record parameter, options, may be specified to control the following options:Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.Distribution: A SapHanaDistribution that sets the value of the \"Distribution\" property in the connection string. Statement routing is the method of evaluating the correct server node of a distributed system before statement execution. The default value is SapHanaDistribution.All.Implementation: Specifies the implementation of the SAP HANA connector to use.EnableColumnBinding: Binds variables to the columns of a SAP HANA result set when fetching data. May potentially improve performance at the cost of slightly higher memory utilization. The default value is false.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is 15 seconds.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SharePoint.Contents",
                    "Syntax": "SharePoint.Contents(url as text, optional options as nullable record) as table.",
                    "About": "Returns a table containing a row for each folder and document found at the specified SharePoint site, url. Each row contains properties of the folder or file and a link to its content. options may be specified to control the following options:ApiVersion: A number (14 or 15) or the text \"Auto\" that specifies the SharePoint API version to use for this site. When not specified, API version 14 is used. When Auto is specified, the server version will be automatically discovered if possible, otherwise version defaults to 14. Non-English SharePoint sites require at least version 15.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SharePoint.Files",
                    "Syntax": "SharePoint.Files(url as text, optional options as nullable record) as table.",
                    "About": "Returns a table containing a row for each document found at the specified SharePoint site, url, and subfolders. Each row contains properties of the folder or file and a link to its content. options may be specified to control the following options:ApiVersion: A number (14 or 15) or the text \"Auto\" that specifies the SharePoint API version to use for this site. When not specified, API version 14 is used. When Auto is specified, the server version will be automatically discovered if possible, otherwise version defaults to 14. Non-English SharePoint sites require at least version 15.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SharePoint.Tables",
                    "Syntax": "SharePoint.Tables(url as text, optional options as nullable record) as table.",
                    "About": "Returns a table containing a row for each List item found at the specified SharePoint list, url. Each row contains properties of the List. options may be specified to control the following options:ApiVersion: A number (14 or 15) or the text \"Auto\" that specifies the SharePoint API version to use for this site. When not specified, API version 14 is used. When Auto is specified, the server version will be automatically discovered if possible, otherwise version defaults to 14. Non-English SharePoint sites require at least version 15.Implementation: Optional. Specifies which version of the SharePoint connector to use. Accepted values are \"2.0\" or null. If the value is \"2.0\", the 2.0 implementation of the SharePoint connector is used. If the value is null, the original implementation of the SharePoint connector is used.ViewMode: Optional. This option is only valid for implementation 2.0. Accepted values are \"All\" and \"Default\". If no value is specified, the value is set to \"All\". When \"All\"; is specified, the view includes all user-created and system-defined columns. When \"Default\" is specified, the view will match what the user sees when looking at the list online in whichever view that user set as Default in their settings. If the user edits their default view to add or remove either user-created or system-defined columns, or by creating a new view and setting it as default, these changes will propagate through the connector.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Soda.Feed",
                    "Syntax": "Soda.Feed(url as text) as table.",
                    "About": "Returns a table from the contents at the specified URL url formatted according to the SODA 2.0 API. The URL must point to a valid SODA-compliant source that ends in a .csv extension.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Sql.Database",
                    "Syntax": "Sql.Database(server as text, database as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables, views, and stored functions from the SQL Server database database on server server. The port may be optionally specified with the server, separated by a colon or a comma. An optional record parameter, options, may be specified to control the following options:Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.MaxDegreeOfParallelism: A number that sets the value of the \"maxdop\" query clause in the generated SQL query.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).MultiSubnetFailover: A logical (true/false) that sets the value of the \"MultiSubnetFailover\" property in the connection string (default is false).UnsafeTypeConversions: A logical (true/false) that, if true, attempts to fold type conversions which could fail and cause the entire query to fail. Not recommended for general use.ContextInfo: A binary value that is used to set the CONTEXT_INFO before running each command.OmitSRID: A logical (true/false) that, if true, omits the SRID when producing Well-Known Text from geometry and geography types.EnableCrossDatabaseFolding: A logical (true/false) value that, if true, allows query folding across databases on the same server. The default value is false.",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "Sql.Databases",
                    "Syntax": "Sql.Databases(server as text, optional options as nullable record) as table",
                    "About": "Returns a table of databases on the specified SQL server, server. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.MaxDegreeOfParallelism: A number that sets the value of the \"maxdop\" query clause in the generated SQL query.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).MultiSubnetFailover: A logical (true/false) that sets the value of the \"MultiSubnetFailover\" property in the connection string (default is false).UnsafeTypeConversions: A logical (true/false) that, if true, attempts to fold type conversions which could fail and cause the entire query to fail. Not recommended for general use.ContextInfo: A binary value that is used to set the CONTEXT_INFO before running each command.OmitSRID: A logical (true/false) that, if true, omits the SRID when producing Well-Known Text from geometry and geography types.EnableCrossDatabaseFolding: A logical (true/false) value that, if true, allows query folding across databases on the same server. The default value is false.",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...]",
                    "pages": []
                },
                {
                    "title": "Sybase.Database",
                    "Syntax": "Sybase.Database(server as text, database as text, optional options as nullable record) as table",
                    "About": "Returns a table of SQL tables and views available in a Sybase database on server server in the database instance named database. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "Teradata.Database",
                    "Syntax": "Teradata.Database(server as text, optional options as nullable record) as table.",
                    "About": "Returns a table of SQL tables and views from the Teradata database on server server. The port may be optionally specified with the server, separated by a colon. An optional record parameter, options, may be specified to control the following options:CreateNavigationProperties: A logical (true/false) that sets whether to generate navigation properties on the returned values (default is true).NavigationPropertyNameGenerator: A function that is used for the creation of names for navigation properties.Query: A native SQL query used to retrieve data. If the query produces multiple result sets, only the first will be returned.CommandTimeout: A duration that controls how long the server-side query is allowed to run before it is canceled. The default value is ten minutes.ConnectionTimeout: A duration that controls how long to wait before abandoning an attempt to make a connection to the server. The default value is driver-dependent.HierarchicalNavigation: A logical (true/false) that sets whether to view the tables grouped by their schema names (default is false).",
                    "Explain": "The record parameter is specified as [option1 = value1, option2 = value2...] or [Query = \"select ...\"]",
                    "pages": []
                },
                {
                    "title": "WebAction.Request",
                    "Syntax": "WebAction.Request(method as text, url as text, optional options as nullable record) as action.",
                    "About": "Creates an action that, when executed, will return the results of performing a method request against url using HTTP as a binary value. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Query: Programmatically add query parameters to the URL without having to worry about escaping.ApiKeyName: If the target site has a notion of an API key, this parameter can be used to specify the name (not the value) of the key parameter that must be used in the URL. The actual key value is provided in the credential.Headers: Specifying this value as a record will supply additional headers to an HTTP request.Timeout: Specifying this value as a duration will change the timeout for an HTTP request. The default value is 100 seconds.ExcludedFromCacheKey: Specifying this value as a list will exclude these HTTP header keys from being part of the calculation for caching data.IsRetry: Specifying this logical value as true will ignore any existing response in the cache when fetching data.ManualStatusHandling: Specifying this value as a list will prevent any builtin handling for HTTP requests whose response has one of these status codes.RelativePath: Specifying this value as text appends it to the base URL before making the request.Content: Specifying this value will cause its contents to become the body of the HTTP request.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Web.BrowserContents",
                    "Syntax": "Web.BrowserContents(url as text, optional options as nullable record) as text.",
                    "About": "Returns the HTML for the specified url, as viewed by a web browser. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:ApiKeyName: If the target site has a notion of an API key, this parameter can be used to specify the name (not the value) of the key parameter that must be used in the URL. The actual key value is provided in the credential.WaitFor: Specifies a condition to wait for before downloading the HTML, in addition to waiting for the page to load (which is always done). Can be a record containing Timeout and/or Selector fields. If only a Timeout is specified, the function will wait the amount of time specified before downloading the HTML. If both a Selector and Timeout are specified, and the Timeout elapses before the Selector exists on the page, an error will be thrown. If a Selector is specified with no Timeout, a default Timeout of 30 seconds is applied.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Web.Contents",
                    "Syntax": "Web.Contents(url as text, optional options as nullable record) as binary.",
                    "About": "Returns the contents downloaded from url as binary. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Query: Programmatically add query parameters to the URL without having to worry about escaping.ApiKeyName: If the target site has a notion of an API key, this parameter can be used to specify the name (not the value) of the key parameter that must be used in the URL. The actual key value is provided in the credential.Headers: Specifying this value as a record will supply additional headers to an HTTP request.Timeout: Specifying this value as a duration will change the timeout for an HTTP request. The default value is 100 seconds.ExcludedFromCacheKey: Specifying this value as a list will exclude these HTTP header keys from being part of the calculation for caching data.IsRetry: Specifying this logical value as true will ignore any existing response in the cache when fetching data.ManualStatusHandling: Specifying this value as a list will prevent any builtin handling for HTTP requests whose response has one of these status codes.RelativePath: Specifying this value as text appends it to the base URL before making the request.Content: Specifying this value changes the web request from a GET to a POST, using the value of the option as the content of the POST.The HTTP request is made as either a GET (when no Content is specified) or a POST (when there is Content). POST requests may only be made anonymously.The headers of the HTTP response are available as metadata on the binary result. Outside of a custom data connector context, only a subset of response headers is available (for security reasons).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Web.Headers",
                    "Syntax": "Web.Headers(url as text, optional options as nullable record) as record",
                    "About": "Returns the headers downloaded from url as a record. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Query: Programmatically add query parameters to the URL without having to worry about escaping.ApiKeyName: If the target site has a notion of an API key, this parameter can be used to specify the name (not the value) of the key parameter that must be used in the URL. The actual key value is provided in the credential.Headers: Specifying this value as a record will supply additional headers to an HTTP request.Timeout: Specifying this value as a duration will change the timeout for an HTTP request. The default value is 100 seconds.ExcludedFromCacheKey: Specifying this value as a list will exclude these HTTP header keys from being part of the calculation for caching data.IsRetry: Specifying this logical value as true will ignore any existing response in the cache when fetching data.ManualStatusHandling: Specifying this value as a list will prevent any builtin handling for HTTP requests whose response has one of these status codes.RelativePath: Specifying this value as text appends it to the base URL before making the request.",
                    "Explain": "Retrieve the HTTP headers for \"https://bing.com/search?q=Power+Query\" using the RelativePath and Query options.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0searchText = \"Power Query\"in\u00a0\u00a0\u00a0\u00a0Web.Headers(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"https://www.bing.com\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0RelativePath = \"search\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Query = [q = searchText]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\u00a0\u00a0\u00a0\u00a0)OutputPower Query M([\u00a0\u00a0\u00a0\u00a0#\"Cache-Control\" = \"private, max-age=0\",\u00a0\u00a0\u00a0\u00a0#\"Content-Encoding\" = \"gzip\",\u00a0\u00a0\u00a0\u00a0#\"Content-Length\" = \"0\",\u00a0\u00a0\u00a0\u00a0#\"Content-Type\" = \"text/html; charset=utf-8\",\u00a0\u00a0\u00a0\u00a0Date = \"Tue, 14 Dec 2021 16:57:25 GMT\",\u00a0\u00a0\u00a0\u00a0Expires = \"Tue, 14 Dec 2021 16:56:25 GMT\",\u00a0\u00a0\u00a0\u00a0Vary = \"Accept-Encoding\"]meta [\u00a0\u00a0\u00a0\u00a0Response.Status = 200])",
                    "pages": []
                },
                {
                    "title": "Web.Page",
                    "Syntax": "Web.Page(html as any) as table.",
                    "About": "Returns the contents of the HTML document broken into its constituent structures, as well as a representation of the full document and its text after removing tags.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Xml.Document",
                    "Syntax": "Xml.Document(contents as any, optional encoding as nullable number) as table.",
                    "About": "Returns the contents of the XML document as a hierarchical table.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Xml.Tables",
                    "Syntax": "Xml.Tables(contents as any, optional options as nullable record, optional encoding as nullable number) as table.",
                    "About": "Returns the contents of the XML document as a nested collection of flattened tables.",
                    "Explain": "Retrieve the contents of a local XML file.UsagePower Query MXml.Tables(File.Contents(\"C:\\invoices.xml\"))Outputtable",
                    "pages": []
                },
                {
                    "title": "Binary Functions",
                    "Syntax": null,
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.7BitEncodedSignedInteger",
                    "Syntax": "BinaryFormat.7BitEncodedSignedInteger(binary as binary) as any",
                    "About": "A binary format that reads a 64-bit signed integer that was encoded using a 7-bit variable-length encoding.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Binary functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "BinaryFormat.7BitEncodedUnsignedInteger",
                    "Syntax": "BinaryFormat.7BitEncodedUnsignedInteger(binary as binary) as any",
                    "About": "A binary format that reads a 64-bit unsigned integer that was encoded using a 7-bit variable-length encoding.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Binary",
                    "Syntax": "BinaryFormat.Binary(optional length as any) as function",
                    "About": "Returns a binary format that reads a binary value. If length is specified, the binary value will contain that many bytes. If length is not specified, the binary value will contain the remaining bytes. The length can be specified either as a number, or as a binary format of the length that precedes the binary data.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Byte",
                    "Syntax": "BinaryFormat.Byte(binary as binary) as any",
                    "About": "A binary format that reads an 8-bit unsigned integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.ByteOrder",
                    "Syntax": "BinaryFormat.ByteOrder(binaryFormat as function, byteOrder as number) as function",
                    "About": "Returns a binary format with the byte order specified by binaryFormat. The default byte order is ByteOrder.BigEndian.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Choice",
                    "Syntax": "BinaryFormat.Choice(binaryFormat as function, chooseFunction as function, optional type as nullable type, optional combineFunction as nullable function) as function",
                    "About": "Returns a binary format that chooses the next binary format based on a value that has already been read. The binary format value produced by this function works in stages:The binary format specified by the binaryFormat parameter is used to read a value.The value is passed to the choice function specified by the chooseFunction parameter.The choice function inspects the value and returns a second binary format.The second binary format is used to read a second value.If the combine function is specified, then the first and second values are passed to the combine function, and the resulting value is returned.If the combine function is not specified, the second value is returned.The second value is returned.The optional type parameter indicates the type of binary format that will be returned by the choice function. Either type any, type list, or type binary may be specified. If the type parameter is not specified, then type any is used. If type list or type binary is used, then the system may be able to return a streaming binary or list value instead of a buffered one, which may reduce the amount of memory necessary to read the format.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Decimal",
                    "Syntax": "BinaryFormat.Decimal(binary as binary) as any",
                    "About": "A binary format that reads a .NET 16-byte decimal value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Double",
                    "Syntax": "BinaryFormat.Double(binary as binary) as any",
                    "About": "A binary format that reads an 8-byte IEEE double-precision floating point value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Group",
                    "Syntax": "BinaryFormat.Group(binaryFormat as function, group as list, optional extra as nullable function, optional lastKey as any) as function",
                    "About": "The parameters are as follows:The binaryFormat parameter specifies the binary format of the key value.The group parameter provides information about the group of known items.The optional extra parameter can be used to specify a function that will return a binary format value for the value following any key that was unexpected. If the extra parameter is not specified, then an error will be raised if there are unexpected key values.The group parameter specifies a list of item definitions. Each item definition is a list, containing 3-5 values, as follows:Key value. The value of the key that corresponds to the item. This must be unique within the set of items.Item format. The binary format corresponding to the value of the item. This allows each item to have a different format.Item occurrence. The BinaryOccurrence.Type value for how many times the item is expected to appear in the group. Required items that are not present cause an error. Required or optional duplicate items are handled like unexpected key values.Default item value (optional). If the default item value appears in the item definition list and is not null, then it will be used instead of the default. The default for repeating or optional items is null, and the default for repeating values is an empty list { }.Item value transform (optional). If the item value transform function is present in the item definition list and is not null, then it will be called to transform the item value before it is returned. The transform function is only called if the item appears in the input (it will never be called with the default value).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Length",
                    "Syntax": "BinaryFormat.Length(binaryFormat as function, length as any) as function",
                    "About": "Returns a binary format that limits the amount of data that can be read. Both BinaryFormat.List and BinaryFormat.Binary can be used to read until end of the data. BinaryFormat.Length can be used to limit the number of bytes that are read. The binaryFormat parameter specifies the binary format to limit. The length parameter specifies the number of bytes to read. The length parameter may either be a number value, or a binary format value that specifies the format of the length value that appears that precedes the value being read.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.List",
                    "Syntax": "BinaryFormat.List(binaryFormat as function, optional countOrCondition as any) as function",
                    "About": "Returns a binary format that reads a sequence of items and returns a list. The binaryFormat parameter specifies the binary format of each item. There are three ways to determine the number of items read:If the countOrCondition is not specified, then the binary format will read until there are no more items.If the countOrCondition is a number, then the binary format will read that many items.If the countOrCondition is a function, then that function will be invoked for each item read. The function returns true to continue, and false to stop reading items. The final item is included in the list.If the countOrCondition is a binary format, then the count of items is expected to precede the list, and the specified format is used to read the count.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Null",
                    "Syntax": "BinaryFormat.Null(binary as binary) as any",
                    "About": "A binary format that reads zero bytes and returns null.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Record",
                    "Syntax": "BinaryFormat.Record(record as record) as function",
                    "About": "Returns a binary format that reads a record. The record parameter specifies the format of the record. Each field in the record can have a different binary format. If a field contains a value that is not a binary format value, then no data is read for that field, and the field value is echoed to the result.",
                    "Explain": "Read a record containing one 16-bit integer and one 32-bit integer.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0binaryData = #binary({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00, 0x01,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00, 0x00, 0x00, 0x02\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0recordFormat = BinaryFormat.Record([\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0A = BinaryFormat.UnsignedInteger16,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0B = BinaryFormat.UnsignedInteger32\u00a0\u00a0\u00a0\u00a0])in\u00a0\u00a0\u00a0\u00a0recordFormat(binaryData)Output[A = 1, B = 2]",
                    "pages": []
                },
                {
                    "title": "BinaryFormat.SignedInteger16",
                    "Syntax": "BinaryFormat.SignedInteger16(binary as binary) as any",
                    "About": "A binary format that reads a 16-bit signed integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.SignedInteger32",
                    "Syntax": "BinaryFormat.SignedInteger32(binary as binary) as any",
                    "About": "A binary format that reads a 32-bit signed integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.SignedInteger64",
                    "Syntax": "BinaryFormat.SignedInteger64(binary as binary) as any",
                    "About": "A binary format that reads a 64-bit signed integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Single",
                    "Syntax": "BinaryFormat.Single(binary as binary) as any",
                    "About": "A binary format that reads a 4-byte IEEE single-precision floating point value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Text",
                    "Syntax": "BinaryFormat.Text(length as any, optional encoding as nullable number) as function",
                    "About": "Returns a binary format that reads a text value. The length specifies the number of bytes to decode, or the binary format of the length that precedes the text. The optional encoding value specifies the encoding of the text. If the encoding is not specified, then the encoding is determined from the Unicode byte order marks. If no byte order marks are present, then TextEncoding.Utf8 is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.Transform",
                    "Syntax": "BinaryFormat.Transform(binaryFormat as function, function as function) as function",
                    "About": "Returns a binary format that will transform the values read by another binary format. The binaryFormat parameter specifies the binary format that will be used to read the value. The function is invoked with the value read, and returns the transformed value.",
                    "Explain": "Read a byte and add one to it.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0binaryData = #binary({1}),\u00a0\u00a0\u00a0\u00a0transformFormat = BinaryFormat.Transform(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BinaryFormat.Byte,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(x) => x + 1\u00a0\u00a0\u00a0\u00a0)in\u00a0\u00a0\u00a0\u00a0transformFormat(binaryData)Output2",
                    "pages": []
                },
                {
                    "title": "BinaryFormat.UnsignedInteger16",
                    "Syntax": "BinaryFormat.UnsignedInteger16(binary as binary) as any",
                    "About": "A binary format that reads a 16-bit unsigned integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.UnsignedInteger32",
                    "Syntax": "BinaryFormat.UnsignedInteger32(binary as binary) as any",
                    "About": "A binary format that reads a 32-bit unsigned integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "BinaryFormat.UnsignedInteger64",
                    "Syntax": "BinaryFormat.UnsignedInteger64(binary as binary) as any",
                    "About": "A binary format that reads a 64-bit unsigned integer.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "#binary",
                    "Syntax": "#binary(value as any) as any",
                    "About": "Creates a binary value from a list of numbers or a base 64 encoded text value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.ApproximateLength",
                    "Syntax": "Binary.ApproximateLength(binary as nullable binary) as nullable number",
                    "About": "Returns the approximate length of binary, or an error if the data source doesn't support an approximate length.",
                    "Explain": "Get the approximate length of the binary value.UsagePower Query MBinary.ApproximateLength(Binary.FromText(\"i45WMlSKjQUA\", BinaryEncoding.Base64))Output9",
                    "pages": []
                },
                {
                    "title": "Binary.Buffer",
                    "Syntax": "Binary.Buffer(binary as nullable binary) as nullable binary",
                    "About": "Buffers the binary value in memory. The result of this call is a stable binary value, which means it will have a deterministic length and order of bytes.",
                    "Explain": "Create a stable version of the binary value.UsagePower Query MBinary.Buffer(Binary.FromList({0..10}))Output#binary({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})",
                    "pages": []
                },
                {
                    "title": "Binary.Combine",
                    "Syntax": "Binary.Combine(binaries as list) as binary",
                    "About": "Combines a list of binaries into a single binary.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.Compress",
                    "Syntax": "Binary.Compress(binary as nullable binary, compressionType as number) as nullable binary",
                    "About": "Compresses a binary value using the given compression type. The result of this call is a compressed copy of the input. Compression types include:Compression.GZipCompression.Deflate",
                    "Explain": "Compress the binary value.UsagePower Query MBinary.Compress(Binary.FromList(List.Repeat({10}, 1000)), Compression.Deflate)Output#binary({227, 226, 26, 5, 163, 96, 20, 12, 119, 0, 0})",
                    "pages": []
                },
                {
                    "title": "Binary.Decompress",
                    "Syntax": "Binary.Decompress(binary as nullable binary, compressionType as number) as nullable binary",
                    "About": "Decompresses a binary value using the given compression type. The result of this call is a decompressed copy of the input. Compression types include:Compression.GZipCompression.Deflate",
                    "Explain": "Decompress the binary value.UsagePower Query MBinary.Decompress(#binary({115, 103, 200, 7, 194, 20, 134, 36, 134, 74, 134, 84, 6, 0}), Compression.Deflate)Output#binary({71, 0, 111, 0, 111, 0, 100, 0, 98, 0, 121, 0, 101, 0})",
                    "pages": []
                },
                {
                    "title": "Binary.From",
                    "Syntax": "Binary.From(value as any, optional encoding as nullable number) as nullable binary",
                    "About": "Returns a binary value from the given value. If the given value is null, Binary.From returns null. If the given value is binary, value is returned. Values of the following types can be converted to a binary value:Text: A binary value from the text representation. Refer to Binary.FromText for details.If value is of any other type, an error is returned.",
                    "Explain": "Get the binary value of \"1011\".UsagePower Query MBinary.From(\"1011\")OutputBinary.FromText(\"1011\", BinaryEncoding.Base64)",
                    "pages": []
                },
                {
                    "title": "Binary.FromList",
                    "Syntax": "Binary.FromList(list as list) as binary",
                    "About": "Converts a list of numbers into a binary value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.FromText",
                    "Syntax": "Binary.FromText(text as nullable text, optional encoding as nullable number) as nullable binary",
                    "About": "Returns the result of converting text value text to a binary (list of number). encoding may be specified to indicate the encoding used in the text value. The following BinaryEncoding values may be used for encoding.BinaryEncoding.Base64: Base 64 encodingBinaryEncoding.Hex: Hex encoding",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.InferContentType",
                    "Syntax": "Binary.InferContentType(source as binary) as record",
                    "About": "Returns a record with field Content.Type that contains the inferred MIME-type. If the inferred content type is text/*, and an encoding code page is detected, then additionally returns field Content.Encoding that contains the encoding of the stream. If the inferred content type is text/csv, and the format is delimited, additionally returns field Csv.PotentialDelimiter containing a table for analysis of potential delimiters. If the inferred content type is text/csv, and the format is fixed-width, additionally returns field Csv.PotentialPositions containing a list for analysis of potential fixed width column positions.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.Length",
                    "Syntax": "Binary.Length(binary as nullable binary) as nullable number",
                    "About": "Returns the number of characters.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.Range",
                    "Syntax": "Binary.Range(binary as binary, offset as number, optional count as nullable number) as binary",
                    "About": "Returns a subset of the binary value beginning at the offset binary. An optional parameter, offset, sets the maximum length of the subset.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.Split",
                    "Syntax": "Binary.Split(binary as binary, pageSize as number) as list",
                    "About": "Splits binary into a list of binaries where the first element of the output list is a binary containing the first pageSize bytes from the source binary, the next element of the output list is a binary containing the next pageSize bytes from the source binary, and so on.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.ToList",
                    "Syntax": "Binary.ToList(binary as binary) as list",
                    "About": "Converts a binary value into a list of numbers.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.ToText",
                    "Syntax": "Binary.ToText(binary as nullable binary, optional encoding as nullable number) as nullable text",
                    "About": "Returns the result of converting a binary list of numbers binary into a text value. Optionally, encoding may be specified to indicate the encoding to be used in the text value produced The following BinaryEncoding values may be used for encoding.BinaryEncoding.Base64: Base 64 encodingBinaryEncoding.Hex: Hex encoding",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.View",
                    "Syntax": "Binary.View(binary as nullable binary, handlers as record) as binary",
                    "About": "Returns a view of binary where the functions specified in handlers are used in lieu of the default behavior of an operation when the operation is applied to the view.If binary is provided, all handler functions are optional. If binary isn't provided, the GetStream handler function is required. If a handler function isn't specified for an operation, the default behavior of the operation is applied to binary instead (except in the case of GetExpression).Handler functions must return a value that is semantically equivalent to the result of applying the operation against binary (or the resulting view in the case of GetExpression).If a handler function raises an error, the default behavior of the operation is applied to the view.Binary.View can be used to implement folding to a data source\u2013the translation of M queries into source-specific operations (for example, to download a section of a file).",
                    "Explain": "Create a basic view that doesn't require accessing the data in order to determine the length.UsagePower Query MBinary.View(\u00a0\u00a0\u00a0\u00a0null,\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetLength = () => 12,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetStream = () => Text.ToBinary(\"hello world!\")\u00a0\u00a0\u00a0\u00a0])OutputPower Query MText.ToBinary(\"hello world!\")",
                    "pages": []
                },
                {
                    "title": "Binary.ViewError",
                    "Syntax": "Binary.ViewError(errorRecord as record) as record",
                    "About": "Creates a modified error record from errorRecord which won't trigger a fallback when thrown by a handler defined on a view (via Binary.View).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Binary.ViewFunction",
                    "Syntax": "Binary.ViewFunction(function as function) as function",
                    "About": "Creates a view function based on function that can be handled in a view created by Binary.View.The OnInvoke handler of Binary.View can be used to define a handler for the view function.As with the handlers for built-in operations, if no OnInvoke handler is specified, or if it does not handle the view function, or if an error is raised by the handler, function is applied on top of the view.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Combiner functions",
                    "Syntax": null,
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Combiner.CombineTextByDelimiter",
                    "Syntax": "Combiner.CombineTextByDelimiter(delimiter as text, optional quoteStyle as nullable number) as function",
                    "About": "Returns a function that combines a list of text values into a single text value using the specified delimiter.",
                    "Explain": "Example 1Combine a list of text values using a semicolon delimiter.UsagePower Query MCombiner.CombineTextByDelimiter(\";\")({\"a\", \"b\", \"c\"})Output\"a;b;c\"Example 2Combine the text of two columns using a comma delimiter and CSV-style quoting.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0Source = #table(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [Column1 = text, Column2 = text],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\"a\", \"b\"}, {\"c\", \"d,e,f\"}}\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0Merged = Table.CombineColumns(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Source,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"Column1\", \"Column2\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Combiner.CombineTextByDelimiter(\",\", QuoteStyle.Csv),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Merged\"\u00a0\u00a0\u00a0\u00a0)in\u00a0\u00a0\u00a0\u00a0MergedOutputPower Query M#table(\u00a0\u00a0\u00a0\u00a0type table [Merged = text],\u00a0\u00a0\u00a0\u00a0{{\"a,b\"}, {\"c,\"\"d,e,f\"\"\"}})",
                    "pages": []
                }
            ]
        },
        {
            "title": "Combiner functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Combiner.CombineTextByDelimiter",
                    "Syntax": "Combiner.CombineTextByDelimiter(delimiter as text, optional quoteStyle as nullable number) as function",
                    "About": "Returns a function that combines a list of text values into a single text value using the specified delimiter.",
                    "Explain": "Example 1Combine a list of text values using a semicolon delimiter.UsagePower Query MCombiner.CombineTextByDelimiter(\";\")({\"a\", \"b\", \"c\"})Output\"a;b;c\"Example 2Combine the text of two columns using a comma delimiter and CSV-style quoting.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0Source = #table(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [Column1 = text, Column2 = text],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\"a\", \"b\"}, {\"c\", \"d,e,f\"}}\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0Merged = Table.CombineColumns(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Source,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"Column1\", \"Column2\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Combiner.CombineTextByDelimiter(\",\", QuoteStyle.Csv),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Merged\"\u00a0\u00a0\u00a0\u00a0)in\u00a0\u00a0\u00a0\u00a0MergedOutputPower Query M#table(\u00a0\u00a0\u00a0\u00a0type table [Merged = text],\u00a0\u00a0\u00a0\u00a0{{\"a,b\"}, {\"c,\"\"d,e,f\"\"\"}})",
                    "pages": []
                },
                {
                    "title": "Combiner.CombineTextByEachDelimiter",
                    "Syntax": "Combiner.CombineTextByEachDelimiter(delimiters as list, optional quoteStyle as nullable number) as function",
                    "About": "Returns a function that combines a list of text into a single text using each specified delimiter in sequence.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Combiner.CombineTextByLengths",
                    "Syntax": "Combiner.CombineTextByLengths(lengths as list, optional template as nullable text) as function",
                    "About": "Returns a function that combines a list of text into a single text using the specified lengths.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Comparer functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Comparer.Equals",
                    "Syntax": "Comparer.Equals(comparer as function, x as any, y as any) as logical",
                    "About": "Returns a logical value based on the equality check over the two given values, x and y, using the provided comparer.comparer is a Comparer which is used to control the comparison. Comparers can be used to provide case-insensitive or culture and locale-aware comparisons.The following built-in comparers are available in the formula language:Comparer.Ordinal: Used to perform an exact ordinal comparisonComparer.OrdinalIgnoreCase: Used to perform an exact ordinal case-insensitive comparisonComparer.FromCulture: Used to perform a culture-aware comparison",
                    "Explain": "Compare \"1\" and \"A\" using \"en-US\" locale to determine if the values are equal.UsagePower Query MComparer.Equals(Comparer.FromCulture(\"en-US\"), \"1\", \"A\")Outputfalse",
                    "pages": []
                },
                {
                    "title": "Comparer.FromCulture",
                    "Syntax": "Comparer.FromCulture(culture as text, optional ignoreCase as nullable logical) as function",
                    "About": "Returns a comparer function given the culture and a logical value ignoreCase for case sensitivity for the comparison. The default value for ignoreCase is false. The value for culture are well known text representations of locales used in the .NET framework.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Comparer.Ordinal",
                    "Syntax": "Comparer.Ordinal(x as any, y as any) as number",
                    "About": "Returns a comparer function which uses Ordinal rules to compare the provided values x and y.",
                    "Explain": "Using Ordinal rules, compare if \"encyclop\u00e6dia\" and \"encyclopaedia\" are equivalent. Note these are equivalent using Comparer.FromCulture(\"en-US\").UsagePower Query MComparer.Equals(Comparer.Ordinal, \"encyclop\u00e6dia\", \"encyclopaedia\")Outputfalse",
                    "pages": []
                },
                {
                    "title": "Comparer.OrdinalIgnoreCase",
                    "Syntax": "Comparer.OrdinalIgnoreCase(x as any, y as any) as number",
                    "About": "Returns a case-insensitive comparer function which uses Ordinal rules to compare the provided values x and y.",
                    "Explain": "Using case-insensitive Ordinal rules, compare \"Abc\" with \"abc\". Note \"Abc\" is less than \"abc\" using Comparer.Ordinal.UsagePower Query MComparer.OrdinalIgnoreCase(\"Abc\", \"abc\")Output0",
                    "pages": []
                }
            ]
        },
        {
            "title": "Date functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Date.AddDays",
                    "Syntax": "Date.AddDays(dateTime as any, numberOfDays as number) as any",
                    "About": "Returns the date, datetime, or datetimezone result from adding numberOfDays days to the datetime value dateTime.dateTime: The date, datetime, or datetimezone value to which days are being added.numberOfDays: The number of days to add.",
                    "Explain": "Add 5 days to the date, datetime, or datetimezone value representing the date 5/14/2011.UsagePower Query MDate.AddDays(#date(2011, 5, 14), 5)Output#date(2011, 5, 19)",
                    "pages": []
                },
                {
                    "title": "Date.AddMonths",
                    "Syntax": "Date.AddMonths(dateTime as any, numberOfMonths as number) as any",
                    "About": "Returns the date, datetime, or datetimezone result from adding numberOfMonths months to the datetime value dateTime.dateTime: The date, datetime, or datetimezone value to which months are being added.numberOfMonths: The number of months to add.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Date.AddQuarters",
                    "Syntax": "Date.AddQuarters(dateTime as any, numberOfQuarters as number) as any",
                    "About": "Returns the date, datetime, or datetimezone result from adding numberOfQuarters quarters to the datetime value dateTime.dateTime: The date, datetime, or datetimezone value to which quarters are being added.numberOfQuarters: The number of quarters to add.",
                    "Explain": "Add 1 quarter to the date, datetime, or datetimezone value representing the date 5/14/2011.UsagePower Query MDate.AddQuarters(#date(2011, 5, 14), 1)Output#date(2011, 8, 14)",
                    "pages": []
                },
                {
                    "title": "Date.AddWeeks",
                    "Syntax": "Date.AddWeeks(dateTime as any, numberOfWeeks as number) as any",
                    "About": "Returns the date, datetime, or datetimezone result from adding numberOfWeeks weeks to the datetime value dateTime.dateTime: The date, datetime, or datetimezone value to which weeks are being added.numberOfWeeks: The number of weeks to add.",
                    "Explain": "Add 2 weeks to the date, datetime, or datetimezone value representing the date 5/14/2011.UsagePower Query MDate.AddWeeks(#date(2011, 5, 14), 2)Output#date(2011, 5, 28)",
                    "pages": []
                },
                {
                    "title": "Date.AddYears",
                    "Syntax": "Date.AddYears(dateTime as any, numberOfYears as number) as any",
                    "About": "Returns the date, datetime, or datetimezone result of adding numberOfYears to a datetime value dateTime.dateTime: The date, datetime, or datetimezone value to which years are added.numberOfYears: The number of years to add.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Date.Day",
                    "Syntax": "Date.Day(dateTime as any) as nullable number",
                    "About": "Returns the day component of a date, datetime, or datetimezone value.dateTime: A date, datetime, or datetimezone value from which the day component is extracted.",
                    "Explain": "Get the day component of a date, datetime, or datetimezone value representing the date and time of 5/14/2011 05:00:00 PM.UsagePower Query MDate.Day(#datetime(2011, 5, 14, 17, 0, 0))Output14",
                    "pages": []
                },
                {
                    "title": "Date.DayOfWeek",
                    "Syntax": "Date.DayOfWeek(dateTime as any, optional firstDayOfWeek as nullable number) as nullable number",
                    "About": "Returns a number (from 0 to 6) indicating the day of the week of the provided dateTime.dateTime: A date, datetime, or datetimezone value.firstDayOfWeek: A Day value indicating which day should be considered the first day of the week. Allowed values are Day.Sunday, Day.Monday, Day.Tuesday, Day.Wednesday, Day.Thursday, Day.Friday, or Day.Saturday. If unspecified, a culture-dependent default is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Date.DayOfWeekName",
                    "Syntax": "Date.DayOfWeekName(date as any, optional culture as nullable text)",
                    "About": "Returns the day of the week name for the provided date. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the day of the week name.UsagePower Query MDate.DayOfWeekName(#date(2011, 12, 31), \"en-US\")Output\"Saturday\"",
                    "pages": []
                },
                {
                    "title": "Date.DayOfYear",
                    "Syntax": "Date.DayOfYear(dateTime as any) as nullable number",
                    "About": "Returns a number representing the day of the year in the provided date, datetime, or datetimezone value, dateTime.",
                    "Explain": "The day of the year for March 1st, 2011.UsagePower Query MDate.DayOfYear(#date(2011, 03, 01))Output60",
                    "pages": []
                },
                {
                    "title": "Date.DaysInMonth",
                    "Syntax": "Date.DaysInMonth(dateTime as any) as nullable number",
                    "About": "Returns the number of days in the month in the date, datetime, or datetimezone value dateTime.dateTime: A date, datetime, or datetimezone value for which the number of days in the month is returned.",
                    "Explain": "Number of days in the month December as represented by #date(2011, 12, 01).UsagePower Query MDate.DaysInMonth(#date(2011, 12, 01))Output31",
                    "pages": []
                },
                {
                    "title": "Date.EndOfDay",
                    "Syntax": "Date.EndOfDay(dateTime as any) as any",
                    "About": "Returns the end of the day represented by dateTime. Time zone information is preserved.dateTime: A date, datetime, or datetimezone value from from which the end of the day is calculated.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Date.EndOfMonth",
                    "Syntax": "Date.EndOfMonth(dateTime as any) as any",
                    "About": "Returns the end of the month that contains dateTime.dateTime: A date, datetime, or datetimezone value from which the end of the month is calculated.",
                    "Explain": "Example 1Get the end of the month for 5/14/2011.UsagePower Query MDate.EndOfMonth(#date(2011, 5, 14))Output#date(2011, 5, 31)Example 2Get the end of the month for 5/17/2011 05:00:00 PM -7:00.UsagePower Query MDate.EndOfMonth(#datetimezone(2011, 5, 17, 5, 0, 0, -7, 0))Output#datetimezone(2011, 5, 31, 23, 59, 59.9999999, -7, 0)",
                    "pages": []
                },
                {
                    "title": "Date.EndOfQuarter",
                    "Syntax": "Date.EndOfQuarter(dateTime as any) as any",
                    "About": "Returns the end of the quarter that contains dateTime. Time zone information is preserved.dateTime: A date, datetime, or datetimezone value from which the end of the quarter is calculated.",
                    "Explain": "Find the end of the quarter for October 10th, 2011, 8:00AM.UsagePower Query MDate.EndOfQuarter(#datetime(2011, 10, 10, 8, 0, 0))Output#datetime(2011, 12, 31, 23, 59, 59.9999999)",
                    "pages": []
                },
                {
                    "title": "Date.EndOfWeek",
                    "Syntax": "Date.EndOfWeek(dateTime as any, optional firstDayOfWeek as nullable number) as any",
                    "About": "Returns the end of the week that contains dateTime. This function takes an optional Day, firstDayOfWeek, to set as the first day of the week for this relative calculation. The default value is Day.Sunday.dateTime: A date, datetime, or datetimezone value from which the last day of the week is calculatedfirstDayOfWeek: [Optional] A Day.Type value representing the first day of the week. Possible values are Day.Sunday, Day.Monday, Day.Tuesday, Day.Wednesday, Day.Thursday, Day.Friday and Day.Saturday. The default value is Day.Sunday.",
                    "Explain": "Example 1Get the end of the week for 5/14/2011.UsagePower Query MDate.EndOfWeek(#date(2011, 5, 14))Output#date(2011, 5, 14)Example 2Get the end of the week for 5/17/2011 05:00:00 PM -7:00, with Sunday as the first day of the week.UsagePower Query MDate.EndOfWeek(#datetimezone(2011, 5, 17, 5, 0, 0, -7, 0), Day.Sunday)\u00a0Output#datetimezone(2011, 5, 21, 23, 59, 59.9999999, -7, 0)",
                    "pages": []
                },
                {
                    "title": "Date.EndOfYear",
                    "Syntax": "Date.EndOfYear(dateTime as any) as any",
                    "About": "Returns the end of the year that contains dateTime, including fractional seconds. Time zone information is preserved.dateTime: A date, datetime, or datetimezone value from which the end of the year is calculated.",
                    "Explain": "Example 1Get the end of the year for 5/14/2011 05:00:00 PM.UsagePower Query MDate.EndOfYear(#datetime(2011, 5, 14, 17, 0, 0))Output#datetime(2011, 12, 31, 23, 59, 59.9999999)Example 2Get the end of hour for 5/17/2011 05:00:00 PM -7:00.UsagePower Query MDate.EndOfYear(#datetimezone(2011, 5, 17, 5, 0, 0, -7, 0))Output#datetimezone(2011, 12, 31, 23, 59, 59.9999999, -7, 0)",
                    "pages": []
                },
                {
                    "title": "Date.From",
                    "Syntax": "Date.From(value as any, optional culture as nullable text) as nullable date",
                    "About": "Returns a date value from the given value. An optional culture> may also be provided (for example, \"en-US\"). If the given value is null, Date.From returns null. If the given value is date, value is returned. Values of the following types can be converted to a date value:text: A date value from textual representation. Refer to Date.FromText for details.datetime: The date component of the value.datetimezone: The date component of the local datetime equivalent of value.number: The date component of the datetime equivalent of the OLE Automation Date expressed by value.If value is of any other type, an error is returned.",
                    "Explain": "Example 1Convert 43910 to a date value.UsagePower Query MDate.From(43910)Output#date(2020, 3, 20)Example 2Convert #datetime(1899, 12, 30, 06, 45, 12) to a date value.UsagePower Query MDate.From(#datetime(1899, 12, 30, 06, 45, 12))Output#date(1899, 12, 30)",
                    "pages": []
                },
                {
                    "title": "Date.FromText",
                    "Syntax": "Date.FromText(text as nullable text, optional options as any) as nullable date",
                    "About": "Creates a date value from a textual representation, text. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in parsing the date using a best effort.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"MMM\" is \"Jan\", \"Feb\", \"Mar\", ..., while in \"ru-RU\" \"MMM\" is \"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", .... When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options may also be a text value. This has the same behavior as if options = [Format = null, Culture = options].",
                    "Explain": "Example 1Convert \"2010-12-31\" into a date value.UsagePower Query MDate.FromText(\"2010-12-31\")Output#date(2010, 12, 31)Example 2Convert using a custom format and the German culture.UsagePower Query MDate.FromText(\"30 Dez 2010\", [Format=\"dd MMM yyyy\", Culture=\"de-DE\"])Output#date(2010, 12, 30)Example 3Find the date in the Gregorian calendar that corresponds to the beginning of 1400 in the Hijri calendar.UsagePower Query MDate.FromText(\"1400\", [Format=\"yyyy\", Culture=\"ar-SA\"])Output#date(1979, 11, 20)",
                    "pages": []
                },
                {
                    "title": "Date.IsInCurrentDay",
                    "Syntax": "Date.IsInCurrentDay(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current day, as determined by the current date and time on the system.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current day.UsagePower Query MDate.IsInCurrentDay(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInCurrentMonth",
                    "Syntax": "Date.IsInCurrentMonth(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current month, as determined by the current date and time on the system.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current month.UsagePower Query MDate.IsInCurrentMonth(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInCurrentQuarter",
                    "Syntax": "Date.IsInCurrentQuarter(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current quarter, as determined by the current date and time on the system.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current quarter.UsagePower Query MDate.IsInCurrentQuarter(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInCurrentWeek",
                    "Syntax": "Date.IsInCurrentWeek(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current week, as determined by the current date and time on the system.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current week.UsagePower Query MDate.IsInCurrentWeek(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInCurrentYear",
                    "Syntax": "Date.IsInCurrentYear(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current year, as determined by the current date and time on the system.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current year.UsagePower Query MDate.IsInCurrentYear(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextDay",
                    "Syntax": "Date.IsInNextDay(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next day, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the day after the current system time is in the next day.UsagePower Query MDate.IsInNextDay(Date.AddDays(DateTime.FixedLocalNow(), 1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextMonth",
                    "Syntax": "Date.IsInNextMonth(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next month, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the month after the current system time is in the next month.UsagePower Query MDate.IsInNextMonth(Date.AddMonths(DateTime.FixedLocalNow(), 1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextNDays",
                    "Syntax": "Date.IsInNextNDays(dateTime as any, days as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of days, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.dateTime: A date, datetime, or datetimezone value to be evaluated.days: The number of days.",
                    "Explain": "Determine if the day after the current system time is in the next two days.UsagePower Query MDate.IsInNextNDays(Date.AddDays(DateTime.FixedLocalNow(), 1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextNMonths",
                    "Syntax": "Date.IsInNextNMonths(dateTime as any, months as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of months, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.dateTime: A date, datetime, or datetimezone value to be evaluated.months: The number of months.",
                    "Explain": "Determine if the month after the current system time is in the next two months.UsagePower Query MDate.IsInNextNMonths(Date.AddMonths(DateTime.FixedLocalNow(), 1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextNQuarters",
                    "Syntax": "Date.IsInNextNQuarters(dateTime as any, quarters as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of quarters, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.dateTime: A date, datetime, or datetimezone value to be evaluated.quarters: The number of quarters.",
                    "Explain": "Determine if the quarter after the current system time is in the next two quarters.UsagePower Query MDate.IsInNextNQuarters(Date.AddQuarters(DateTime.FixedLocalNow(), 1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextNWeeks",
                    "Syntax": "Date.IsInNextNWeeks(dateTime as any, weeks as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of weeks, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.dateTime: A date, datetime, or datetimezone value to be evaluated.weeks: The number of weeks.",
                    "Explain": "Determine if the week after the current system time is in the next two weeks.UsagePower Query MDate.IsInNextNWeeks(Date.AddDays(DateTime.FixedLocalNow(), 7), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextNYears",
                    "Syntax": "Date.IsInNextNYears(dateTime as any, years as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of years, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.dateTime: A date, datetime, or datetimezone value to be evaluated.years: The number of years.",
                    "Explain": "Determine if the year after the current system time is in the next two years.UsagePower Query MDate.IsInNextNYears(Date.AddYears(DateTime.FixedLocalNow(), 1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextQuarter",
                    "Syntax": "Date.IsInNextQuarter(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next quarter, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the quarter after the current system time is in the next quarter.UsagePower Query MDate.IsInNextQuarter(Date.AddQuarters(DateTime.FixedLocalNow(), 1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextWeek",
                    "Syntax": "Date.IsInNextWeek(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next week, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the week after the current system time is in the next week.UsagePower Query MDate.IsInNextWeek(Date.AddDays(DateTime.FixedLocalNow(), 7))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInNextYear",
                    "Syntax": "Date.IsInNextYear(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next year, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the year after the current system time is in the next year.UsagePower Query MDate.IsInNextYear(Date.AddYears(DateTime.FixedLocalNow(), 1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousDay",
                    "Syntax": "Date.IsInPreviousDay(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous day, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the day before the current system time is in the previous day.UsagePower Query MDate.IsInPreviousDay(Date.AddDays(DateTime.FixedLocalNow(), -1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousMonth",
                    "Syntax": "Date.IsInPreviousMonth(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous month, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the month before the current system time is in the previous month.UsagePower Query MDate.IsInPreviousMonth(Date.AddMonths(DateTime.FixedLocalNow(), -1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousNDays",
                    "Syntax": "Date.IsInPreviousNDays(dateTime as any, days as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of days, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current day.dateTime: A date, datetime, or datetimezone value to be evaluated.`days: The number of days.",
                    "Explain": "Determine if the day before the current system time is in the previous two days.UsagePower Query MDate.IsInPreviousNDays(Date.AddDays(DateTime.FixedLocalNow(), -1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousNMonths",
                    "Syntax": "Date.IsInPreviousNMonths(dateTime as any, months as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of months, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current month.dateTime: A date, datetime, or datetimezone value to be evaluated.months: The number of months.",
                    "Explain": "Determine if the month before the current system time is in the previous two months.UsagePower Query MDate.IsInPreviousNMonths(Date.AddMonths(DateTime.FixedLocalNow(), -1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousNQuarters",
                    "Syntax": "Date.IsInPreviousNQuarters(dateTime as any, quarters as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of quarters, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.dateTime: A date, datetime, or datetimezone value to be evaluated.quarters: The number of quarters.",
                    "Explain": "Determine if the quarter before the current system time is in the previous two quarters.UsagePower Query MDate.IsInPreviousNQuarters(Date.AddQuarters(DateTime.FixedLocalNow(), -1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousNWeeks",
                    "Syntax": "Date.IsInPreviousNWeeks(dateTime as any, weeks as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of weeks, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.dateTime: A date, datetime, or datetimezone value to be evaluated.weeks: The number of weeks.",
                    "Explain": "Determine if the week before the current system time is in the previous two weeks.UsagePower Query MDate.IsInPreviousNWeeks(Date.AddDays(DateTime.FixedLocalNow(), -7), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousNYears",
                    "Syntax": "Date.IsInPreviousNYears(dateTime as any, years as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of years, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.dateTime: A date, datetime, or datetimezone value to be evaluated.years: The number of years.",
                    "Explain": "Determine if the year before the current system time is in the previous two years.UsagePower Query MDate.IsInPreviousNYears(Date.AddYears(DateTime.FixedLocalNow(), -1), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousQuarter",
                    "Syntax": "Date.IsInPreviousQuarter(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous quarter, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current quarter.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the quarter before the current system time is in the previous quarter.UsagePower Query MDate.IsInPreviousQuarter(Date.AddQuarters(DateTime.FixedLocalNow(), -1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousWeek",
                    "Syntax": "Date.IsInPreviousWeek(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous week, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current week.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the week before the current system time is in the previous week.UsagePower Query MDate.IsInPreviousWeek(Date.AddDays(DateTime.FixedLocalNow(), -7))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInPreviousYear",
                    "Syntax": "Date.IsInPreviousYear(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous year, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current year.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the year before the current system time is in the previous year.UsagePower Query MDate.IsInPreviousYear(Date.AddYears(DateTime.FixedLocalNow(), -1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsInYearToDate",
                    "Syntax": "Date.IsInYearToDate(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current year and is on or before the current day, as determined by the current date and time on the system.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the year to date.UsagePower Query MDate.IsInYearToDate(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.IsLeapYear",
                    "Syntax": "Date.IsLeapYear(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime falls in is a leap year.dateTime: A date, datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the year 2012, as represented by #date(2012, 01, 01) is a leap year.UsagePower Query MDate.IsLeapYear(#date(2012, 01, 01))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Date.Month",
                    "Syntax": "Date.Month(dateTime as any) as nullable number",
                    "About": "Returns the month component of the provided datetime value, dateTime.",
                    "Explain": "Find the month in #datetime(2011, 12, 31, 9, 15, 36).UsagePower Query MDate.Month(#datetime(2011, 12, 31, 9, 15, 36))Output12",
                    "pages": []
                },
                {
                    "title": "Date.MonthName",
                    "Syntax": "Date.MonthName(date as any, optional culture as nullable text) as nullable text",
                    "About": "Returns the name of the month component for the provided date. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the month name.UsagePower Query MDate.MonthName(#datetime(2011, 12, 31, 5, 0, 0), \"en-US\")Output\"December\"",
                    "pages": []
                },
                {
                    "title": "Date.QuarterOfYear",
                    "Syntax": "Date.QuarterOfYear(dateTime as any) as nullable number",
                    "About": "Returns a number from 1 to 4 indicating which quarter of the year the date dateTime falls in. dateTime can be a date, datetime, or datetimezone value.",
                    "Explain": "Find which quarter of the year the date #date(2011, 12, 31) falls in.UsagePower Query MDate.QuarterOfYear(#date(2011, 12, 31))Output4",
                    "pages": []
                },
                {
                    "title": "Date.StartOfDay",
                    "Syntax": "Date.StartOfDay(dateTime as any) as any",
                    "About": "Returns the start of the day represented by dateTime. dateTime must be a date, datetime, or datetimezone value.",
                    "Explain": "Find the start of the day for October 10th, 2011, 8:00AM.UsagePower Query MDate.StartOfDay(#datetime(2011, 10, 10, 8, 0, 0))Output#datetime(2011, 10, 10, 0, 0, 0)",
                    "pages": []
                },
                {
                    "title": "Date.StartOfMonth",
                    "Syntax": "Date.StartOfMonth(dateTime as any) as any",
                    "About": "Returns the start of the month that contains dateTime. dateTime must be a date or datetime value.",
                    "Explain": "Find the start of the month for October 10th, 2011, 8:10:32AM.UsagePower Query MDate.StartOfMonth(#datetime(2011, 10, 10, 8, 10, 32))Output#datetime(2011, 10, 1, 0, 0, 0)",
                    "pages": []
                },
                {
                    "title": "Date.StartOfQuarter",
                    "Syntax": "Date.StartOfQuarter(dateTime as any) as any",
                    "About": "Returns the start of the quarter that contains dateTime. dateTime must be a date, datetime, or datetimezone value.",
                    "Explain": "Find the start of the quarter for October 10th, 2011, 8:00AM.UsagePower Query MDate.StartOfQuarter(#datetime(2011, 10, 10, 8, 0, 0))Output#datetime(2011, 10, 1, 0, 0, 0)",
                    "pages": []
                },
                {
                    "title": "Date.StartOfWeek",
                    "Syntax": "Date.StartOfWeek(dateTime as any, optional firstDayOfWeek as nullable number) as any",
                    "About": "Returns the start of the week that contains dateTime. dateTime must be a date, datetime, or datetimezone value.",
                    "Explain": "Example 1Find the start of the week for Tuesday, October 11th, 2011.UsagePower Query MDate.StartOfWeek(#datetime(2011, 10, 11, 8, 10, 32))OutputPower Query M// Sunday, October 9th, 2011#datetime(2011, 10, 9, 0, 0, 0)Example 2Find the start of the week for Tuesday, October 11th, 2011, using Monday as the start of the week.UsagePower Query MDate.StartOfWeek(#datetime(2011, 10, 11, 8, 10, 32))OutputPower Query M// Monday, October 10th, 2011#datetime(2011, 10, 10, 0, 0, 0)",
                    "pages": []
                },
                {
                    "title": "Date.StartOfYear",
                    "Syntax": "Date.StartOfYear(dateTime as any) as any",
                    "About": "Returns the start of the year that contains dateTime. dateTime must be a date, datetime, or datetimezone value.",
                    "Explain": "Find the start of the year for October 10th, 2011, 8:10:32AM.UsagePower Query MDate.StartOfYear(#datetime(2011, 10, 10, 8, 10, 32))Output#datetime(2011, 1, 1, 0, 0, 0)",
                    "pages": []
                },
                {
                    "title": "Date.ToRecord",
                    "Syntax": "Date.ToRecord(date as date) as record",
                    "About": "Returns a record containing the parts of the given date value, date.date: A date value for from which the record of its parts is to be calculated.",
                    "Explain": "Convert the #date(2011, 12, 31) value into a record containing parts from the date value.UsagePower Query MDate.ToRecord(#date(2011, 12, 31))OutputPower Query M[\u00a0Year = 2011,Month = 12,Day = 31\u00a0]",
                    "pages": []
                },
                {
                    "title": "Date.ToText",
                    "Syntax": "Date.ToText(date as nullable date, optional options as any, optional culture as nullable text) as nullable text",
                    "About": "Returns a textual representation of date. An optional record parameter, options, may be provided to specify additional properties. culture is only used for legacy workflows. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in formatting the date using the default defined by Culture.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"MMM\" is \"Jan\", \"Feb\", \"Mar\", ..., while in \"ru-RU\" \"MMM\" is \"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", .... When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options and culture may also be text values. This has the same behavior as if options = [Format = options, Culture = culture].",
                    "Explain": "Example 1Convert #date(2010, 12, 31) into a text value. Result output may vary depending on current culture.UsagePower Query MDate.ToText(#date(2010, 12, 31))Output\"12/31/2010\"Example 2Convert using a custom format and the German culture.UsagePower Query MDate.ToText(#date(2010, 12, 31), [Format=\"dd MMM yyyy\", Culture=\"de-DE\"])Output\"31 Dez 2010\"Example 3Find the year in the Hijri calendar that corresponds to January 1st, 2000 in the Gregorian calendar.UsagePower Query MDate.ToText(#date(2000, 1, 1), [Format=\"yyyy\", Culture=\"ar-SA\"])Output\"1420\"",
                    "pages": []
                },
                {
                    "title": "Date.WeekOfMonth",
                    "Syntax": "Date.WeekOfMonth(dateTime as any, optional firstDayOfWeek as nullable number) as nullable number",
                    "About": "Returns a number from 1 to 6 indicating which week of the month the date dateTime falls in.dateTime: A datetime value for which the week-of-the-month is determined.",
                    "Explain": "Determine which week of March the 15th falls on in 2011.UsagePower Query MDate.WeekOfMonth(#date(2011, 03, 15))Output3",
                    "pages": []
                },
                {
                    "title": "Date.WeekOfYear",
                    "Syntax": "Date.WeekOfYear(dateTime as any, optional firstDayOfWeek as nullable number) as nullable number",
                    "About": "Returns a number from 1 to 54 indicating which week of the year the date, dateTime, falls in.dateTime: A datetime value for which the week-of-the-year is determined.firstDayOfWeek: An optional Day.Type value that indicates which day is considered the start of a new week (for example, Day.Sunday). If unspecified, a culture-dependent default is used.",
                    "Explain": "Example 1Determine which week of the year contains March 27th, 2011.UsagePower Query MDate.WeekOfYear(#date(2011, 03, 27))Output14Example 2Determine which week of the year contains March 27th, 2011, using Monday as the start of the week.UsagePower Query MDate.WeekOfYear(#date(2011, 03, 27), Day.Monday)Output13",
                    "pages": []
                },
                {
                    "title": "Date.Year",
                    "Syntax": "Date.Year(dateTime as any) as nullable number",
                    "About": "Returns the year component of the provided datetime value, dateTime.",
                    "Explain": "Find the year in #datetime(2011, 12, 31, 9, 15, 36).UsagePower Query MDate.Year(#datetime(2011, 12, 31, 9, 15, 36))Output2011",
                    "pages": []
                },
                {
                    "title": "#date",
                    "Syntax": "#date(year as number, month as number, day as number) as date",
                    "About": "Creates a date value from whole numbers representing the year, month, and day. Raises an error if these conditions are not true:1 \u2264 year \u2264 99991 \u2264 month \u2264 121 \u2264 day \u2264 31",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Date and time functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "DateTime.AddZone",
                    "Syntax": "DateTime.AddZone(dateTime as nullable datetime, timezoneHours as number, optional timezoneMinutes as nullable number) as nullable datetimezone",
                    "About": "Adds timezone information to the dateTime value. The timezone information includes timezoneHours and optionally timezoneMinutes, which specify the desired offset from UTC time.",
                    "Explain": "Set the timezone to UTC+7:30 (7 hours and 30 minutes past UTC).UsagePower Query MDateTime.AddZone(#datetime(2010, 12, 31, 11, 56, 02), 7, 30)Output#datetimezone(2010, 12, 31, 11, 56, 2, 7, 30)",
                    "pages": []
                },
                {
                    "title": "DateTime.Date",
                    "Syntax": "DateTime.Date(dateTime as any) as nullable date",
                    "About": "Returns the date component of dateTime, the given date, datetime, or datetimezone value.",
                    "Explain": "Find date value of #datetime(2010, 12, 31, 11, 56, 02).UsagePower Query MDateTime.Date(#datetime(2010, 12, 31, 11, 56, 02))Output#date(2010, 12, 31)",
                    "pages": []
                },
                {
                    "title": "DateTime.FixedLocalNow",
                    "Syntax": "DateTime.FixedLocalNow() as datetime",
                    "About": "Returns a datetime value set to the current date and time on the system. This value is fixed and will not change with successive calls, unlike DateTime.LocalNow, which may return different values over the course of execution of an expression.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DateTime.From",
                    "Syntax": "DateTime.From(value as any, optional culture as nullable text) as nullable datetime",
                    "About": "Returns a datetime value from the given value. An optional culture may also be provided (for example, \"en-US\"). If the given value is null, DateTime.From returns null. If the given value is datetime, value is returned. Values of the following types can be converted to a datetime value:text: A datetime value from textual representation. Refer to DateTime.FromText for details.date: A datetime with value as the date component and 12:00:00 AM as the time component.datetimezone: The local datetime equivalent of value.time: A datetime with the date equivalent of the OLE Automation Date of 0 as the date component and value as the time component.number: A datetime equivalent of the OLE Automation Date expressed by value.If value is of any other type, an error is returned.",
                    "Explain": "Example 1Convert #time(06, 45, 12) to a datetime value.UsagePower Query MDateTime.From(#time(06, 45, 12))Output#datetime(1899, 12, 30, 06, 45, 12)Example 2Convert #date(1975, 4, 4) to a datetime value.UsagePower Query MDateTime.From(#date(1975, 4, 4))Output#datetime(1975, 4, 4, 0, 0, 0)",
                    "pages": []
                },
                {
                    "title": "DateTime.FromFileTime",
                    "Syntax": "DateTime.FromFileTime(fileTime as nullable number) as nullable datetime",
                    "About": "Creates a datetime value from the fileTime value and converts it to the local time zone. The filetime is a Windows file time value that represents the number of 100-nullosecond intervals that have elapsed since 12:00 midnight, January 1, 1601 A.D. (C.E.) Coordinated Universal Time (UTC).",
                    "Explain": "Convert 129876402529842245 into a datetime value.UsagePower Query MDateTime.FromFileTime(129876402529842245)Output#datetime(2012, 7, 24, 14, 50, 52.9842245)",
                    "pages": []
                },
                {
                    "title": "DateTime.FromText",
                    "Syntax": "DateTime.FromText(text as nullable text, optional options as any) as nullable datetime",
                    "About": "Creates a datetime value from a textual representation, text. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in parsing the date using a best effort.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"MMM\" is \"Jan\", \"Feb\", \"Mar\", ..., while in \"ru-RU\" \"MMM\" is \"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", .... When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options may also be a text value. This has the same behavior as if options = [Format = null, Culture = options].",
                    "Explain": "Example 1Convert \"2010-12-31T01:30:00\" into a datetime value.UsagePower Query MDateTime.FromText(\"2010-12-31T01:30:25\")Output#datetime(2010, 12, 31, 1, 30, 25)Example 2Convert \"2010-12-31T01:30:00.121212\" into a datetime value.UsagePower Query MDateTime.FromText(\"30 Dez 2010 02:04:50.369730\", [Format=\"dd MMM yyyy HH:mm:ss.ffffff\", Culture=\"de-DE\"])Output#datetime(2010, 12, 30, 2, 4, 50.36973)Example 3Convert \"2010-12-31T01:30:00\" into a datetime value.UsagePower Query MDateTime.FromText(\"2000-02-08T03:45:12Z\", [Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"])Output#datetime(2000, 2, 8, 3, 45, 12)Example 4Convert \"20101231T013000\" into a datetime value.UsagePower Query MDateTime.FromText(\"20101231T013000\", [Format=\"yyyyMMdd'T'HHmmss\", Culture=\"en-US\"])Output#datetime(2010, 12, 31, 1, 30, 0)",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInCurrentHour",
                    "Syntax": "DateTime.IsInCurrentHour(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current hour, as determined by the current date and time on the system.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current hour.UsagePower Query MDateTime.IsInCurrentHour(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInCurrentMinute",
                    "Syntax": "DateTime.IsInCurrentMinute(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current minute, as determined by the current date and time on the system.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current minute.UsagePower Query MDateTime.IsInCurrentMinute(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInCurrentSecond",
                    "Syntax": "DateTime.IsInCurrentSecond(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the current second, as determined by the current date and time on the system.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the current system time is in the current second.UsagePower Query MDateTime.IsInCurrentSecond(DateTime.FixedLocalNow())Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInNextHour",
                    "Syntax": "DateTime.IsInNextHour(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next hour, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the hour after the current system time is in the next hour.UsagePower Query MDateTime.IsInNextHour(DateTime.FixedLocalNow() + #duration(0, 1, 0, 0))Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInNextMinute",
                    "Syntax": "DateTime.IsInNextMinute(dateTime as any) as nullable logic",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next minute, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the minute after the current system time is in the next minute.UsagePower Query MDateTime.IsInNextMinute(DateTime.FixedLocalNow() + #duration(0, 0, 1, 0))Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInNextNHours",
                    "Syntax": "DateTime.IsInNextNHours(dateTime as any, hours as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of hours, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.dateTime: A datetime, or datetimezone value to be evaluated.hours: The number of hours.",
                    "Explain": "Determine if the hour after the current system time is in the next two hours.UsagePower Query MDateTime.IsInNextNHours(DateTime.FixedLocalNow() + #duration(0, 2, 0, 0), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInNextNMinutes",
                    "Syntax": "DateTime.IsInNextNMinutes(dateTime as any, minutes as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of minutes, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.dateTime: A datetime, or datetimezone value to be evaluated.minutes: The number of minutes.",
                    "Explain": "Determine if the minute after the current system time is in the next two minutes.UsagePower Query MDateTime.IsInNextNMinutes(DateTime.FixedLocalNow() + #duration(0, 0, 2, 0), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInNextNSeconds",
                    "Syntax": "DateTime.IsInNextNSeconds(dateTime as any, seconds as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next number of seconds, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.dateTime: A datetime, or datetimezone value to be evaluated.seconds: The number of seconds.",
                    "Explain": "Determine if the second after the current system time is in the next two seconds.UsagePower Query MDateTime.IsInNextNSeconds(DateTime.FixedLocalNow() + #duration(0, 0, 0, 2), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInNextSecond",
                    "Syntax": "DateTime.IsInNextSecond(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the next second, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the second after the current system time is in the next second.UsagePower Query MDateTime.IsInNextSecond(DateTime.FixedLocalNow() + #duration(0, 0, 0, 1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInPreviousHour",
                    "Syntax": "DateTime.IsInPreviousHour(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous hour, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current hour.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the hour before the current system time is in the previous hour.UsagePower Query MDateTime.IsInPreviousHour(DateTime.FixedLocalNow() - #duration(0, 1, 0, 0))Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInPreviousMinute",
                    "Syntax": "DateTime.IsInPreviousMinute(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous minute, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the minute before the current system time is in the previous minute.UsagePower Query MDateTime.IsInPreviousMinute(DateTime.FixedLocalNow() - #duration(0, 0, 1, 0))Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInPreviousNMinutes",
                    "Syntax": "DateTime.IsInPreviousNMinutes(dateTime as any, minutes as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of minutes, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current minute.dateTime: A datetime, or datetimezone value to be evaluated.`minutes: The number of minutes.",
                    "Explain": "Determine if the minute before the current system time is in the previous two minutes.UsagePower Query MDateTime.IsInPreviousNMinutes(DateTime.FixedLocalNow() - #duration(0, 0, 2, 0), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInPreviousNSeconds",
                    "Syntax": "DateTime.IsInPreviousNSeconds(dateTime as any, seconds as number) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous number of seconds, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.dateTime: A datetime>, or datetimezone value to be evaluated.seconds: The number of seconds.",
                    "Explain": "Determine if the second before the current system time is in the previous two seconds.UsagePower Query MDateTime.IsInPreviousNSeconds(DateTime.FixedLocalNow() - #duration(0, 0, 0, 2), 2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.IsInPreviousSecond",
                    "Syntax": "DateTime.IsInPreviousSecond(dateTime as any) as nullable logical",
                    "About": "Indicates whether the given datetime value dateTime occurs during the previous second, as determined by the current date and time on the system. Note that this function will return false when passed a value that occurs within the current second.dateTime: A datetime, or datetimezone value to be evaluated.",
                    "Explain": "Determine if the second before the current system time is in the previous second.UsagePower Query MDateTime.IsInPreviousSecond(DateTime.FixedLocalNow() - #duration(0, 0, 0, 1))Outputtrue",
                    "pages": []
                },
                {
                    "title": "DateTime.LocalNow",
                    "Syntax": "DateTime.LocalNow() as datetime",
                    "About": "Returns a datetime value set to the current date and time on the system.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DateTime.Time",
                    "Syntax": "DateTime.Time(dateTime as any) as nullable time",
                    "About": "Returns the time part of the given datetime value, dateTime.",
                    "Explain": "Find the time value of #datetime(2010, 12, 31, 11, 56, 02).UsagePower Query MDateTime.Time(#datetime(2010, 12, 31, 11, 56, 02))Output#time(11, 56, 2)",
                    "pages": []
                },
                {
                    "title": "DateTime.ToRecord",
                    "Syntax": "DateTime.ToRecord(dateTime as datetime) as record",
                    "About": "Returns a record containing the parts of the given datetime value, dateTime.dateTime: A datetime value for from which the record of its parts is to be calculated.",
                    "Explain": "Convert the #datetime(2011, 12, 31, 11, 56, 2) value into a record containing Date and Time values.UsagePower Query MDateTime.ToRecord(#datetime(2011, 12, 31, 11, 56, 2))Output[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Year = 2011,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Month = 12,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Day = 31,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hour = 11,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Minute = 56,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Second = 2]",
                    "pages": []
                },
                {
                    "title": "DateTime.ToText",
                    "Syntax": "DateTime.ToText(dateTime as nullable datetime, optional options as any, optional culture as nullable text) as nullable text",
                    "About": "Returns a textual representation of dateTime. An optional record parameter, options, may be provided to specify additional properties. culture is only used for legacy workflows. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in formatting the date using the default defined by Culture.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"MMM\" is \"Jan\", \"Feb\", \"Mar\", ..., while in \"ru-RU\" \"MMM\" is \"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", .... When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options and culture may also be text values. This has the same behavior as if options = [Format = options, Culture = culture].",
                    "Explain": "Example 1Convert #datetime(2010, 12, 31, 01, 30, 25) into a text value. Result output may vary depending on current culture.UsagePower Query MDateTime.ToText(#datetime(2010, 12, 31, 01, 30, 25))Output\"12/31/2010 1:30:25 AM\"Example 2Convert using a custom format and the German culture.UsagePower Query MDateTime.ToText(#datetime(2010, 12, 30, 2, 4, 50.36973), [Format=\"dd MMM yyyy HH:mm:ss.ffffff\", Culture=\"de-DE\"])Output\"30 Dez 2010 02:04:50.369730\"Example 3Convert using the ISO 8601 pattern.UsagePower Query MDateTime.ToText(#datetime(2000, 2, 8, 3, 45, 12),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"])Output\"2000-02-08T03:45:12Z\"",
                    "pages": []
                },
                {
                    "title": "#datetime",
                    "Syntax": "#datetime(year as number, month as number, day as number, hour as number, minute as number, second as number) as datetime",
                    "About": "Creates a datetime value from numbers representing the year, month, day, hour, minute, and (fractional) second. Raises an error if these conditions are not true:1 \u2264 year \u2264 99991 \u2264 month \u2264 121 \u2264 day \u2264 310 \u2264 hour \u2264 230 \u2264 minute \u2264 590 \u2264 second < 60",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "DateTimeZone functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "DateTimeZone.FixedLocalNow",
                    "Syntax": "DateTimeZone.FixedLocalNow() as datetimezone",
                    "About": "Returns a datetime value set to the current date and time on the system. The returned value contains timezone information representing the local timezone. This value is fixed and will not change with successive calls, unlike DateTimeZone.LocalNow, which may return different values over the course of execution of an expression.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DateTimeZone.FixedUtcNow",
                    "Syntax": "DateTimeZone.FixedUtcNow() as datetimezone",
                    "About": "Returns the current date and time in UTC (the GMT timezone). This value is fixed and will not change with successive calls.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DateTimeZone.From",
                    "Syntax": "DateTimeZone.From(value as any, optional culture as nullable text) as nullable datetimezone",
                    "About": "Returns a datetimezone value from the given value. An optional culture may also be provided (for example, \"en-US\"). If the given value is null, DateTimeZone.From returns null. If the given value is datetimezone, value is returned. Values of the following types can be converted to a datetimezone value:text: A datetimezone value from textual representation. Refer to DateTimeZone.FromText for details.date: A datetimezone with value as the date component, 12:00:00 AM as the time component, and the offset corresponding the local time zone.datetime: A datetimezone with value as the datetime and the offset corresponding the local time zone.time: A datetimezone with the date equivalent of the OLE Automation Date of 0 as the date component, value as the time component, and the offset corresponding the local time zone.number: A datetimezone with the datetime equivalent to the OLE Automation Date expressed by value and the offset corresponding the local time zone.If value is of any other type, an error is returned.",
                    "Explain": "Convert \"2020-10-30T01:30:00-08:00\" to a datetimezone value.UsagePower Query MDateTimeZone.From(\"2020-10-30T01:30:00-08:00\")Output#datetimezone(2020, 10, 30, 01, 30, 00, -8, 00)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.FromFileTime",
                    "Syntax": "DateTimeZone.FromFileTime(fileTime as nullable number) as nullable datetimezone",
                    "About": "Creates a datetimezone value from the fileTime value and converts it to the local time zone. The filetime is a Windows file time value that represents the number of 100-nullosecond intervals that have elapsed since 12:00 midnight, January 1, 1601 A.D. (C.E.) Coordinated Universal Time (UTC).",
                    "Explain": "Convert 129876402529842245 into a datetimezone value.UsagePower Query MDateTimeZone.FromFileTime(129876402529842245)Output#datetimezone(2012, 7, 24, 14, 50, 52.9842245, -7, 0)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.FromText",
                    "Syntax": "DateTimeZone.FromText(text as nullable text, optional options as any) as nullable datetimezone",
                    "About": "Creates a datetimezone value from a textual representation, text. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in parsing the date using a best effort.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"MMM\" is \"Jan\", \"Feb\", \"Mar\", ..., while in \"ru-RU\" \"MMM\" is \"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", .... When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options may also be a text value. This has the same behavior as if options = [Format = null, Culture = options].",
                    "Explain": "Example 1Convert \"2010-12-31T01:30:00-08:00\" into a datetimezone value.UsagePower Query MDateTimeZone.FromText(\"2010-12-31T01:30:00-08:00\")Output#datetimezone(2010, 12, 31, 1, 30, 0, -8, 0)Example 2Convert using a custom format and the German culture.UsagePower Query MDateTimeZone.FromText(\"30 Dez 2010 02:04:50.369730 +02:00\", [Format=\"dd MMM yyyy HH:mm:ss.ffffff zzz\", Culture=\"de-DE\"])Output#datetimezone(2010, 12, 30, 2, 4, 50.36973, 2, 0)Example 3Convert using ISO 8601.UsagePower Query MDateTimeZone.FromText(\"2009-06-15T13:45:30.0000000-07:00\", [Format=\"O\", Culture=\"en-US\"])Output#datetimezone(2009, 6, 15, 13, 45, 30, -7, 0)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.LocalNow",
                    "Syntax": "DateTimeZone.LocalNow() as datetimezone",
                    "About": "Returns a datetimezone value set to the current date and time on the system. The returned value contains timezone information representing the local timezone.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DateTimeZone.RemoveZone",
                    "Syntax": "DateTimeZone.RemoveZone(dateTimeZone as nullable datetimezone) as nullable datetime",
                    "About": "Returns a #datetime value from dateTimeZone with timezone information removed.",
                    "Explain": "Remove timezone information from the value #datetimezone(2011, 12, 31, 9, 15, 36, -7, 0).UsagePower Query MDateTimeZone.RemoveZone(#datetimezone(2011, 12, 31, 9, 15, 36, -7, 0))Output#datetime(2011, 12, 31, 9, 15, 36)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.SwitchZone",
                    "Syntax": "DateTimeZone.SwitchZone(dateTimeZone as nullable datetimezone, timezoneHours as number, optional timezoneMinutes as nullable number) as nullable datetimezone",
                    "About": "Changes timezone information to on the datetimezone value dateTimeZone to the new timezone information provided by timezoneHours and optionally timezoneMinutes. If dateTimeZone does not have a timezone component, an exception is thrown.",
                    "Explain": "Example 1Change timezone information for #datetimezone(2010, 12, 31, 11, 56, 02, 7, 30) to 8 hours.UsagePower Query MDateTimeZone.SwitchZone(#datetimezone(2010, 12, 31, 11, 56, 02, 7, 30), 8)Output#datetimezone(2010, 12, 31, 12, 26, 2, 8, 0)Example 2Change timezone information for #datetimezone(2010, 12, 31, 11, 56, 02, 7, 30) to -30 minutes.UsagePower Query MDateTimeZone.SwitchZone(#datetimezone(2010, 12, 31, 11, 56, 02, 7, 30), 0, -30)Output#datetimezone(2010, 12, 31, 3, 56, 2, 0, -30)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.ToLocal",
                    "Syntax": "DateTimeZone.ToLocal(dateTimeZone as nullable datetimezone) as nullable datetimezone",
                    "About": "Changes timezone information of the datetimezone value dateTimeZone to the local timezone information. If dateTimeZone does not have a timezone component, the local timezone information is added.",
                    "Explain": "Change timezone information for #datetimezone(2010, 12, 31, 11, 56, 02, 7, 30) to local timezone (assuming PST).UsagePower Query MDateTimeZone.ToLocal(#datetimezone(2010, 12, 31, 11, 56, 02, 7, 30))Output#datetimezone(2010, 12, 31, 12, 26, 2, -8, 0)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.ToRecord",
                    "Syntax": "DateTimeZone.ToRecord(dateTimeZone as datetimezone) as record",
                    "About": "Returns a record containing the parts of the given datetimezone value, dateTimeZone.dateTimeZone: A datetimezone value for from which the record of its parts is to be calculated.",
                    "Explain": "Convert the #datetimezone(2011, 12, 31, 11, 56, 2, 8, 0) value into a record containing Date, Time, and Zone values.UsagePower Query MDateTimeZone.ToRecord(#datetimezone(2011, 12, 31, 11, 56, 2, 8, 0))Output[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Year = 2011,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Month = 12,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Day = 31,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hour = 11,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Minute = 56,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Second = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ZoneHours = 8,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ZoneMinutes = 0]",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.ToText",
                    "Syntax": "DateTimeZone.ToText(dateTimeZone as nullable datetimezone, optional options as any, optional culture as nullable text) as nullable text",
                    "About": "Returns a textual representation of dateTimeZone. An optional record parameter, options, may be provided to specify additional properties. culture is only used for legacy workflows. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in formatting the date using the default defined by Culture.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"MMM\" is \"Jan\", \"Feb\", \"Mar\", ..., while in \"ru-RU\" \"MMM\" is \"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", .... When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options and culture may also be text values. This has the same behavior as if options = [Format = options, Culture = culture].",
                    "Explain": "Example 1Convert #datetimezone(2010, 12, 31, 01, 30, 25, 2, 0) into a text value. Result output may vary depending on current culture.UsagePower Query MDateTimeZone.ToText(#datetimezone(2010, 12, 31, 01, 30, 25, 2, 0))Output\"12/31/2010 1:30:25 AM +02:00\"Example 2Convert using a custom format and the German culture.UsagePower Query MDateTimeZone.ToText(#datetimezone(2010, 12, 30, 2, 4, 50.36973, -8,0), [Format=\"dd MMM yyyy HH:mm:ss.ffffff zzz\", Culture=\"de-DE\"])Output\"30 Dez 2010 02:04:50.369730 -08:00\"Example 3Convert using the ISO 8601 pattern.UsagePower Query MDateTimeZone.ToText(#datetimezone(2000, 2, 8, 3, 45, 12, 2, 0),[Format=\"O\", Culture=\"en-US\"])Output\"2000-02-08T03:45:12.0000000+02:00\"",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.ToUtc",
                    "Syntax": "DateTimeZone.ToUtc(dateTimeZone as nullable datetimezone) as nullable datetimezone",
                    "About": "Changes timezone information of the datetime value dateTimeZone to the UTC or Universal Time timezone information. If dateTimeZone does not have a timezone component, the UTC timezone information is added.",
                    "Explain": "Change timezone information for #datetimezone(2010, 12, 31, 11, 56, 02, 7, 30) to UTC timezone.UsagePower Query MDateTimeZone.ToUtc(#datetimezone(2010, 12, 31, 11, 56, 02, 7, 30))Output#datetimezone(2010, 12, 31, 4, 26, 2, 0, 0)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.UtcNow",
                    "Syntax": "DateTimeZone.UtcNow() as datetimezone",
                    "About": "Returns the current date and time in UTC (the GMT timezone).",
                    "Explain": "Get the current date & time in UTC.UsagePower Query MDateTimeZone.UtcNow()Output#datetimezone(2011, 8, 16, 23, 34, 37.745, 0, 0)",
                    "pages": []
                },
                {
                    "title": "DateTimeZone.ZoneHours",
                    "Syntax": "DateTimeZone.ZoneHours(dateTimeZone as nullable datetimezone) as nullable number",
                    "About": "Changes the timezone of the value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "DateTimeZone.ZoneMinutes",
                    "Syntax": "DateTimeZone.ZoneMinutes(dateTimeZone as nullable datetimezone) as nullable number",
                    "About": "Changes the timezone of the value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "#datetimezone",
                    "Syntax": "#datetimezone(year as number, month as number, day as number, hour as number, minute as number, second as number, offsetHours as number, offsetMinutes as number) as datetimezone",
                    "About": "Creates a datetimezone value from numbers representing the year, month, day, hour, minute, (fractional) second, (fractional) offset-hours, and offset-minutes. Raises an error if these conditions are not true:1 \u2264 year \u2264 99991 \u2264 month \u2264 121 \u2264 day \u2264 310 \u2264 hour \u2264 230 \u2264 minute \u2264 590 \u2264 second < 60-14 \u2264 offset-hours + offset-minutes / 60 \u2264 14",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Duration functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Duration.Days",
                    "Syntax": "Duration.Days(duration as nullable duration) as nullable number",
                    "About": "Returns the days portion of duration.",
                    "Explain": "Extract the number of days between two dates.UsagePower Query MDuration.Days(#date(2022, 3, 4) - #date(2022, 2, 25))Output7",
                    "pages": []
                },
                {
                    "title": "Duration.From",
                    "Syntax": "Duration.From(value as any) as nullable duration",
                    "About": "Returns a duration value from the given value. If the given value is null, Duration.From returns null. If the given value is duration, value is returned. Values of the following types can be converted to a duration value:text: A duration value from textual elapsed time forms (d.h:m:s). Refer to Duration.FromText for details.number: A duration equivalent to the number of whole and fractional days expressed by value.If value is of any other type, an error is returned.",
                    "Explain": "Convert 2.525 into a duration value.UsagePower Query MDuration.From(2.525)Output#duration(2, 12, 36, 0)",
                    "pages": []
                },
                {
                    "title": "Duration.FromText",
                    "Syntax": "Duration.FromText(text as nullable text) as nullable duration",
                    "About": "Returns a duration value from the specified text, text. The following formats can be parsed by this function:(-)hh:mm(:ss(.ff))(-)ddd(.hh:mm(:ss(.ff)))(All ranges are inclusive)ddd: Number of days.hh: Number of hours, between 0 and 23.mm: Number of minutes, between 0 and 59.ss: Number of seconds, between 0 and 59.ff: Fraction of seconds, between 0 and 9999999.",
                    "Explain": "Convert \"2.05:55:20\" into a duration value.UsagePower Query MDuration.FromText(\"2.05:55:20\")Output#duration(2, 5, 55, 20)",
                    "pages": []
                },
                {
                    "title": "Duration.Hours",
                    "Syntax": "Duration.Hours(duration as nullable duration) as nullable number",
                    "About": "Returns the hours portion of duration.",
                    "Explain": "Extract the hours from a duration value.UsagePower Query MDuration.Hours(#duration(5, 4, 3, 2))Output4",
                    "pages": []
                },
                {
                    "title": "Duration.Minutes",
                    "Syntax": "Duration.Minutes(duration as nullable duration) as nullable number",
                    "About": "Returns the minutes portion of duration.",
                    "Explain": "Extract the minutes from a duration value.UsagePower Query MDuration.Minutes(#duration(5, 4, 3, 2))Output3",
                    "pages": []
                },
                {
                    "title": "Duration.Seconds",
                    "Syntax": "Duration.Seconds(duration as nullable duration) as nullable number",
                    "About": "Returns the seconds portion of duration.",
                    "Explain": "Extract the seconds from a duration value.UsagePower Query MDuration.Seconds(#duration(5, 4, 3, 2))Output2",
                    "pages": []
                },
                {
                    "title": "Duration.ToRecord",
                    "Syntax": "Duration.ToRecord(duration as duration) as record",
                    "About": "Returns a record containing the parts the duration value, duration.duration: A duration from which the record is created.",
                    "Explain": "Convert #duration(2, 5, 55, 20) into a record of its parts including days, hours, minutes, and seconds if applicable.UsagePower Query MDuration.ToRecord(#duration(2, 5, 55, 20))Output[\u00a0\u00a0\u00a0\u00a0Days = 2,\u00a0\u00a0\u00a0\u00a0Hours = 5,\u00a0\u00a0\u00a0\u00a0Minutes = 55,\u00a0\u00a0\u00a0\u00a0Seconds = 20]",
                    "pages": []
                },
                {
                    "title": "Duration.TotalDays",
                    "Syntax": "Duration.TotalDays(duration as nullable duration) as nullable number",
                    "About": "Returns the total days spanned by duration.",
                    "Explain": "Find the total days spanned by a duration value.UsagePower Query MDuration.TotalDays(#duration(5, 4, 3, 2))Output5.1687731481481478",
                    "pages": []
                },
                {
                    "title": "Duration.TotalHours",
                    "Syntax": "Duration.TotalHours(duration as nullable duration) as nullable number",
                    "About": "Returns the total hours spanned by duration.",
                    "Explain": "Find the total hours spanned by a duration value.UsagePower Query MDuration.TotalHours(#duration(5, 4, 3, 2))Output124.05055555555555",
                    "pages": []
                },
                {
                    "title": "Duration.TotalMinutes",
                    "Syntax": "Duration.TotalMinutes(duration as nullable duration) as nullable number",
                    "About": "Returns the total minutes spanned by duration.",
                    "Explain": "Find the total minutes spanned by a duration value.UsagePower Query MDuration.TotalMinutes(#duration(5, 4, 3, 2))Output7443.0333333333338",
                    "pages": []
                },
                {
                    "title": "Duration.TotalSeconds",
                    "Syntax": "Duration.TotalSeconds(duration as nullable duration) as nullable number",
                    "About": "Returns the total seconds spanned by duration.",
                    "Explain": "Find the total seconds spanned by a duration value.UsagePower Query MDuration.TotalSeconds(#duration(5, 4, 3, 2))Output446582",
                    "pages": []
                },
                {
                    "title": "Duration.ToText",
                    "Syntax": "Duration.ToText(duration as nullable duration, optional format as nullable text) as nullable text",
                    "About": "Returns a textual representation in the form \"day.hour:mins:sec\" of the given duration value, duration.duration: A duration from which the textual representation is calculated.format: [Optional] Deprecated, will throw an error if not null.",
                    "Explain": "Convert #duration(2, 5, 55, 20) into a text value.UsagePower Query MDuration.ToText(#duration(2, 5, 55, 20))Output\"2.05:55:20\"",
                    "pages": []
                },
                {
                    "title": "#duration",
                    "Syntax": "#duration(days as number, hours as number, minutes as number, seconds as number) as duration",
                    "About": "Creates a duration value from numbers representing days, hours, minutes, and (fractional) seconds.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Error functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Diagnostics.ActivityId",
                    "Syntax": "Diagnostics.ActivityId() as nullable text",
                    "About": "Returns an opaque identifier for the currently-running evaluation.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Diagnostics.Trace",
                    "Syntax": "Diagnostics.Trace(traceLevel as number, message as anynonnull, value as any, optional delayed as nullable logical) as any",
                    "About": "Writes a trace message, if tracing is enabled, and returns value. An optional parameter delayed specifies whether to delay the evaluation of value until the message is traced. traceLevel can take one of the following values:TraceLevel.CriticalTraceLevel.ErrorTraceLevel.WarningTraceLevel.InformationTraceLevel.Verbose",
                    "Explain": "Trace the message before invoking Text.From function and return the result.UsagePower Query MDiagnostics.Trace(TraceLevel.Information, \"TextValueFromNumber\", () => Text.From(123), true)Output\"123\"",
                    "pages": []
                },
                {
                    "title": "Error.Record",
                    "Syntax": "Error.Record(reason as text, optional message as nullable text, optional detail as any, optional parameters as nullable list) as record",
                    "About": "Returns an error record from the provided text values for reason, message and detail.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Expression functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Expression.Constant",
                    "Syntax": "Expression.Constant(value as any) as text",
                    "About": "Returns the M source code representation of a constant value.",
                    "Explain": "Example 1Get the M source code representation of a number value.UsagePower Query MExpression.Constant(123)Output\"123\"Example 2Get the M source code representation of a date value.UsagePower Query MExpression.Constant(#date(2035, 01, 02))Output\"#date(2035, 1, 2)\"Example 3Get the M source code representation of a text value.UsagePower Query MExpression.Constant(\"abc\")Output\"\"\"abc\"\"\"",
                    "pages": []
                },
                {
                    "title": "Expression.Evaluate",
                    "Syntax": "Expression.Evaluate(document as text, optional environment as nullable record) as any",
                    "About": "Returns the result of evaluating an M expression document, with the available identifiers that can be referenced defined by environment.",
                    "Explain": "Example 1Evaluate a simple sum.UsagePower Query MExpression.Evaluate(\"1 + 1\")Output2Example 2Evaluate a more complex sum.UsagePower Query MExpression.Evaluate(\"List.Sum({1, 2, 3})\", [List.Sum = List.Sum])Output6Example 3Evaluate the concatenation of a text value with an identifier.UsagePower Query MExpression.Evaluate(Expression.Constant(\"\"\"abc\") & \" & \" & Expression.Identifier(\"x\"), [x = \"def\"\"\"])Output\"\"\"abcdef\"\"\"",
                    "pages": []
                },
                {
                    "title": "Expression.Identifier",
                    "Syntax": "Expression.Identifier(name as text) as text",
                    "About": "Returns the M source code representation of an identifier name.",
                    "Explain": "Example 1Get the M source code representation of an identifier.UsagePower Query MExpression.Identifier(\"MyIdentifier\")Output\"MyIdentifier\"Example 2Get the M source code representation of an identifier that contains a space.UsagePower Query MExpression.Identifier(\"My Identifier\")Output\"#\"\"My Identifier\"\"\"",
                    "pages": []
                }
            ]
        },
        {
            "title": "Function values",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Function.From",
                    "Syntax": "Function.From(functionType as type, function as function) as function",
                    "About": "Takes a unary function function and creates a new function with the type functionType that constructs a list out of its arguments and passes it to function.",
                    "Explain": "Example 1Converts List.Sum into a two-argument function whose arguments are added together.UsagePower Query MFunction.From(type function (a as number, b as number) as number, List.Sum)(2, 1)Output3Example 2Converts a function taking a list into a two-argument function.UsagePower Query MFunction.From(type function (a as text, b as text) as text, (list) => list{0} & list{1})(\"2\", \"1\")Output\"21\"",
                    "pages": []
                },
                {
                    "title": "Function.Invoke",
                    "Syntax": "Function.Invoke(function as function, args as list) as any",
                    "About": "Invokes the given function using the specified list of arguments and returns the result.",
                    "Explain": "Invokes Record.FieldNames with one argument [A=1,B=2]UsagePower Query MFunction.Invoke(Record.FieldNames, {[A = 1, B = 2]}Output{\"A\", \"B\"}",
                    "pages": []
                },
                {
                    "title": "Function.InvokeAfter",
                    "Syntax": "Function.InvokeAfter(function as function, delay as duration) as any",
                    "About": "Returns the result of invoking function after duration delay has passed.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Function.IsDataSource",
                    "Syntax": "Function.IsDataSource(function as function) as logical",
                    "About": "Returns whether or not function is considered a data source.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Function.ScalarVector",
                    "Syntax": "Function.ScalarVector(scalarFunctionType as type, vectorFunction as function) as function",
                    "About": "Returns a scalar function of type scalarFunctionType that invokes vectorFunction with a single row of arguments and returns its single output. Additionally, when the scalar function is repeatedly applied for each row of a table of inputs, such as in Table.AddColumn, instead vectorFunction will be applied once for all inputs.vectorFunction will be passed a table whose columns match in name and position the parameters of scalarFunctionType. Each row of this table contains the arguments for one call to the scalar function, with the columns corresponding to the parameters of scalarFunctionType.vectorFunction must return a list of the same length as the input table, whose item at each position must be the same result as evaluating the scalar function on the input row of the same position.The input table is expected to be streamed in, so vectorFunction is expected to stream its output as input comes in, only working with one chunk of input at a time. In particular, vectorFunction must not enumerate its input table more than once.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Lines functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Lines.FromBinary",
                    "Syntax": "Lines.FromBinary(binary as binary, optional quoteStyle as nullable number, optional includeLineSeparators as nullable logical, optional encoding as nullable number) as list",
                    "About": "Converts a binary value to a list of text values split at lines breaks. If a quote style is specified, then line breaks may appear within quotes. If includeLineSeparators is true, then the line break characters are included in the text.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Lines.FromText",
                    "Syntax": "Lines.FromText(text as text, optional quoteStyle as nullable number, optional includeLineSeparators as nullable logical) as list",
                    "About": "Converts a text value to a list of text values split at lines breaks. If includeLineSeparators is true, then the line break characters are included in the text.QuoteStyle.None: (default) No quoting behavior is needed.QuoteStyle.Csv: Quoting is as per Csv. A double quote character is used to demarcate such regions, and a pair of double quote characters is used to indicate a single double quote character within such a region.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Lines.ToBinary",
                    "Syntax": "Lines.ToBinary(lines as list, optional lineSeparator as nullable text, optional encoding as nullable number, optional includeByteOrderMark as nullable logical) as binary",
                    "About": "Converts a list of text into a binary value using the specified encoding and lineSeparator.The specified lineSeparator is appended to each line. If not specified then the carriage return and line feed characters are used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Lines.ToText",
                    "Syntax": "Lines.ToText(lines as list, optional lineSeparator as nullable text) as text",
                    "About": "Converts a list of text into a single text. The specified lineSeparator is appended to each line. If not specified then the carriage return and line feed characters are used.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "List functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "List.Accumulate",
                    "Syntax": "List.Accumulate(list as list, seed as any, accumulator as function) as any",
                    "About": "Accumulates a summary value from the items in the list list, using accumulator. An optional seed parameter, seed, may be set.",
                    "Explain": "Accumulates the summary value from the items in the list {1, 2, 3, 4, 5} using ((state, current) => state + current ).UsagePower Query MList.Accumulate({1, 2, 3, 4, 5}, 0, (state, current) => state + current)Output15",
                    "pages": []
                },
                {
                    "title": "List.AllTrue",
                    "Syntax": "List.AllTrue(list as list) as logical",
                    "About": "Returns true if all expressions in the list list are true.",
                    "Explain": "Example 1Determine if all the expressions in the list {true, true, 2 > 0} are true.UsagePower Query MList.AllTrue({true, true, 2 > 0})OutputtrueExample 2Determine if all the expressions in the list {true, true, 2 < 0} are true.UsagePower Query MList.AllTrue({true, false, 2 < 0})Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.Alternate",
                    "Syntax": "List.Alternate(list as list, count as number, optional repeatInterval as nullable number, optional offset as nullable number) as list",
                    "About": "Returns a list comprised of all the odd numbered offset elements in a list. Alternates between taking and skipping values from the list list depending on the parameters.count: Specifies number of values that are skipped each time.repeatInterval: An optional repeat interval to indicate how many values are added in between the skipped values.offset: An option offset parameter to begin skipping the values at the initial offset.",
                    "Explain": "Example 1Create a list from {1..10} that skips the first number.UsagePower Query MList.Alternate({1..10}, 1)Output{2, 3, 4, 5, 6, 7, 8, 9, 10}Example 2Create a list from {1..10} that skips every other number.UsagePower Query MList.Alternate({1..10}, 1, 1)Output{2, 4, 6, 8, 10}Example 3Create a list from {1..10} that starts at 1 and skips every other number.UsagePower Query MList.Alternate({1..10}, 1, 1, 1)Output{1, 3, 5, 7, 9}Example 4Create a list from {1..10} that starts at 1, skips one value, keeps two values, and so on.UsagePower Query MList.Alternate({1..10}, 1, 2, 1)Output{1, 3, 4, 6, 7, 9, 10}",
                    "pages": []
                },
                {
                    "title": "List.AnyTrue",
                    "Syntax": "List.AnyTrue(list as list) as logical",
                    "About": "Returns true if any expression in the list list is true.",
                    "Explain": "Example 1Determine if any of the expressions in the list {true, false, 2 > 0} are true.UsagePower Query MList.AnyTrue({true, false, 2>0})OutputtrueExample 2Determine if any of the expressions in the list {2 = 0, false, 2 < 0} are true.UsagePower Query MList.AnyTrue({2 = 0, false, 2 < 0})Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.Average",
                    "Syntax": "List.Average(list as list, optional precision as nullable number) as any",
                    "About": "Returns the average value for the items in the list, list. The result is given in the same datatype as the values in the list. Only works with number, date, time, datetime, datetimezone and duration values. If the list is empty null is returned.",
                    "Explain": "Example 1Find the average of the list of numbers, {3, 4, 6}.UsagePower Query MList.Average({3, 4, 6})Output4.333333333333333Example 2Find the average of the date values January 1, 2011, January 2, 2011 and January 3, 2011.UsagePower Query MList.Average({#date(2011, 1, 1), #date(2011, 1, 2), #date(2011, 1, 3)})Output#date(2011, 1, 2)",
                    "pages": []
                },
                {
                    "title": "List.Buffer",
                    "Syntax": "List.Buffer(list as list) as list",
                    "About": "Buffers the list in memory. The result of this call is a stable list, which means it will have a determinimic count, and order of items.",
                    "Explain": "Create a stable copy of the list {1..10}.UsagePower Query MList.Buffer({1..10})Output{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
                    "pages": []
                },
                {
                    "title": "List.Combine",
                    "Syntax": "List.Combine(lists as list) as list",
                    "About": "Takes a list of lists, lists, and merges them into a single new list.",
                    "Explain": "Example 1Combine the two simple lists {1, 2} and {3, 4}.UsagePower Query MList.Combine({{1, 2}, {3, 4}})Output{\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a02,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a04}Example 2Combine the two lists, {1, 2} and {3, {4, 5}}, one of which contains a nested list.UsagePower Query MList.Combine({{1, 2}, {3, {4, 5}}})Output{\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a02,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a0{4, 5}}",
                    "pages": []
                },
                {
                    "title": "List.ConformToPageReader",
                    "Syntax": "List.ConformToPageReader(list as list, optional options as nullable record) as table",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "List.Contains",
                    "Syntax": "List.Contains(list as list, value as any, optional equationCriteria as any) as logical",
                    "About": "Indicates whether the list list contains the value value. Returns true if value is found in the list, false otherwise. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Example 1Find if the list {1, 2, 3, 4, 5} contains 3.UsagePower Query MList.Contains({1, 2, 3, 4, 5}, 3)OutputtrueExample 2Find if the list {1, 2, 3, 4, 5} contains 6.UsagePower Query MList.Contains({1, 2, 3, 4, 5}, 6)Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.ContainsAll",
                    "Syntax": "List.ContainsAll(list as list, values as list, optional equationCriteria as any) as logical",
                    "About": "Indicates whether the list list includes all the values in another list, values. Returns true if value is found in the list, false otherwise. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Example 1Find out if the list {1, 2, 3, 4, 5} contains 3 and 4.UsagePower Query MList.ContainsAll({1, 2, 3, 4, 5}, {3, 4})OutputtrueExample 2Find out if the list {1, 2, 3, 4, 5} contains 5 and 6.UsagePower Query MList.ContainsAll({1, 2, 3, 4, 5}, {5, 6})Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.ContainsAny",
                    "Syntax": "List.ContainsAny(list as list, values as list, optional equationCriteria as any) as logical",
                    "About": "Indicates whether the list list includes any of the values in another list, values. Returns true if value is found in the list, false otherwise. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Example 1Find out if the list {1, 2, 3, 4, 5} contains 3 or 9.UsagePower Query MList.ContainsAny({1, 2, 3, 4, 5}, {3, 9})OutputtrueExample 2Find out if the list {1, 2, 3, 4, 5} contains 6 or 7.UsagePower Query MList.ContainsAny({1, 2, 3, 4, 5}, {6, 7})Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.Count",
                    "Syntax": "List.Count(list as list) as number",
                    "About": "Returns the number of items in the list list.",
                    "Explain": "Find the number of values in the list {1, 2, 3}.UsagePower Query MList.Count({1, 2, 3})Output3",
                    "pages": []
                },
                {
                    "title": "List.Covariance",
                    "Syntax": "List.Covariance(numberList1 as list, numberList2 as list) as nullable number",
                    "About": "Returns the covariance between two lists, numberList1 and numberList2. numberList1 and numberList2 must contain the same number of number values.",
                    "Explain": "Calculate the covariance between two lists.UsagePower Query MList.Covariance({1, 2, 3}, {1, 2, 3})Output0.66666666666666607",
                    "pages": []
                },
                {
                    "title": "List.Dates",
                    "Syntax": "List.Dates(start as date, count as number, step as duration) as list",
                    "About": "Returns a list of date values of size count, starting at start. The given increment, step, is a duration value that is added to every value.",
                    "Explain": "Create a list of 5 values starting from New Year's Eve (#date(2011, 12, 31)) incrementing by 1 day(#duration(1, 0, 0, 0)).UsagePower Query MList.Dates(#date(2011, 12, 31), 5, #duration(1, 0, 0, 0))Output{\u00a0\u00a0\u00a0\u00a0#date(2011, 12, 31),\u00a0\u00a0\u00a0\u00a0#date(2012, 1, 1),\u00a0\u00a0\u00a0\u00a0#date(2012, 1, 2),\u00a0\u00a0\u00a0\u00a0#date(2012, 1, 3),\u00a0\u00a0\u00a0\u00a0#date(2012, 1, 4)}",
                    "pages": []
                },
                {
                    "title": "List.DateTimes",
                    "Syntax": "List.DateTimes(start as datetime, count as number, step as duration) as list",
                    "About": "Returns a list of datetime values of size count, starting at start. The given increment, step, is a duration value that is added to every value.",
                    "Explain": "Create a list of 10 values starting from 5 minutes before New Year's Day (#datetime(2011, 12, 31, 23, 55, 0)) incrementing by 1 minute (#duration(0, 0, 1, 0)).UsagePower Query MList.DateTimes(#datetime(2011, 12, 31, 23, 55, 0), 10, #duration(0, 0, 1, 0))Output{\u00a0\u00a0\u00a0\u00a0#datetime(2011, 12, 31, 23, 55, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2011, 12, 31, 23, 56, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2011, 12, 31, 23, 57, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2011, 12, 31, 23, 58, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2011, 12, 31, 23, 59, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2012, 1, 1, 0, 0, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2012, 1, 1, 0, 1, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2012, 1, 1, 0, 2, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2012, 1, 1, 0, 3, 0),\u00a0\u00a0\u00a0\u00a0#datetime(2012, 1, 1, 0, 4, 0)}",
                    "pages": []
                },
                {
                    "title": "List.DateTimeZones",
                    "Syntax": "List.DateTimeZones(start as datetimezone, count as number, step as duration) as list",
                    "About": "Returns a list of datetimezone values of size count, starting at start. The given increment, step, is a duration value that is added to every value.",
                    "Explain": "Create a list of 10 values starting from 5 minutes before New Year's Day (#datetimezone(2011, 12, 31, 23, 55, 0, -8, 0)) incrementing by 1 minute (#duration(0, 0, 1, 0)).UsagePower Query MList.DateTimeZones(#datetimezone(2011, 12, 31, 23, 55, 0, -8, 0), 10, #duration(0, 0, 1, 0))Output{\u00a0\u00a0\u00a0\u00a0#datetimezone(2011, 12, 31, 23, 55, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2011, 12, 31, 23, 56, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2011, 12, 31, 23, 57, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2011, 12, 31, 23, 58, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2011, 12, 31, 23, 59, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2012, 1, 1, 0, 0, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2012, 1, 1, 0, 1, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2012, 1, 1, 0, 2, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2012, 1, 1, 0, 3, 0, -8, 0),\u00a0\u00a0\u00a0\u00a0#datetimezone(2012, 1, 1, 0, 4, 0, -8, 0)}",
                    "pages": []
                },
                {
                    "title": "List.Difference",
                    "Syntax": "List.Difference(list1 as list, list2 as list, optional equationCriteria as any) as list",
                    "About": "Returns the items in list list1 that do not appear in list list2. Duplicate values are supported. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Example 1Find the items in list {1, 2, 3, 4, 5} that do not appear in {4, 5, 3}.UsagePower Query MList.Difference({1, 2, 3, 4, 5}, {4, 5, 3})Output{1, 2}Example 2Find the items in the list {1, 2} that do not appear in {1, 2, 3}.UsagePower Query MList.Difference({1, 2}, {1, 2, 3})Output{}",
                    "pages": []
                },
                {
                    "title": "List.Distinct",
                    "Syntax": "List.Distinct(list as list, optional equationCriteria as any) as list",
                    "About": "Filters a list down by removing duplicates. An optional equation criteria value can be specified to control equality comparison. The first value from each equality group is chosen.",
                    "Explain": "Remove the duplicates from the list {1, 1, 2, 3, 3, 3}.UsagePower Query MList.Distinct({1, 1, 2, 3, 3, 3})Output{1, 2, 3}",
                    "pages": []
                },
                {
                    "title": "List.Durations",
                    "Syntax": "List.Durations(start as duration, count as number, step as duration) as list",
                    "About": "Returns a list of count duration values, starting at start and incremented by the given duration step.",
                    "Explain": "Create a list of 5 values starting 1 hour and incrementing by an hour.UsagePower Query MList.Durations(#duration(0, 1, 0, 0), 5, #duration(0, 1, 0, 0))Output{\u00a0\u00a0\u00a0\u00a0#duration(0, 1, 0, 0),\u00a0\u00a0\u00a0\u00a0#duration(0, 2, 0, 0),\u00a0\u00a0\u00a0\u00a0#duration(0, 3, 0, 0),\u00a0\u00a0\u00a0\u00a0#duration(0, 4, 0, 0),\u00a0\u00a0\u00a0\u00a0#duration(0, 5, 0, 0)}",
                    "pages": []
                },
                {
                    "title": "List.FindText",
                    "Syntax": "List.FindText(list as list, text as text) as list",
                    "About": "Returns a list of the values from the list list which contained the value text.",
                    "Explain": "Find the text values in the list {\"a\", \"b\", \"ab\"} that match \"a\".UsagePower Query MList.FindText({\"a\", \"b\", \"ab\"}, \"a\")Output{\"a\", \"ab\"}",
                    "pages": []
                },
                {
                    "title": "List.First",
                    "Syntax": "List.First(list as list, optional defaultValue as any) as any",
                    "About": "Returns the first item in the list list, or the optional default value, defaultValue, if the list is empty. If the list is empty and a default value is not specified, the function returns null.",
                    "Explain": "Example 1Find the first value in the list {1, 2, 3}.UsagePower Query MList.First({1, 2, 3})Output1Example 2Find the first value in the list {}. If the list is empty, return -1.UsagePower Query MList.First({}, -1)Output-1",
                    "pages": []
                },
                {
                    "title": "List.FirstN",
                    "Syntax": "List.FirstN(list as list, countOrCondition as any) as any",
                    "About": "If a number is specified, up to that many items are returned.If a condition is specified, all items are returned that initially meet the condition. Once an item fails the condition, no further items are considered.",
                    "Explain": "Find the intial values in the list {3, 4, 5, -1, 7, 8, 2} that are greater than 0.UsagePower Query MList.FirstN({3, 4, 5, -1, 7, 8, 2}, each _ > 0)Output{3, 4, 5}",
                    "pages": []
                },
                {
                    "title": "List.Generate",
                    "Syntax": "List.Generate(initial as function, condition as function, next as function, optional selector as nullable function) as list",
                    "About": "Generates a list of values using the provided functions. The initial function generates a starting candidate value, which is then tested against condition. If the candidate value is approved, then it's returned as part of the resulting list, and the next candidate value is generated by passing the newly approved value to next. Once a candidate value fails to match condition, the list generation process stops. An optional parameter, selector, may also be provided to transform the items in the resulting list.",
                    "Explain": "Example 1Create a list by starting at ten, repeatedly decrementing by one, and ensuring each item is greater than zero.UsagePower Query MList.Generate(() => 10, each _ > 0, each _ - 1)Output{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}Example 2Generate a list of records containing x and y, where x is a value and y is a list. x should remain less than 10 and represent the number of items in the list y. After the list is generated, return only the x values.UsagePower Query MList.Generate(\u00a0\u00a0\u00a0\u00a0() => [x = 1, y = {}],\u00a0\u00a0\u00a0\u00a0each [x] < 10,\u00a0\u00a0\u00a0\u00a0each [x = List.Count([y]), y = [y] & {x}],\u00a0\u00a0\u00a0\u00a0each [x])Output{1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}",
                    "pages": []
                },
                {
                    "title": "List.InsertRange",
                    "Syntax": "List.InsertRange(list as list, index as number, values as list) as list",
                    "About": "Returns a new list produced by inserting the values in values into list at index. The first position in the list is at index 0.list: The target list where values are to be inserted.index: The index of the target list(list) where the values are to be inserted. The first position in the list is at index 0.values: The list of values which are to be inserted into list.",
                    "Explain": "Example 1Insert the list ({3, 4}) into the target list ({1, 2, 5}) at index 2.UsagePower Query MList.InsertRange({1, 2, 5}, 2, {3, 4})Output{\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a02,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a04,\u00a0\u00a0\u00a0\u00a05}Example 2Insert a list with a nested list ({1, {1.1, 1.2}}) into a target list ({2, 3, 4}) at index 0.UsagePower Query MList.InsertRange({2, 3, 4}, 0, {1, {1.1, 1.2}})Output{\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a02,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a04}",
                    "pages": []
                },
                {
                    "title": "List.Intersect",
                    "Syntax": "List.Intersect(lists as list, optional equationCriteria as any) as list",
                    "About": "Returns the intersection of the list values found in the input list lists. An optional parameter, equationCriteria, can be specified.",
                    "Explain": "Find the intersection of the lists {1..5}, {2..6}, {3..7}.UsagePower Query MList.Intersect({{1..5}, {2..6}, {3..7}})Output{3, 4, 5}",
                    "pages": []
                },
                {
                    "title": "List.IsDistinct",
                    "Syntax": "List.IsDistinct(list as list, optional equationCriteria as any) as logical",
                    "About": "Returns a logical value whether there are duplicates in the list list; true if the list is distinct, false if there are duplicate values.",
                    "Explain": "Example 1Find if the list {1, 2, 3} is distinct (i.e. no duplicates).UsagePower Query MList.IsDistinct({1, 2, 3})OutputtrueExample 2Find if the list {1, 2, 3, 3} is distinct (i.e. no duplicates).UsagePower Query MList.IsDistinct({1, 2, 3, 3})Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.IsEmpty",
                    "Syntax": "List.IsEmpty(list as list) as logical",
                    "About": "Returns true if the list, list, contains no values (length 0). If the list contains values (length > 0), returns false.",
                    "Explain": "Example 1Find if the list {} is empty.UsagePower Query MList.IsEmpty({})OutputtrueExample 2Find if the list {1, 2} is empty.UsagePower Query MList.IsEmpty({1, 2})Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.Last",
                    "Syntax": "List.Last(list as list, optional defaultValue as any) as any",
                    "About": "Returns the last item in the list list, or the optional default value, defaultValue, if the list is empty. If the list is empty and a default value is not specified, the function returns null.",
                    "Explain": "Example 1Find the last value in the list {1, 2, 3}.UsagePower Query MList.Last({1, 2, 3})Output3Example 2Find the last value in the list {} or -1 if it empty.UsagePower Query MList.Last({}, -1)Output-1",
                    "pages": []
                },
                {
                    "title": "List.LastN",
                    "Syntax": "List.LastN(list as list, optional countOrCondition as any) as any",
                    "About": "Returns the last item of the list list. If the list is empty, an exception is thrown. This function takes an optional parameter, countOrCondition, to support gathering multiple items or filtering items. countOrCondition can be specified in three ways:If a number is specified, up to that many items are returned.If a condition is specified, all items are returned that initially meet the condition, starting at the end of the list. Once an item fails the condition, no further items are considered.If this parameter is null the last item in the list is returned.",
                    "Explain": "Example 1Find the last value in the list {3, 4, 5, -1, 7, 8, 2}.UsagePower Query MList.LastN({3, 4, 5, -1, 7, 8, 2}, 1)Output{2}Example 2Find the last values in the list {3, 4, 5, -1, 7, 8, 2} that are greater than 0.UsagePower Query MList.LastN({3, 4, 5, -1, 7, 8, 2}, each _ > 0)Output{7, 8, 2}",
                    "pages": []
                },
                {
                    "title": "List.MatchesAll",
                    "Syntax": "List.MatchesAll(list as list, condition as function) as logical",
                    "About": "Returns true if the condition function, condition, is satisfied by all values in the list list, otherwise returns false",
                    "Explain": "Example 1Determine if all the values in the list {11, 12, 13} are greater than 10.UsagePower Query MList.MatchesAll({11, 12, 13}, each _\u00a0 > 10)OutputtrueExample 2Determine if all the values in the list {1, 2, 3} are greater than 10.UsagePower Query MList.MatchesAll({1, 2, 3}, each _\u00a0 > 10)Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.MatchesAny",
                    "Syntax": "List.MatchesAny(list as list, condition as function) as logical",
                    "About": "Returns true if the condition function, condition, is satisfied by any of values in the list list, otherwise returns false.",
                    "Explain": "Example 1Find if any of the values in the list {9, 10, 11} are greater than 10.UsagePower Query MList.MatchesAny({9, 10, 11}, each _\u00a0 > 10)OutputtrueExample 2Find if any of the values in the list {1, 2, 3} are greater than 10.UsagePower Query MList.MatchesAny({1, 2, 3}, each _\u00a0 > 10)Outputfalse",
                    "pages": []
                },
                {
                    "title": "List.Max",
                    "Syntax": "List.Max(list as list, optional default as any, optional comparisonCriteria as any, optional includeNulls as nullable logical) as any",
                    "About": "Returns the maximum item in the list list, or the optional default value default if the list is empty. An optional comparisonCriteria value, comparisonCriteria, may be specified to determine how to compare the items in the list. If this parameter is null, the default comparer is used.",
                    "Explain": "Example 1Find the max in the list {1, 4, 7, 3, -2, 5}.UsagePower Query MList.Max({1, 4, 7, 3, -2, 5}, 1)Output7Example 2Find the max in the list {} or return -1 if it is empty.UsagePower Query MList.Max({}, -1)Output-1",
                    "pages": []
                },
                {
                    "title": "List.MaxN",
                    "Syntax": "List.MaxN(list as list, countOrCondition as any, optional comparisonCriteria as any, optional includeNulls as nullable logical) as list",
                    "About": "Returns the maximum value(s) in the list, list. After the rows are sorted, optional parameters may be specified to further filter the result. The optional parameter countOrCondition specifies the number of values to return or a filtering condition. The optional parameter comparisonCriteria specifies how to compare values in the list.list: The list of values.countOrCondition: If a number is specified, a list of up to countOrCondition items in ascending order is returned. If a condition is specified, a list of items that initially meet the condition is returned. Once an item fails the condition, no further items are considered.comparisonCriteria: [Optional] An optional comparisonCriteria value can be specified to determine how to compare the items in the list. If this parameter is null, the default comparer is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "List.Median",
                    "Syntax": "List.Median(list as list, optional comparisonCriteria as any) as any",
                    "About": "Returns the median item of the list list. This function returns null if the list contains no non-null values. If there is an even number of items, the function chooses the smaller of the two median items unless the list is comprised entirely of datetimes, durations, numbers or times, in which case it returns the average of the two items.",
                    "Explain": "Find the median of the list {5, 3, 1, 7, 9}.UsagePower Query Mpowerquery-mList.Median({5, 3, 1, 7, 9})Output5",
                    "pages": []
                },
                {
                    "title": "List.Min",
                    "Syntax": "List.Min(list as list, optional default as any, optional comparisonCriteria as any, optional includeNulls as nullable logical) as any",
                    "About": "Returns the minimum item in the list list, or the optional default value default if the list is empty. An optional comparisonCriteria value, comparisonCriteria, may be specified to determine how to compare the items in the list. If this parameter is null, the default comparer is used.",
                    "Explain": "Example 1Find the min in the list {1, 4, 7, 3, -2, 5}.UsagePower Query MList.Min({1, 4, 7, 3, -2, 5})Output-2Example 2Find the min in the list {} or return -1 if it is empty.UsagePower Query MList.Min({}, -1)Output-1",
                    "pages": []
                },
                {
                    "title": "List.MinN",
                    "Syntax": "List.MinN(list as list, countOrCondition as any, optional comparisonCriteria as any, optional includeNulls as nullable logical) as list",
                    "About": "Returns the minimum value(s) in the list, list. The parameter, countOrCondition, specifies the number of values to return or a filtering condition. The optional parameter, comparisonCriteria, specifies how to compare values in the list.list: The list of values.countOrCondition: If a number is specified, a list of up to countOrCondition items in ascending order is returned. If a condition is specified, a list of items that initially meet the condition is returned. Once an item fails the condition, no further items are considered. If this parameter is null, the single smallest value in the list is returned.comparisonCriteria: [Optional] An optional comparisonCriteria value can be specified to determine how to compare the items in the list. If this parameter is null, the default comparer is used.",
                    "Explain": "Find the 5 smallest values in the list {3, 4, 5, -1, 7, 8, 2}.UsagePower Query MList.MinN({3, 4, 5, -1, 7, 8, 2}, 5)Output{-1, 2, 3, 4, 5}",
                    "pages": []
                },
                {
                    "title": "List.Mode",
                    "Syntax": "List.Mode(list as list, optional equationCriteria as any) as any",
                    "About": "Returns the item that appears most frequently in list. If the list is empty an exception is thrown. If multiple items appear with the same maximum frequency, the last one is chosen. An optional comparison criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Example 1Find the item that appears most frequently in the list {\"A\", 1, 2, 3, 3, 4, 5}.UsagePower Query MList.Mode({\"A\", 1, 2, 3, 3, 4, 5})Output3Example 2Find the item that appears most frequently in the list {\"A\", 1, 2, 3, 3, 4, 5, 5}.UsagePower Query MList.Mode({\"A\", 1, 2, 3, 3, 4, 5, 5})Output5",
                    "pages": []
                },
                {
                    "title": "List.Modes",
                    "Syntax": "List.Modes(list as list, optional equationCriteria as any) as list",
                    "About": "Returns the items that appear most frequently in list. If the list is empty an exception is thrown. If multiple items appear with the same maximum frequency, all of them are returned. An optional comparison criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Find the items that appears most frequently in the list {\"A\", 1, 2, 3, 3, 4, 5, 5}.UsagePower Query MList.Modes({\"A\", 1, 2, 3, 3, 4, 5, 5})Output{3, 5}",
                    "pages": []
                },
                {
                    "title": "List.NonNullCount",
                    "Syntax": "List.NonNullCount(list as list) as number",
                    "About": "Returns the number of non-null items in the list list.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "List.Numbers",
                    "Syntax": "List.Numbers(start as number, count as number, optional increment as nullable number) as list",
                    "About": "Returns a list of numbers given an initial value, count, and optional increment value. The default increment value is 1.start: The initial value in the list.count: The number of values to create.`increment: [Optional] The value to increment by. If omitted values are incremented by 1.",
                    "Explain": "Example 1Generate a list of 10 consecutive numbers starting at 1.UsagePower Query MList.Numbers(1, 10)Output{\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a02,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a04,\u00a0\u00a0\u00a0\u00a05,\u00a0\u00a0\u00a0\u00a06,\u00a0\u00a0\u00a0\u00a07,\u00a0\u00a0\u00a0\u00a08,\u00a0\u00a0\u00a0\u00a09,\u00a0\u00a0\u00a0\u00a010}Example 2Generate a list of 10 numbers starting at 1, with an increment of 2 for each subsequent number.UsagePower Query MList.Numbers(1, 10, 2)Output{\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a05,\u00a0\u00a0\u00a0\u00a07,\u00a0\u00a0\u00a0\u00a09,\u00a0\u00a0\u00a0\u00a011,\u00a0\u00a0\u00a0\u00a013,\u00a0\u00a0\u00a0\u00a015,\u00a0\u00a0\u00a0\u00a017,\u00a0\u00a0\u00a0\u00a019}",
                    "pages": []
                },
                {
                    "title": "List.Percentile",
                    "Syntax": "List.Percentile(list as list, percentiles as any, optional options as nullable record) as any",
                    "About": "Returns one or more sample percentiles of the list list. If the value percentiles is a number between 0.0 and 1.0, it will be treated as a percentile and the result will be a single value corresponding to that probability. If the value percentiles is a list of numbers with values between 0.0 and 1.0, the result will be a list of percentiles corresponding to the input probability.The PercentileMode option in options can be used by advanced users to pick a more-specific interpolation method but is not recommended for most uses. Predefined symbols PercentileMode.ExcelInc and PercentileMode.ExcelExc match the interpolation methods used by the Excel functions PERCENTILE.INC and PERCENTILE.EXC. The default behavior matches PercentileMode.ExcelInc. The symbols PercentileMode.SqlCont and PercentileMode.SqlDisc match the SQL Server behavior for PERCENTILE_CONT and PERCENTILE_DISC, respectively.",
                    "Explain": "Example 1Find the first quartile of the list {5, 3, 1, 7, 9}.UsagePower Query MList.Percentile({5, 3, 1, 7, 9}, 0.25)Output3Example 2Find the quartiles of the list {5, 3, 1, 7, 9} using an interpolation method matching Excel's PERCENTILE.EXC.UsagePower Query MList.Percentile({5, 3, 1, 7, 9}, {0.25, 0.5, 0.75}, [PercentileMode=PercentileMode.ExcelExc])Output{2, 5, 8}",
                    "pages": []
                },
                {
                    "title": "List.PositionOf",
                    "Syntax": "List.PositionOf(list as list, value as any, optional occurrence as nullable number, optional equationCriteria as any) as any",
                    "About": "Returns the offset at which the value value appears in the list list. Returns -1 if the value doesn't appear. An optional occurrence parameter occurrence can be specified.occurrence: The maximum number of occurrences to report.",
                    "Explain": "Find the position in the list {1, 2, 3} at which the value 3 appears.UsagePower Query MList.PositionOf({1, 2, 3}, 3)Output2",
                    "pages": []
                },
                {
                    "title": "List.PositionOfAny",
                    "Syntax": "List.PositionOfAny(list as list, values as list, optional occurrence as nullable number, optional equationCriteria as any) as any",
                    "About": "Returns the offset in list list of the first occurrence of a value in a list values. Returns -1 if no occurrence is found. An optional occurrence parameter occurrence can be specified.occurrence: The maximum number of occurrences that can be returned.",
                    "Explain": "Find the first position in the list {1, 2, 3} at which the value 2 or 3 appears.UsagePower Query MList.PositionOfAny({1, 2, 3}, {2, 3})Output1",
                    "pages": []
                },
                {
                    "title": "List.Positions",
                    "Syntax": "List.Positions(list as list) as list",
                    "About": "Returns a list of offsets for the input list list. When using List.Transform to change a list, the list of positions can be used to give the transform access to the position.",
                    "Explain": "Find the offsets of values in the list {1, 2, 3, 4, null, 5}.UsagePower Query MList.Positions({1, 2, 3, 4, null, 5})Output{0, 1, 2, 3, 4, 5}",
                    "pages": []
                },
                {
                    "title": "List.Product",
                    "Syntax": "List.Product(numbersList as list, optional precision as nullable number) as nullable number",
                    "About": "Returns the product of the non-null numbers in the list, numbersList. Returns null if there are no non-null values in the list.",
                    "Explain": "Find the product of the numbers in the list {1, 2, 3, 3, 4, 5, 5}.UsagePower Query MList.Product({1, 2, 3, 3, 4, 5, 5})Output1800",
                    "pages": []
                },
                {
                    "title": "List.Random",
                    "Syntax": "List.Random(count as number, optional seed as nullable number) as list",
                    "About": "Returns a list of random numbers between 0 and 1, given the number of values to generate and an optional seed value.count: The number of random values to generate.seed: [Optional] A numeric value used to seed the random number generator. If omitted a unique list of random numbers is generated each time you call the function. If you specify the seed value with a number every call to the function generates the same list of random numbers.",
                    "Explain": "Example 1Create a list of 3 random numbers.UsagePower Query MList.Random(3)Output{0.992332, 0.132334, 0.023592}Example 2Create a list of 3 random numbers, specifying seed value.UsagePower Query MList.Random(3, 2)Output{0.883002, 0.245344, 0.723212}",
                    "pages": []
                },
                {
                    "title": "List.Range",
                    "Syntax": "List.Range(list as list, offset as number, optional count as nullable number) as list",
                    "About": "Returns a subset of the list beginning at the offset list. An optional parameter, offset, sets the maximum number of items in the subset.",
                    "Explain": "Example 1Find the subset starting at offset 6 of the list of numbers 1 through 10.UsagePower Query MList.Range({1..10}, 6)Output{7, 8, 9, 10}Example 2Find the subset of length 2 from offset 6, from the list of numbers 1 through 10.UsagePower Query MList.Range({1..10}, 6, 2)Output{7, 8}",
                    "pages": []
                },
                {
                    "title": "List.RemoveFirstN",
                    "Syntax": "List.RemoveFirstN(list as list, optional countOrCondition as any) as list",
                    "About": "Returns a list that removes the first element of list list. If list is an empty list an empty list is returned. This function takes an optional parameter, countOrCondition, to support removing multiple values as listed below.If a number is specified, up to that many items are removed.If a condition is specified, the returned list begins with the first element in list that meets the criteria. Once an item fails the condition, no further items are considered.If this parameter is null, the default behavior is observed.",
                    "Explain": "Example 1Create a list from {1, 2, 3, 4, 5} without the first 3 numbers.UsagePower Query MList.RemoveFirstN({1, 2, 3, 4, 5}, 3)Output{4, 5}Example 2Create a list from {5, 4, 2, 6, 1} that starts with a number less than 3.UsagePower Query MList.RemoveFirstN({5, 4, 2, 6, 1}, each _ > 3)Output{2, 6, 1}",
                    "pages": []
                },
                {
                    "title": "List.RemoveItems",
                    "Syntax": "List.RemoveItems(list1 as list, list2 as list) as list",
                    "About": "Removes all occurrences of the given values in the list2 from list1. If the values in list2 don't exist in list1, the original list is returned.",
                    "Explain": "Remove the items in the list {2, 4, 6} from the list {1, 2, 3, 4, 2, 5, 5}.UsagePower Query MList.RemoveItems({1, 2, 3, 4, 2, 5, 5}, {2, 4, 6})Output{1, 3, 5, 5}",
                    "pages": []
                },
                {
                    "title": "List.RemoveLastN",
                    "Syntax": "List.RemoveLastN(list as list, optional countOrCondition as any) as list",
                    "About": "Returns a list that removes the last countOrCondition elements from the end of list list. If list has less than countOrCondition elements, an empty list is returned.If a number is specified, up to that many items are removed.If a condition is specified, the returned list ends with the first element from the bottom in list that meets the criteria. Once an item fails the condition, no further items are considered.If this parameter is null, only one item is removed.",
                    "Explain": "Example 1Create a list from {1, 2, 3, 4, 5} without the last 3 numbers.UsagePower Query MList.RemoveLastN({1, 2, 3, 4, 5}, 3)Output{1, 2}Example 2Create a list from {5, 4, 2, 6, 4} that ends with a number less than 3.UsagePower Query MList.RemoveLastN({5, 4, 2, 6, 4}, each _ > 3)Output{5, 4, 2}",
                    "pages": []
                },
                {
                    "title": "List.RemoveMatchingItems",
                    "Syntax": "List.RemoveMatchingItems(list1 as list, list2 as list, optional equationCriteria as any) as list",
                    "About": "Removes all occurrences of the given values in list2 from the list list1. If the values in list2 don't exist in list1, the original list is returned. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Create a list from {1, 2, 3, 4, 5, 5} without {1, 5}.UsagePower Query MList.RemoveMatchingItems({1, 2, 3, 4, 5, 5}, {1, 5})Output{2, 3, 4}",
                    "pages": []
                },
                {
                    "title": "List.RemoveNulls",
                    "Syntax": "List.RemoveNulls(list as list) as list",
                    "About": "Removes all occurrences of \"null\" values in the list. If there are no 'null' values in the list, the original list is returned.",
                    "Explain": "Remove the \"null\" values from the list {1, 2, 3, null, 4, 5, null, 6}.UsagePower Query MList.RemoveNulls({1, 2, 3, null, 4, 5, null, 6})Output{1, 2, 3, 4, 5, 6}",
                    "pages": []
                },
                {
                    "title": "List.RemoveRange",
                    "Syntax": "List.RemoveRange(list as list, index as number, optional count as nullable number) as list",
                    "About": "Removes count values in the list starting at the specified position, index.",
                    "Explain": "Remove 3 values in the list {1, 2, 3, 4, -6, -2, -1, 5} starting at index 4.UsagePower Query MList.RemoveRange({1, 2, 3, 4, -6, -2, -1, 5}, 4, 3)Output{1, 2, 3, 4, 5}",
                    "pages": []
                },
                {
                    "title": "List.Repeat",
                    "Syntax": "List.Repeat(list as list, count as number) as list",
                    "About": "Returns a list that is count repetitions of the original list, list.",
                    "Explain": "Create a list that has {1, 2} repeated 3 times.UsagePower Query MList.Repeat({1, 2}, 3)Output{1, 2, 1, 2, 1, 2}",
                    "pages": []
                },
                {
                    "title": "List.ReplaceMatchingItems",
                    "Syntax": "List.ReplaceMatchingItems(list as list, replacements as list, optional equationCriteria as any) as list",
                    "About": "Performs the given replacements to the list list. A replacement operation replacements consists of a list of two values, the old value and new value, provided in a list. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Create a list from {1, 2, 3, 4, 5} replacing the value 5 with -5, and the value 1 with -1.UsagePower Query MList.ReplaceMatchingItems({1, 2, 3, 4, 5}, {{5, -5}, {1, -1}})Output{-1, 2, 3, 4, -5}",
                    "pages": []
                },
                {
                    "title": "List.ReplaceRange",
                    "Syntax": "List.ReplaceRange(list as list, index as number, count as number, replaceWith as list) as list",
                    "About": "Replaces count values in the list with the list replaceWith, starting at specified position, index.",
                    "Explain": "Replace {7, 8, 9} in the list {1, 2, 7, 8, 9, 5} with {3, 4}.UsagePower Query MList.ReplaceRange({1, 2, 7, 8, 9, 5}, 2, 3, {3, 4})Output{1, 2, 3, 4, 5}",
                    "pages": []
                },
                {
                    "title": "List.ReplaceValue",
                    "Syntax": "List.ReplaceValue(list as list, oldValue as any, newValue as any, replacer as function) as list",
                    "About": "Searches a list of values, list, for the value oldValue and replaces each occurrence with the replacement value newValue.",
                    "Explain": "Replace all the \"a\" values in the list {\"a\", \"B\", \"a\", \"a\"} with \"A\".UsagePower Query MList.ReplaceValue({\"a\", \"B\", \"a\", \"a\"}, \"a\", \"A\", Replacer.ReplaceText)Output{\"A\", \"B\", \"A\", \"A\"}",
                    "pages": []
                },
                {
                    "title": "List.Reverse",
                    "Syntax": "List.Reverse(list as list) as list",
                    "About": "Returns a list with the values in the list list in reversed order.",
                    "Explain": "Create a list from {1..10} in reverse order.UsagePower Query MList.Reverse({1..10})Output{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}",
                    "pages": []
                },
                {
                    "title": "List.Select",
                    "Syntax": "List.Select(list as list, selection as function) as list",
                    "About": "Returns a list of values from the list list, that match the selection condition selection.",
                    "Explain": "Find the values in the list {1, -3, 4, 9, -2} that are greater than 0.UsagePower Query MList.Select({1, -3, 4, 9, -2}, each _ > 0)Output{1, 4, 9}",
                    "pages": []
                },
                {
                    "title": "List.Single",
                    "Syntax": "List.Single(list as list) as any",
                    "About": "If there is only one item in the list list, returns that item. If there is more than one item or the list is empty, the function throws an exception.",
                    "Explain": "Example 1Find the single value in the list {1}.UsagePower Query MList.Single({1})Output1Example 2Find the single value in the list {1, 2, 3}.UsagePower Query MList.Single({1, 2, 3})Output[Expression.Error] There were too many elements in the enumeration to complete the operation.",
                    "pages": []
                },
                {
                    "title": "List.SingleOrDefault",
                    "Syntax": "List.SingleOrDefault(list as list, optional default as any) as any",
                    "About": "If there is only one item in the list list, returns that item. If the list is empty, the function returns null unless an optional default is specified. If there is more than one item in the list, the function returns an error.",
                    "Explain": "Example 1Find the single value in the list {1}.UsagePower Query MList.SingleOrDefault({1})Output1Example 2Find the single value in the list {}.UsagePower Query MList.SingleOrDefault({})OutputnullExample 3Find the single value in the list {}. If is empty, return -1.UsagePower Query MList.SingleOrDefault({}, -1)Output-1",
                    "pages": []
                },
                {
                    "title": "List.Skip",
                    "Syntax": "List.Skip(list as list, optional countOrCondition as any) as list",
                    "About": "Returns a list that skips the first element of list list. If list is an empty list an empty list is returned. This function takes an optional parameter, countOrCondition, to support skipping multiple values as listed below.If a number is specified, up to that many items are skipped.If a condition is specified, the returned list begins with the first element in list that meets the criteria. Once an item fails the condition, no further items are considered.If this parameter is null, the default behavior is observed.",
                    "Explain": "Example 1Create a list from {1, 2, 3, 4, 5} without the first 3 numbers.UsagePower Query MList.Skip({1, 2, 3, 4, 5}, 3)Output{4, 5}Example 2Create a list from {5, 4, 2, 6, 1} that starts with a number less than 3.UsagePower Query MList.Skip({5, 4, 2, 6, 1}, each _ > 3)Output{2, 6, 1}",
                    "pages": []
                },
                {
                    "title": "List.Sort",
                    "Syntax": "List.Sort(list as list, optional comparisonCriteria as any) as list",
                    "About": "Sorts a list of data, list, according to the optional criteria specified. An optional parameter, comparisonCriteria, can be specified as the comparison criterion. This can take the following values:To control the order, the comparison criterion can be an Order enum value. (Order.Descending, Order.Ascending).To compute a key to be used for sorting, a function of 1 argument can be used.To both select a key and control order, comparison criterion can be a list containing the key and order ({each 1 / _, Order.Descending}).To completely control the comparison, a function of 2 arguments can be used. This function will be passed two items from the list (any two items, in any order). The function should return one of the following values:-1: The first item is less than the second item.0: The items are equal.1: The first item is greater than the second item.Value.Compare is a method that can be used to delegate this logic.",
                    "Explain": "Example 1Sort the list {2, 3, 1}.UsagePower Query MList.Sort({2, 3, 1})Output{1, 2, 3}Example 2Sort the list {2, 3, 1} in descending order.UsagePower Query MList.Sort({2, 3, 1}, Order.Descending)Output{3, 2, 1}Example 3Sort the list {2, 3, 1} in descending order using the Value.Compare method.UsagePower Query MList.Sort({2, 3, 1}, (x, y) => Value.Compare(1/x, 1/y))Output{3, 2, 1}",
                    "pages": []
                },
                {
                    "title": "List.Split",
                    "Syntax": "List.Split(list as list, pageSize as number) as list",
                    "About": "Splits list into a list of lists where the first element of the output list is a list containing the first pageSize elements from the source list, the next element of the output list is a list containing the next pageSize elements from the source list, and so on.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "List.StandardDeviation",
                    "Syntax": "List.StandardDeviation(numbersList as list) as nullable number",
                    "About": "Returns a sample based estimate of the standard deviation of the values in the list, numbersList. If numbersList is a list of numbers, a number is returned. An exception is thrown on an empty list or a list of items that is not type number.",
                    "Explain": "Find the standard deviation of the numbers 1 through 5.UsagePower Query MList.StandardDeviation({1..5})Output1.5811388300841898",
                    "pages": []
                },
                {
                    "title": "List.Sum",
                    "Syntax": "List.Sum(list as list, optional precision as nullable number) as any",
                    "About": "Returns the sum of the non-null values in the list, list. Returns null if there are no non-null values in the list.",
                    "Explain": "Find the sum of the numbers in the list {1, 2, 3}.UsagePower Query MList.Sum({1, 2, 3})Output6",
                    "pages": []
                },
                {
                    "title": "List.Times",
                    "Syntax": "List.Times(start as time, count as number, step as duration) as list",
                    "About": "Returns a list of time values of size count, starting at start. The given increment, step, is a duration value that is added to every value.",
                    "Explain": "Create a list of 4 values starting from noon (#time(12, 0, 0)) incrementing by one hour (#duration(0, 1, 0, 0)).UsagePower Query MList.Times(#time(12, 0, 0), 4, #duration(0, 1, 0, 0))Output{\u00a0\u00a0\u00a0\u00a0#time(12, 0, 0),\u00a0\u00a0\u00a0\u00a0#time(13, 0, 0),\u00a0\u00a0\u00a0\u00a0#time(14, 0, 0),\u00a0\u00a0\u00a0\u00a0#time(15, 0, 0)}",
                    "pages": []
                },
                {
                    "title": "List.Transform",
                    "Syntax": "List.Transform(list as list, transform as function) as list",
                    "About": "Returns a new list of values by applying the transform function transform to the list, list.",
                    "Explain": "Add 1 to each value in the list {1, 2}.UsagePower Query MList.Transform({1, 2}, each _ + 1)Output{2, 3}",
                    "pages": []
                },
                {
                    "title": "List.TransformMany",
                    "Syntax": "List.TransformMany(list as list, collectionTransform as function, resultTransform as function) as list",
                    "About": "Returns a list whose elements are projected from the input list.The collectionTransform function transforms each element into an intermediate list, and the resultTransform function receives the original element as well as an item from the intermediate list in order to construct the final result.The collectionTransform function has the signature (x as any) as list => ..., where x is an element in list. The resultTransform function projects the shape of the result and has the signature (x as any, y as any) as any => ..., where x is an element in list and y is an element from the list generated by passing x to collectionTransform.",
                    "Explain": "Flatten a list of people and their pets.UsagePower Query MList.TransformMany(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Alice\", Pets = {\"Scruffy\", \"Sam\"}],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Pets = {\"Walker\"}]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0each [Pets],\u00a0\u00a0\u00a0\u00a0(person, pet) => [Name = person[Name], Pet = pet])Output{\u00a0\u00a0\u00a0\u00a0[Name = \"Alice\", Pet = \"Scruffy\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Alice\", Pet = \"Sam\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Pet = \"Walker\"]}",
                    "pages": []
                },
                {
                    "title": "List.Union",
                    "Syntax": "List.Union(lists as list, optional equationCriteria as any) as list",
                    "About": "Takes a list of lists lists, unions the items in the individual lists and returns them in the output list. As a result, the returned list contains all items in any input lists. This operation maintains traditional bag semantics, so duplicate values are matched as part of the Union. An optional equation criteria value, equationCriteria, can be specified to control equality testing.",
                    "Explain": "Create a union of the list {1..5}, {2..6}, {3..7}.UsagePower Query MList.Union({{1..5}, {2..6}, {3..7}})Output{1, 2, 3, 4, 5, 6, 7}",
                    "pages": []
                },
                {
                    "title": "List.Zip",
                    "Syntax": "List.Zip(lists as list) as list",
                    "About": "Takes a list of lists, lists, and returns a list of lists combining items at the same position.",
                    "Explain": "Example 1Zips the two simple lists {1, 2} and {3, 4}.UsagePower Query MList.Zip({{1, 2}, {3, 4}})Output{\u00a0\u00a0\u00a0\u00a0{1, 3},\u00a0\u00a0\u00a0\u00a0{2, 4}}Example 2Zips the two simple lists of different lengths {1, 2} and {3}.UsagePower Query MList.Zip({{1, 2}, {3}})Output{\u00a0\u00a0\u00a0\u00a0{1, 3},\u00a0\u00a0\u00a0\u00a0{2, null}}",
                    "pages": []
                }
            ]
        },
        {
            "title": "Logical functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Logical.From",
                    "Syntax": "Logical.From(value as any) as nullable logical",
                    "About": "Returns a logical value from the given value. If the given value is null, Logical.From returns null. If the given value is logical, value is returned.Values of the following types can be converted to a logical value:text: A logical value from the text value, either \"true\" or \"false\". Refer to Logical.FromText for details.number: false if value equals 0, true otherwise.If value is of any other type, an error is returned.",
                    "Explain": "Convert 2 to a logical value.UsagePower Query MLogical.From(2)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Logical.FromText",
                    "Syntax": "Logical.FromText(text as nullable text) as nullable logical",
                    "About": "Creates a logical value from the text value text, either \"true\" or \"false\". If text contains a different string, an exception is thrown. The text value text is case insensitive.",
                    "Explain": "Example 1Create a logical value from the text string \"true\".UsagePower Query MLogical.FromText(\"true\")OutputtrueExample 2Create a logical value from the text string \"a\".UsagePower Query MLogical.FromText(\"a\")Output[Expression.Error] Could not convert to a logical.",
                    "pages": []
                },
                {
                    "title": "Logical.ToText",
                    "Syntax": "Logical.ToText(logicalValue as nullable logical) as nullable text",
                    "About": "Creates a text value from the logical value logicalValue, either true or false. If logicalValue is not a logical value, an exception is thrown.",
                    "Explain": "Create a text value from the logical true.UsagePower Query MLogical.ToText(true)Output\"true\"",
                    "pages": []
                }
            ]
        },
        {
            "title": "Number functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Byte.From",
                    "Syntax": "Byte.From(value as any, optional culture as nullable text, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns an 8-bit integer number value from the given value. If the given value is null, Byte.From returns null. If the given value is a number within the range of an 8-bit integer without a fractional part, value is returned. If it has fractional part, then the number is rounded with the rounding mode specified. The default rounding mode is RoundingMode.ToEven. If value is of any other type, it will first be converted to a number using Number.FromText. Refer to Number.Round for the available rounding modes. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Get the 8-bit integer number value of \"4\".UsagePower Query MByte.From(\"4\")Output4Example 2Get the 8-bit integer number value of \"4.5\" using RoundingMode.AwayFromZero.UsagePower Query MByte.From(\"4.5\", null, RoundingMode.AwayFromZero)Output5",
                    "pages": []
                },
                {
                    "title": "Currency.From",
                    "Syntax": "Currency.From(value as any, optional culture as nullable text, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns a currency value from the given value. If the given value is null, Currency.From returns null. If the given value is number within the range of currency, fractional part of the value is rounded to 4 decimal digits and returned. If value is of any other type, it will first be converted to a number using Number.FromText. Valid range for currency is -922,337,203,685,477.5808 to 922,337,203,685,477.5807. Refer to Number.Round for the available rounding modes. The default is RoundingMode.ToEven. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Get the currency value of \"1.23455\".UsagePower Query MCurrency.From(\"1.23455\")Output1.2346Example 2Get the currency value of \"1.23455\" using RoundingMode.Down.UsagePower Query MCurrency.From(\"1.23455\", \"en-US\", RoundingMode.Down)Output1.2345",
                    "pages": []
                },
                {
                    "title": "Decimal.From",
                    "Syntax": "Decimal.From(value as any, optional culture as nullable text) as nullable number",
                    "About": "Returns a Decimal number value from the given value. If the given value is null, Decimal.From returns null. If the given value is number within the range of Decimal, value is returned, otherwise an error is returned. If value is of any other type, it will first be converted to a number using Number.FromText. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the Decimal number value of \"4.5\".UsagePower Query MDecimal.From(\"4.5\")Output4.5",
                    "pages": []
                },
                {
                    "title": "Double.From",
                    "Syntax": "Double.From(value as any, optional culture as nullable text) as nullable number",
                    "About": "Returns a Double number value from the given value. If the given value is null, Double.From returns null. If the given value is number within the range of Double, value is returned, otherwise an error is returned. If value is of any other type, it will first be converted to a number using Number.FromText. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the Double number value of \"4\".UsagePower Query MDouble.From(\"4.5\")Output4.5",
                    "pages": []
                },
                {
                    "title": "Int8.From",
                    "Syntax": "Int8.From(value as any, optional culture as nullable text, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns a signed 8-bit integer number value from the given value. If the given value is null, Int8.From returns null. If the given value is number within the range of signed 8-bit integer without a fractional part, value is returned. If it has fractional part, then the number is rounded with the rounding mode specified. The default rounding mode is RoundingMode.ToEven. If value is of any other type, it will first be converted to a number using Number.FromText. Refer to Number.Round for the available rounding modes. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Get the signed 8-bit integer number value of \"4\".UsagePower Query MInt8.From(\"4\")Output4Example 2Get the signed 8-bit integer number value of \"4.5\" using RoundingMode.AwayFromZero.UsagePower Query MInt8.From(\"4.5\", null, RoundingMode.AwayFromZero)Output5",
                    "pages": []
                },
                {
                    "title": "Int16.From",
                    "Syntax": "Int16.From(value as any, optional culture as nullable text, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns a 16-bit integer number value from the given value. If the given value is null, Int16.From returns null. If the given value is number within the range of 16-bit integer without a fractional part, value is returned. If it has fractional part, then the number is rounded with the rounding mode specified. The default rounding mode is RoundingMode.ToEven. If value is of any other type, it will first be converted to a number using Number.FromText. Refer to Number.Round for the available rounding modes. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Get the 16-bit integer number value of \"4\".UsagePower Query MInt16.From(\"4\")Output4Example 2Get the 16-bit integer number value of \"4.5\" using RoundingMode.AwayFromZero.UsagePower Query MInt16.From(\"4.5\", null, RoundingMode.AwayFromZero)Output5",
                    "pages": []
                },
                {
                    "title": "Int32.From",
                    "Syntax": "Int32.From(value as any, optional culture as nullable text, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns a 32-bit integer number value from the given value. If the given value is null, Int32.From returns null. If the given value is number within the range of 32-bit integer without a fractional part, value is returned. If it has fractional part, then the number is rounded with the rounding mode specified. The default rounding mode is RoundingMode.ToEven. If value is of any other type, it will first be converted to a number using Number.FromText. Refer to Number.Round for the available rounding modes. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Get the 32-bit integer number value of \"4\".UsagePower Query MInt32.From(\"4\")Output4Example 2Get the 32-bit integer number value of \"4.5\" using RoundingMode.AwayFromZero.UsagePower Query MInt32.From(\"4.5\", null, RoundingMode.AwayFromZero)Output5",
                    "pages": []
                },
                {
                    "title": "Int64.From",
                    "Syntax": "Int64.From(value as any, optional culture as nullable text, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns a 64-bit integer number value from the given value. If the given value is null, Int64.From returns null. If the given value is number within the range of 64-bit integer without a fractional part, value is returned. If it has fractional part, then the number is rounded with the rounding mode specified. The default rounding mode is RoundingMode.ToEven. If value is of any other type, it will first be converted to a number using Number.FromText. Refer to Number.Round for the available rounding modes. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Get the 64-bit integer number value of \"4\".UsagePower Query MInt64.From(\"4\")Output4Example 2Get the 64-bit integer number value of \"4.5\" using RoundingMode.AwayFromZero.UsagePower Query MInt64.From(\"4.5\", null, RoundingMode.AwayFromZero)Output5",
                    "pages": []
                },
                {
                    "title": "Number.Abs",
                    "Syntax": "Number.Abs(number as nullable number) as nullable number",
                    "About": "Returns the absolute value of number. If number is null, Number.Abs returns null.number: A number for which the absolute value is to be calculated.",
                    "Explain": "Absolute value of -3.UsagePower Query MNumber.Abs(-3)Output3",
                    "pages": []
                },
                {
                    "title": "Number.Acos",
                    "Syntax": "Number.Acos(number as nullable number) as nullable number",
                    "About": "Returns the arccosine of number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.Asin",
                    "Syntax": "Number.Asin(number as nullable number) as nullable number",
                    "About": "Returns the arcsine of number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.Atan",
                    "Syntax": "Number.Atan(number as nullable number) as nullable number",
                    "About": "Returns the arctangent of number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.Atan2",
                    "Syntax": "Number.Atan2(y as nullable number, x as nullable number) as nullable number",
                    "About": "Returns the angle, in radians, whose tangent is the quotient y/x of the two numbers y and x.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.BitwiseAnd",
                    "Syntax": "Number.BitwiseAnd(number1 as nullable number, number2 as nullable number) as nullable number",
                    "About": "Returns the result of performing a bitwise \"And\" operation between number1 and number2.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.BitwiseNot",
                    "Syntax": "Number.BitwiseNot(number as any) as any",
                    "About": "Returns the result of performing a bitwise \"Not\" operation on number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.BitwiseOr",
                    "Syntax": "Number.BitwiseOr(number1 as nullable number, number2 as nullable number) as nullable number",
                    "About": "Returns the result of performing a bitwise \"Or\" between number1 and number2.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.BitwiseShiftLeft",
                    "Syntax": "Number.BitwiseShiftLeft(number1 as nullable number, number2 as nullable number) as nullable number",
                    "About": "Returns the result of performing a bitwise shift to the left on number1, by the specified number of bits number2.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.BitwiseShiftRight",
                    "Syntax": "Number.BitwiseShiftRight(number1 as nullable number, number2 as nullable number) as nullable number",
                    "About": "Returns the result of performing a bitwise shift to the right on number1, by the specified number of bits number2.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.BitwiseXor",
                    "Syntax": "Number.BitwiseXor(number1 as nullable number, number2 as nullable number) as nullable number",
                    "About": "Returns the result of performing a bitwise \"XOR\" (Exclusive-OR) between number1 and number2.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.Combinations",
                    "Syntax": "Number.Combinations(setSize as nullable number, combinationSize as nullable number) as nullable number",
                    "About": "Returns the number of unique combinations from a list of items, setSize with specified combination size, combinationSize.setSize: The number of items in the list.combinationSize: The number of items in each combination.",
                    "Explain": "Find the number of combinations from a total of 5 items when each combination is a group of 3.UsagePower Query MNumber.Combinations(5, 3)Output10",
                    "pages": []
                },
                {
                    "title": "Number.Cos",
                    "Syntax": "Number.Cos(number as nullable number) as nullable number",
                    "About": "Returns the cosine of number.",
                    "Explain": "Find the cosine of the angle 0.UsagePower Query MNumber.Cos(0)Output1",
                    "pages": []
                },
                {
                    "title": "Number.Cosh",
                    "Syntax": "Number.Cosh(number as nullable number) as nullable number",
                    "About": "Returns the hyperbolic cosine of number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.Exp",
                    "Syntax": "Number.Exp(number as nullable number) as nullable number",
                    "About": "Returns the result of raising e to the power of number (exponential function).number: A number for which the exponential function is to be calculated. If number is null, Number.Exp returns null.",
                    "Explain": "Raise e to the power of 3.UsagePower Query MNumber.Exp(3)Output20.085536923187668",
                    "pages": []
                },
                {
                    "title": "Number.Factorial",
                    "Syntax": "Number.Factorial(number as nullable number) as nullable number",
                    "About": "Returns the factorial of the number number.",
                    "Explain": "Find the factorial of 10.UsagePower Query MNumber.Factorial(10)Output3628800",
                    "pages": []
                },
                {
                    "title": "Number.From",
                    "Syntax": "Number.From(value as any, optional culture as nullable text) as nullable number",
                    "About": "Returns a number value from the given value. An optional culture may also be provided (for example, \"en-US\"). If the given value is null, Number.From returns null. If the given value is number, value is returned. Values of the following types can be converted to a number value:text: A number value from textual representation. Common text formats are handled (\"15\", \"3,423.10\", \"5.0E-10\"). Refer to Number.FromText for details.logical: 1 for true, 0 for false.datetime: A double-precision floating-point number that contains an OLE Automation date equivalent.datetimezone: A double-precision floating-point number that contains an OLE Automation date equivalent of the local date and time of value.date: A double-precision floating-point number that contains an OLE Automation date equivalent.time: Expressed in fractional days.duration: Expressed in whole and fractional days.If value is of any other type, an error is returned.",
                    "Explain": "Example 1Get the number value of \"4\".UsagePower Query MNumber.From(\"4\")Output4Example 2Get the number value of #datetime(2020, 3, 20, 6, 0, 0).UsagePower Query MNumber.From(#datetime(2020, 3, 20, 6, 0, 0))Output43910.25Example 3Get the number value of \"12.3%\".UsagePower Query MNumber.From(\"12.3%\")Output0.123",
                    "pages": []
                },
                {
                    "title": "Number.FromText",
                    "Syntax": "Number.FromText(text as nullable text, optional culture as nullable text) as nullable number",
                    "About": "Returns a number value from the given text value, text.text: The textual representation of a number value. The representation must be in a common number format, such as \"15\", \"3,423.10\", or \"5.0E-10\".culture: An optional culture that controls how text is interpreted (for example, \"en-US\").",
                    "Explain": "Example 1Get the number value of \"4\".UsagePower Query MNumber.FromText(\"4\")Output4Example 2Get the number value of \"5.0e-10\".UsagePower Query MNumber.FromText(\"5.0e-10\")Output5E-10",
                    "pages": []
                },
                {
                    "title": "Number.IntegerDivide",
                    "Syntax": "Number.IntegerDivide(number1 as nullable number, number2 as nullable number, optional precision as nullable number) as nullable number",
                    "About": "Returns the integer portion of the result from dividing a number, number1, by another number, number2. If number1 or number2 are null, Number.IntegerDivide returns null.number1: The dividend.number2: The divisor.",
                    "Explain": "Example 1Divide 6 by 4.UsagePower Query MNumber.IntegerDivide(6, 4)Output1Example 2Divide 8.3 by 3.UsagePower Query MNumber.IntegerDivide(8.3, 3)Output2",
                    "pages": []
                },
                {
                    "title": "Number.IsEven",
                    "Syntax": "Number.IsEven(number as number) as logical",
                    "About": "Indicates if the value, number, is even by returning true if it is even, false otherwise.",
                    "Explain": "Example 1Check if 625 is an even number.UsagePower Query MNumber.IsEven(625)OutputfalseExample 2Check if 82 is an even number.UsagePower Query MNumber.IsEven(82)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Number.Isnull",
                    "Syntax": "Number.Isnull(number as number) as logical",
                    "About": "Indicates if the value is null (Not a number). Returns true if number is equivalent to Number.Isnull, false otherwise.",
                    "Explain": "Example 1Check if 0 divided by 0 is null.UsagePower Query MNumber.Isnull(0/0)OutputtrueExample 2Check if 1 divided by 0 is null.UsagePower Query MNumber.Isnull(1/0)Outputfalse",
                    "pages": []
                },
                {
                    "title": "Number.IsOdd",
                    "Syntax": "Number.IsOdd(number as number) as logical",
                    "About": "Indicates if the value is odd. Returns true if number is an odd number, false otherwise.",
                    "Explain": "Example 1Check if 625 is an odd number.UsagePower Query MNumber.IsOdd(625)OutputtrueExample 2Check if 82 is an odd number.UsagePower Query MNumber.IsOdd(82)Outputfalse",
                    "pages": []
                },
                {
                    "title": "Number.Ln",
                    "Syntax": "Number.Ln(number as nullable number) as nullable number",
                    "About": "Returns the natural logarithm of a number, number. If number is null Number.Ln returns null.",
                    "Explain": "Get the natural logarithm of 15.UsagePower Query MNumber.Ln(15)Output2.70805020110221",
                    "pages": []
                },
                {
                    "title": "Number.Log",
                    "Syntax": "Number.Log(number as nullable number, optional base as nullable number) as nullable number",
                    "About": "Returns the logarithm of a number, number, to the specified base base. If base is not specified, the default value is Number.E. If number is null Number.Log returns null.",
                    "Explain": "Example 1Get the base 10 logarithm of 2.UsagePower Query MNumber.Log(2, 10)Output0.3010299956639812Example 2Get the base e logarithm of 2.UsagePower Query MNumber.Log(2)Output0.69314718055994529",
                    "pages": []
                },
                {
                    "title": "Number.Log10",
                    "Syntax": "Number.Log10(number as nullable number) as nullable number",
                    "About": "Returns the base 10 logarithm of a number, number. If number is null Number.Log10 returns null.",
                    "Explain": "Get the base 10 logarithm of 2.UsagePower Query MNumber.Log10(2)Output0.3010299956639812",
                    "pages": []
                },
                {
                    "title": "Number.Mod",
                    "Syntax": "Number.Mod(number as nullable number, divisor as nullable number, optional precision as nullable number) as nullable number",
                    "About": "Returns the remainder resulting from the integer division of number by divisor. If number or divisor are null, Number.Mod returns null.number: The dividend.divisor: The divisor.",
                    "Explain": "Find the remainder when you divide 5 by 3.UsagePower Query MNumber.Mod(5, 3)Output2",
                    "pages": []
                },
                {
                    "title": "Number.Permutations",
                    "Syntax": "Number.Permutations(setSize as nullable number, permutationSize as nullable number) as nullable number",
                    "About": "Returns the number of permutations that can be generated from a number of items, setSize, with a specified permutation size, permutationSize.",
                    "Explain": "Find the number of permutations from a total of 5 items in groups of 3.UsagePower Query MNumber.Permutations(5, 3)Output60",
                    "pages": []
                },
                {
                    "title": "Number.Power",
                    "Syntax": "Number.Power(number as nullable number, power as nullable number) as nullable number",
                    "About": "Returns the result of raising number to the power of power. If number or power are null, Number.Power returns null.number: The base.power: The exponent.",
                    "Explain": "Find the value of 5 raised to the power of 3 (5 cubed).UsagePower Query MNumber.Power(5, 3)Output125",
                    "pages": []
                },
                {
                    "title": "Number.Random",
                    "Syntax": "Number.Random() as number",
                    "About": "Returns a random number between 0 and 1.",
                    "Explain": "Get a random number.UsagePower Query MNumber.Random()Output0.919303",
                    "pages": []
                },
                {
                    "title": "Number.RandomBetween",
                    "Syntax": "Number.RandomBetween(bottom as number, top as number) as number",
                    "About": "Returns a random number between bottom and top.",
                    "Explain": "Get a random number between 1 and 5.UsagePower Query MNumber.RandomBetween(1, 5)Output2.546797",
                    "pages": []
                },
                {
                    "title": "Number.Round",
                    "Syntax": "Number.Round(number as nullable number, optional digits as nullable number, optional roundingMode as nullable number) as nullable number",
                    "About": "Returns the result of rounding number to the nearest number. If number is null, Number.Round returns null.By default, number is rounded to the nearest integer, and ties are broken by rounding to the nearest even number (using RoundingMode.ToEven, also known as \"banker's rounding\").However, these defaults can be overridden via the following optional parameters.digits: Causes number to be rounded to the specified number of decimal digits.roundingMode: Overrides the default tie-breaking behavior when number is at the midpoint between two potential rounded values (refer to RoundingMode.Type for possible values).",
                    "Explain": "Example 1Round 1.234 to the nearest integer.UsagePower Query MNumber.Round(1.234)Output1Example 2Round 1.56 to the nearest integer.UsagePower Query MNumber.Round(1.56)Output2Example 3Round 1.2345 to two decimal places.UsagePower Query MNumber.Round(1.2345, 2)Output1.23Example 4Round 1.2345 to three decimal places (Rounding up).UsagePower Query MNumber.Round(1.2345, 3, RoundingMode.Up)Output1.235Example 5Round 1.2345 to three decimal places (Rounding down).UsagePower Query MNumber.Round(1.2345, 3, RoundingMode.Down)Output1.234",
                    "pages": []
                },
                {
                    "title": "Number.RoundAwayFromZero",
                    "Syntax": "Number.RoundAwayFromZero(number as nullable number, optional digits as nullable number) as nullable number",
                    "About": "Returns the result of rounding number based on the sign of the number. This function will round positive numbers up and negative numbers down. If digits is specified, number is rounded to the digits number of decimal digits.",
                    "Explain": "Example 1Round the number -1.2 away from zero.UsagePower Query MNumber.RoundAwayFromZero(-1.2)Output-2Example 2Round the number 1.2 away from zero.UsagePower Query MNumber.RoundAwayFromZero(1.2)Output2Example 3Round the number -1.234 to two decimal places away from zero.UsagePower Query MNumber.RoundAwayFromZero(-1.234, 2)Output-1.24",
                    "pages": []
                },
                {
                    "title": "Number.RoundDown",
                    "Syntax": "Number.RoundDown(number as nullable number, optional digits as nullable number) as nullable number",
                    "About": "Returns the result of rounding number down to the previous highest integer. If number is null, this function returns null. If digits is provided, number is rounded to the specified number of decimal digits.",
                    "Explain": "Example 1Round down 1.234 to integer.UsagePower Query MNumber.RoundDown(1.234)Output1Example 2Round down 1.999 to integer.UsagePower Query MNumber.RoundDown(1.999)Output1Example 3Round down 1.999 to two decimal places.UsagePower Query MNumber.RoundDown(1.999, 2)Output1.99",
                    "pages": []
                },
                {
                    "title": "Number.RoundTowardZero",
                    "Syntax": "Number.RoundTowardZero(number as nullable number, optional digits as nullable number) as nullable number",
                    "About": "Returns the result of rounding number based on the sign of the number. This function will round positive numbers down and negative numbers up. If digits is specified, number is rounded to the digits number of decimal digits.",
                    "Explain": "Example 1Round the number -1.2 toward zero.UsagePower Query MNumber.RoundTowardZero(-1.2)Output-1Example 2Round the number 1.2 toward zero.UsagePower Query MNumber.RoundTowardZero(1.2)Output1Example 3Round the number -1.234 to two decimal places toward zero.UsagePower Query MNumber.RoundTowardZero(-1.234, 2)Output-1.23",
                    "pages": []
                },
                {
                    "title": "Number.RoundUp",
                    "Syntax": "Number.RoundUp(number as nullable number, optional digits as nullable number) as nullable number",
                    "About": "Returns the result of rounding number up to the next highest integer. If number is null, this function returns null. If digits is provided, number is rounded to the specified number of decimal digits.",
                    "Explain": "Example 1Round up 1.234 to integer.UsagePower Query MNumber.RoundUp(1.234)Output2Example 2Round up 1.999 to integer.UsagePower Query MNumber.RoundUp(1.999)Output2Example 3Round up 1.234 to two decimal places.UsagePower Query MNumber.RoundUp(1.234, 2)Output1.24",
                    "pages": []
                },
                {
                    "title": "Number.Sign",
                    "Syntax": "Number.Sign(number as nullable number) as nullable number",
                    "About": "Returns 1 for if number is a positive number, -1 if it is a negative number, and 0 if it is zero. If number is null, Number.Sign returns null.",
                    "Explain": "Example 1Determine the sign of 182.UsagePower Query MNumber.Sign(182)Output1Example 2Determine the sign of -182.UsagePower Query MNumber.Sign(-182)Output-1Example 3Determine the sign of 0.UsagePower Query MNumber.Sign(0)Output0",
                    "pages": []
                },
                {
                    "title": "Number.Sin",
                    "Syntax": "Number.Sin(number as nullable number) as nullable number",
                    "About": "Returns the sine of number.",
                    "Explain": "Find the sine of the angle 0.UsagePower Query MNumber.Sin(0)Output0",
                    "pages": []
                },
                {
                    "title": "Number.Sinh",
                    "Syntax": "Number.Sinh(number as nullable number) as nullable number",
                    "About": "Returns the hyperbolic sine of number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.Sqrt",
                    "Syntax": "Number.Sqrt(number as nullable number) as nullable number",
                    "About": "Returns the square root of number. If number is null, Number.Sqrt returns null. If it is a negative value, Number.null is returned (Not a number).",
                    "Explain": "Example 1Find the square root of 625.UsagePower Query MNumber.Sqrt(625)Output25Example 2Find the square root of 85.UsagePower Query MNumber.Sqrt(85)Output9.2195444572928871",
                    "pages": []
                },
                {
                    "title": "Number.Tan",
                    "Syntax": "Number.Tan(number as nullable number) as nullable number",
                    "About": "Returns the tangent of number.",
                    "Explain": "Find the tangent of the angle 1.UsagePower Query MNumber.Tan(1)Output1.5574077246549023",
                    "pages": []
                },
                {
                    "title": "Number.Tanh",
                    "Syntax": "Number.Tanh(number as nullable number) as nullable number",
                    "About": "Returns the hyperbolic tangent of number.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Number.ToText",
                    "Syntax": "Number.ToText(number as nullable number, optional format as nullable text, optional culture as nullable text) as nullable text",
                    "About": "Converts the numeric value number to a text value according to the format specified by format.The format is a text value indicating how the number should be converted. For more details on the supported format values, go to https://go.microsoft.com/fwlink/?linkid=2241210 and https://go.microsoft.com/fwlink/?linkid=2240884.An optional culture may also be provided (for example, \"en-US\") to control the culture-dependent behavior of format.",
                    "Explain": "Example 1Convert a number to text without specifying a format.UsagePower Query MNumber.ToText(4)Output\"4\"Example 2Convert a number to exponential format.UsagePower Query MNumber.ToText(4, \"e\")Output\"4.000000e+000\"Example 3Convert a number to percentage format with only one decimal place.UsagePower Query MNumber.ToText(-0.1234, \"P1\")Output\"-12.3 %\"",
                    "pages": []
                },
                {
                    "title": "Percentage.From",
                    "Syntax": "Percentage.From(value as any, optional culture as nullable text) as nullable number",
                    "About": "Returns a percentage value from the given value. If the given value is null, Percentage.From returns null. If the given value is text with a trailing percent symbol, then the converted decimal number will be returned. Otherwise, the value will be converted to a number using Number.From. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the percentage value of \"12.3%\".UsagePower Query MPercentage.From(\"12.3%\")Output0.123",
                    "pages": []
                },
                {
                    "title": "Single.From",
                    "Syntax": "Single.From(value as any, optional culture as nullable text) as nullable number",
                    "About": "Returns a Single number value from the given value. If the given value is null, Single.From returns null. If the given value is number within the range of Single, value is returned, otherwise an error is returned. If value is of any other type, it will first be converted to a number using Number.FromText. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the Single number value of \"1.5\".UsagePower Query MSingle.From(\"1.5\")Output1.5",
                    "pages": []
                }
            ]
        },
        {
            "title": "Record functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Geography.FromWellKnownText",
                    "Syntax": "Geography.FromWellKnownText(input as nullable text) as nullable record",
                    "About": "Translates text representing a geographic value in Well-Known Text (WKT) format into a structured record. WKT is a standard format defined by the Open Geospatial Consortium (OGC) and is the typical serialization format used by databases including SQL Server.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Geography.ToWellKnownText",
                    "Syntax": "Geography.ToWellKnownText(input as nullable record, optional omitSRID as nullable logical) as nullable text",
                    "About": "Translates a structured geographic point value into its Well-Known Text (WKT) representation as defined by the Open Geospatial Consortium (OGC), also the serialization format used by many databases including SQL Server.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "GeographyPoint.From",
                    "Syntax": "GeographyPoint.From(longitude as number, latitude as number, optional z as nullable number, optional m as nullable number, optional srid as nullable number) as record",
                    "About": "Creates a record representing a geographic point from its constituent parts, such as longitude, latitude, and if present, elevation (Z) and measure (M). An optional spatial reference identifier (SRID) can be given if different from the default value (4326).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Geometry.FromWellKnownText",
                    "Syntax": "Geometry.FromWellKnownText(input as nullable text) as nullable record",
                    "About": "Translates text representing a geometric value in Well-Known Text (WKT) format into a structured record. WKT is a standard format defined by the Open Geospatial Consortium (OGC) and is the typical serialization format used by databases including SQL Server.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Geometry.ToWellKnownText",
                    "Syntax": "Geometry.ToWellKnownText(input as nullable record, optional omitSRID as nullable logical) as nullable text",
                    "About": "Translates a structured geometric point value into its Well-Known Text (WKT) representation as defined by the Open Geospatial Consortium (OGC), also the serialization format used by many databases including SQL Server.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "GeometryPoint.From",
                    "Syntax": "GeometryPoint.From(x as number, y as number, optional z as nullable number, optional m as nullable number, optional srid as nullable number) as record",
                    "About": "Creates a record representing a geometric point from its constituent parts, such as X coordinate, Y coordinate, and if present, Z coordinate and measure (M). An optional spatial reference identifier (SRID) can be given if different from the default value (0).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Record.AddField",
                    "Syntax": "Record.AddField(record as record, fieldName as text, value as any, optional delayed as nullable logical) as record",
                    "About": "Adds a field to a record record, given the name of the field fieldName and the value value.",
                    "Explain": "Add the field Address to the record.UsagePower Query MRecord.AddField([CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"], \"Address\", \"123 Main St.\")Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\", Address = \"123 Main St.\"]",
                    "pages": []
                },
                {
                    "title": "Record.Combine",
                    "Syntax": "Record.Combine(records as list) as record",
                    "About": "Combines the records in the given records. If the records contains non-record values, an error is returned.",
                    "Explain": "Create a combined record from the records.UsagePower Query MRecord.Combine({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0[Phone = \"123-4567\"]})Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]",
                    "pages": []
                },
                {
                    "title": "Record.Field",
                    "Syntax": "Record.Field(record as record, field as text) as any",
                    "About": "Returns the value of the given field. This function can be used to dynamically create field lookup syntax for a given record. In that way it is a dynamic version of the record[field] syntax.",
                    "Explain": "Find the value of field \"CustomerID\" in the record.UsagePower Query MRecord.Field([CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"], \"CustomerID\")Output1",
                    "pages": []
                },
                {
                    "title": "Record.FieldCount",
                    "Syntax": "Record.FieldCount(record as record) as number",
                    "About": "Returns the number of fields in the record record.",
                    "Explain": "Find the number of fields in the record.UsagePower Query MRecord.FieldCount([CustomerID = 1, Name = \"Bob\"])Output2",
                    "pages": []
                },
                {
                    "title": "Record.FieldNames",
                    "Syntax": "Record.FieldNames(record as record) as list",
                    "About": "Returns the names of the fields in the record record as text.",
                    "Explain": "Find the names of the fields in the record.UsagePower Query MRecord.FieldNames([OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0])Output{\"OrderID\", \"CustomerID\", \"Item\", \"Price\"}",
                    "pages": []
                },
                {
                    "title": "Record.FieldOrDefault",
                    "Syntax": "Record.FieldOrDefault(record as nullable record, field as text, optional defaultValue as any) as any",
                    "About": "Returns the value of the specified field field in the record record. If the field is not found, the optional defaultValue is returned.",
                    "Explain": "Example 1Find the value of field \"Phone\" in the record, or return null if it doesn't exist.UsagePower Query MRecord.FieldOrDefault([CustomerID = 1, Name = \"Bob\"], \"Phone\")OutputnullExample 2Find the value of field \"Phone\" in the record, or return the default if it doesn't exist.UsagePower Query MRecord.FieldOrDefault([CustomerID = 1, Name = \"Bob\"], \"Phone\", \"123-4567\")Output\"123-4567\"",
                    "pages": []
                },
                {
                    "title": "Record.FieldValues",
                    "Syntax": "Record.FieldValues(record as record) as list",
                    "About": "Returns a list of the field values in record record.",
                    "Explain": "Find the field values in the record.UsagePower Query MRecord.FieldValues([CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"])Output{1, \"Bob\", \"123-4567\"}",
                    "pages": []
                },
                {
                    "title": "Record.FromList",
                    "Syntax": "Record.FromList(list as list, fields as any) as record",
                    "About": "Returns a record given a list of field values and a set of fields. The fields can be specified either by a list of text values, or a record type. An error is thrown if the fields are not unique.",
                    "Explain": "Example 1Build a record from a list of field values and a list of field names.UsagePower Query MRecord.FromList({1, \"Bob\", \"123-4567\"}, {\"CustomerID\", \"Name\", \"Phone\"})Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]Example 2Build a record from a list of field values and a record type.UsagePower Query MRecord.FromList({1, \"Bob\", \"123-4567\"}, type [CustomerID = number, Name = text, Phone = number])Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]",
                    "pages": []
                },
                {
                    "title": "Record.FromTable",
                    "Syntax": "Record.FromTable(table as table) as record",
                    "About": "Returns a record from a table of records table containing field names and value names {[Name = name, Value = value]}. An exception is thrown if the field names are not unique.",
                    "Explain": "Create a record from the table of the form Table.FromRecords({[Name = \"CustomerID\", Value = 1], [Name = \"Name\", Value = \"Bob\"], [Name = \"Phone\", Value = \"123-4567\"]}).UsagePower Query MRecord.FromTable(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"CustomerID\", Value = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Name\", Value = \"Bob\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Phone\", Value = \"123-4567\"]\u00a0\u00a0\u00a0\u00a0}))Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]",
                    "pages": []
                },
                {
                    "title": "Record.HasFields",
                    "Syntax": "Record.HasFields(record as record, fields as any) as logical",
                    "About": "Indicates whether the record record has the fields specified in fields, by returning a logical value (true or false). Multiple field values can be specified using a list.",
                    "Explain": "Example 1Check if the record has the field \"CustomerID\".UsagePower Query MRecord.HasFields([CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"], \"CustomerID\")OutputtrueExample 2Check if the record has the field \"CustomerID\" and \"Address\".UsagePower Query MRecord.HasFields([CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"], {\"CustomerID\", \"Address\"})Outputfalse",
                    "pages": []
                },
                {
                    "title": "Record.RemoveFields",
                    "Syntax": "Record.RemoveFields(record as record, fields as any, optional missingField as nullable number) as record",
                    "About": "Returns a record that removes all the fields specified in list fields from the input record. If the field specified does not exist, an exception is thrown.",
                    "Explain": "Example 1Remove the field \"Price\" from the record.UsagePower Query MRecord.RemoveFields([CustomerID = 1, Item = \"Fishing rod\", Price = 18.00], \"Price\")Output[CustomerID = 1, Item = \"Fishing rod\"]Example 2Remove the fields \"Price\" and \"Item\" from the record.UsagePower Query MRecord.RemoveFields([CustomerID = 1, Item = \"Fishing rod\", Price = 18.00], {\"Price\", \"Item\"})Output[CustomerID = 1]",
                    "pages": []
                },
                {
                    "title": "Record.RenameFields",
                    "Syntax": "Record.RenameFields(record as record, renames as list, optional missingField as nullable number) as record",
                    "About": "Returns a new record that renames the fields specified. The resultant fields will retain their original order. This function supports swapping and chaining field names. However, all target names plus remaining field names must constitute a unique set or an error will occur.",
                    "Explain": "Example 1Rename the field \"UnitPrice\" to \"Price\" from the record.UsagePower Query MRecord.RenameFields(\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", UnitPrice = 100.0],\u00a0\u00a0\u00a0\u00a0{\"UnitPrice\", \"Price\"})Output[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0]Example 2Rename the fields \"UnitPrice\" to \"Price\" and \"OrderNum\" to \"OrderID\" from the record.UsagePower Query MRecord.RenameFields(\u00a0\u00a0\u00a0\u00a0[OrderNum = 1, CustomerID = 1, Item = \"Fishing rod\", UnitPrice = 100.0],\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"UnitPrice\", \"Price\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"OrderNum\", \"OrderID\"}\u00a0\u00a0\u00a0\u00a0})Output[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0]",
                    "pages": []
                },
                {
                    "title": "Record.ReorderFields",
                    "Syntax": "Record.ReorderFields(record as record, fieldOrder as list, optional missingField as nullable number) as record",
                    "About": "Returns a record after reordering the fields in record in the order of fields specified in list fieldOrder. Field values are maintained and fields not listed in fieldOrder are left in their original position.",
                    "Explain": "Reorder some of the fields in the record.UsagePower Query MRecord.ReorderFields(\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, OrderID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0{\"OrderID\", \"CustomerID\"})Output[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0]",
                    "pages": []
                },
                {
                    "title": "Record.SelectFields",
                    "Syntax": "Record.SelectFields(record as record, fields as any, optional missingField as nullable number) as record",
                    "About": "Returns a new record that contains the fields selected from the input record. The original order of the fields is maintained.",
                    "Explain": "Select the fields \"Item\" and \"Price\" in the record.UsagePower Query MRecord.SelectFields(\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0{\"Item\", \"Price\"})Output[Item = \"Fishing rod\", Price = 100]",
                    "pages": []
                },
                {
                    "title": "Record.ToList",
                    "Syntax": "Record.ToList(record as record) as list",
                    "About": "Returns a list of values containing the field values from the input record.",
                    "Explain": "Extract the field values from a record.UsagePower Query MRecord.ToList([A = 1, B = 2, C = 3])Output{1, 2, 3}",
                    "pages": []
                },
                {
                    "title": "Record.ToTable",
                    "Syntax": "Record.ToTable(record as record) as table",
                    "About": "Returns a table containing the columns Name and Value with a row for each field in record.",
                    "Explain": "Return the table from the record.UsagePower Query MRecord.ToTable([OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0])OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Name = \"OrderID\", Value = 1],\u00a0\u00a0\u00a0\u00a0[Name = \"CustomerID\", Value = 1],\u00a0\u00a0\u00a0\u00a0[Name = \"Item\", Value = \"Fishing rod\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Price\", Value = 100]})",
                    "pages": []
                },
                {
                    "title": "Record.TransformFields",
                    "Syntax": "Record.TransformFields(record as record, transformOperations as list, optional missingField as nullable number) as record",
                    "About": "Returns a record after applying transformations specified in list transformOperations to record. One or more fields may be transformed at a given time.In the case of a single field being transformed, transformOperations is expected to be a list with two items. The first item in transformOperations specifies a field name, and the second item in transformOperations specifies the function to be used for transformation. For example, {\"Quantity\", Number.FromText}In the case of a multiple fields being transformed, transformOperations is expected to be a list of lists, where each inner list is a pair of field name and transformation operation. For example, {{\"Quantity\",Number.FromText},{\"UnitPrice\", Number.FromText}}",
                    "Explain": "Example 1Convert \"Price\" field to number.UsagePower Query MRecord.TransformFields(\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = \"100.0\"],\u00a0\u00a0\u00a0\u00a0{\"Price\", Number.FromText})Output[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100]Example 2Convert \"OrderID\" and \"Price\" fields to numbers.UsagePower Query MRecord.TransformFields(\u00a0\u00a0\u00a0\u00a0[OrderID = \"1\", CustomerID = 1, Item = \"Fishing rod\", Price = \"100.0\"],\u00a0\u00a0\u00a0\u00a0{{\"OrderID\", Number.FromText}, {\"Price\", Number.FromText}})Output[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100]",
                    "pages": []
                }
            ]
        },
        {
            "title": "Replacer functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Replacer.ReplaceText",
                    "Syntax": "Replacer.ReplaceText(text as nullable text, old as text, new as text) as nullable text",
                    "About": "Replaces the old text in the original text with the new text. This replacer function can be used in List.ReplaceValue and Table.ReplaceValue.",
                    "Explain": "Replace the text \"hE\" with \"He\" in the string \"hEllo world\".UsagePower Query MReplacer.ReplaceText(\"hEllo world\", \"hE\", \"He\")Output\"Hello world\"",
                    "pages": []
                },
                {
                    "title": "Replacer.ReplaceValue",
                    "Syntax": "Replacer.ReplaceValue(value as any, old as any, new as any) as any",
                    "About": "Replaces the old value in the original value with the new value. This replacer function can be used in List.ReplaceValue and Table.ReplaceValue.",
                    "Explain": "Replace the value 11 with the value 10.UsagePower Query MReplacer.ReplaceValue(11, 11, 10)Output10",
                    "pages": []
                }
            ]
        },
        {
            "title": "Splitter functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Splitter.SplitByNothing",
                    "Syntax": "Splitter.SplitByNothing() as function",
                    "About": "Returns a function that does no splitting, returning its argument as a single element list.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByAnyDelimiter",
                    "Syntax": "Splitter.SplitTextByAnyDelimiter(delimiters as list, optional quoteStyle as nullable number, optional startAtEnd as nullable logical) as function",
                    "About": "Returns a function that splits text into a list of text at any of the specified delimiters.",
                    "Explain": "Example 1Split the input by comma or semicolon, ignoring quotes and quoted delimiters and starting from the beginning of the input.UsagePower Query MSplitter.SplitTextByAnyDelimiter({\",\", \";\"}, QuoteStyle.Csv)(\"a,b;\"\"c,d;e\"\",f\")Output{\"a\", \"b\", \"c,d;e\", \"f\"}Example 2Split the input by comma or semicolon, ignoring quotes and quoted delimiters and starting from the end of the input.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0startAtEnd = truein\u00a0\u00a0\u00a0\u00a0Splitter.SplitTextByAnyDelimiter({\",\", \";\"}, QuoteStyle.Csv, startAtEnd)(\"a,\"\"b;c,d\")Output{\"a,b\", \"c\", \"d\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByCharacterTransition",
                    "Syntax": "Splitter.SplitTextByCharacterTransition(before as anynonnull, after as anynonnull) as function",
                    "About": "Returns a function that splits text into a list of text according to a transition from one kind of character to another. The before and after parameters can either be a list of characters, or a function that takes a character and returns true/false.",
                    "Explain": "Split the input whenever an upper or lowercase letter is followed by a digit.UsagePower Query MSplitter.SplitTextByCharacterTransition({\"A\"..\"Z\", \"a\"..\"z\"}, {\"0\"..\"9\"})(\"Abc123\")Output{\"Abc\", \"123\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByDelimiter",
                    "Syntax": "Splitter.SplitTextByDelimiter(delimiter as text, optional quoteStyle as nullable number) as function",
                    "About": "Returns a function that splits text into a list of text according to the specified delimiter.",
                    "Explain": "Split the input by comma, ignoring quoted commas.UsagePower Query MSplitter.SplitTextByDelimiter(\",\", QuoteStyle.Csv)(\"a,\"\"b,c\"\",d\")Output{\"a\", \"b,c\", \"d\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByEachDelimiter",
                    "Syntax": "Splitter.SplitTextByEachDelimiter(delimiters as list, optional quoteStyle as nullable number, optional startAtEnd as nullable logical) as function",
                    "About": "Returns a function that splits text into a list of text at each specified delimiter in sequence.",
                    "Explain": "Example 1Split the input by comma, then semicolon, starting from the beginning of the input.UsagePower Query MSplitter.SplitTextByEachDelimiter({\",\", \";\"})(\"a,b;c,d\")Output{\"a\", \"b\", \"c,d\"}Example 2Split the input by comma, then semicolon, treating quotes like any other character and starting from the end of the input.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0startAtEnd = truein\u00a0\u00a0\u00a0\u00a0Splitter.SplitTextByEachDelimiter({\",\", \";\"}, QuoteStyle.None, startAtEnd)(\"a,\"\"b;c\"\",d\")Output{\"a,\"\"b\", \"c\"\"\", \"d\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByLengths",
                    "Syntax": "Splitter.SplitTextByLengths(lengths as list, optional startAtEnd as nullable logical) as function",
                    "About": "Returns a function that splits text into a list of text by each specified length.",
                    "Explain": "Example 1Split the input into the first two characters followed by the next three, starting from the beginning of the input.UsagePower Query MSplitter.SplitTextByLengths({2, 3})(\"AB123\")Output{\"AB\", \"123\"}Example 2Split the input into the first three characters followed by the next two, starting from the end of the input.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0startAtEnd = truein\u00a0\u00a0\u00a0\u00a0Splitter.SplitTextByLengths({5, 2}, startAtEnd)(\"RedmondWA98052\")Output{\"WA\", \"98052\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByPositions",
                    "Syntax": "Splitter.SplitTextByPositions(positions as list, optional startAtEnd as nullable logical) as function",
                    "About": "Returns a function that splits text into a list of text at each specified position.",
                    "Explain": "Example 1Split the input at the specified positions, starting from the beginning of the input.UsagePower Query MSplitter.SplitTextByPositions({0, 3, 4})(\"ABC|12345\")Output{\"ABC\", \"|\", \"12345\"}Example 2Split the input at the specified positions, starting from the end of the input.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0startAtEnd = truein\u00a0\u00a0\u00a0\u00a0Splitter.SplitTextByPositions({0, 5}, startAtEnd)(\"Redmond98052\")Output{\"Redmond\", \"98052\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByRanges",
                    "Syntax": "Splitter.SplitTextByRanges(ranges as list, optional startAtEnd as nullable logical) as function",
                    "About": "Returns a function that splits text into a list of text according to the specified offsets and lengths. A null length indicates that all remaining input should be included.",
                    "Explain": "Example 1Split the input by the specified position and length pairs, starting from the beginning of the input. Note that the ranges in this example overlap.UsagePower Query MSplitter.SplitTextByRanges({{0, 4}, {2, 10}})(\"codelimiter\")Output{\"code\", \"delimiter\"}Example 2Split the input by the specified position and length pairs, starting from the end of the input.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0startAtEnd = truein\u00a0\u00a0\u00a0\u00a0Splitter.SplitTextByRanges({{0, 5}, {6, 2}}, startAtEnd)(\"RedmondWA?98052\")Output{\"WA\", \"98052\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByRepeatedLengths",
                    "Syntax": "Splitter.SplitTextByRepeatedLengths(length as number, optional startAtEnd as nullable logical) as function",
                    "About": "Returns a function that splits text into a list of text after the specified length repeatedly.",
                    "Explain": "Example 1Repeatedly split the input into chunks of three characters, starting from the beginning of the input.UsagePower Query MSplitter.SplitTextByRepeatedLengths(3)(\"12345678\")Output{\"123\", \"456\", \"78\"}Example 2Repeatedly split the input into chunks of three characters, starting from the end of the input.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0startAtEnd = truein\u00a0\u00a0\u00a0\u00a0Splitter.SplitTextByRepeatedLengths(3, startAtEnd)(\"87654321\")Output{\"87\", \"654\", \"321\"}",
                    "pages": []
                },
                {
                    "title": "Splitter.SplitTextByWhitespace",
                    "Syntax": "Splitter.SplitTextByWhitespace(optional quoteStyle as nullable number) as function",
                    "About": "Returns a function that splits text into a list of text at whitespace.",
                    "Explain": "Split the input by whitespace characters, treating quotes like any other character.UsagePower Query MSplitter.SplitTextByWhitespace(QuoteStyle.None)(\"a b#(tab)c\")Output{\"a\", \"b\", \"c\"}",
                    "pages": []
                }
            ]
        },
        {
            "title": "Table functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "ItemExpression.From",
                    "Syntax": "ItemExpression.From(function as function) as record",
                    "About": "Returns the abstract syntax tree (AST) for the body of function, normalized into an item expression:The function must be a 1-argument lambda.All references to the function parameter are replaced with ItemExpression.Item.The AST will be simplified to contain only nodes of the kinds:ConstantInvocationUnaryBinaryIfFieldAccessAn error is raised if an item expression AST cannot be returned for the body of function.This function is identical to RowExpression.From.",
                    "Explain": "Returns the AST for the body of the function each _ <> null.UsagePower Query MItemExpression.From(each _ <> null)Output[\u00a0\u00a0\u00a0\u00a0Kind = \"Binary\",\u00a0\u00a0\u00a0\u00a0Operator = \"NotEquals\",\u00a0\u00a0\u00a0\u00a0Left = ItemExpression.Item,\u00a0\u00a0\u00a0\u00a0Right =\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Kind = \"Constant\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Value = null\u00a0\u00a0\u00a0\u00a0]]",
                    "pages": []
                },
                {
                    "title": "ItemExpression.Item",
                    "Syntax": "An abstract syntax tree (AST) node representing the item in an item expression.This value is identical to RowExpression.Row.",
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "RowExpression.Column",
                    "Syntax": "RowExpression.Column(columnName as text) as record",
                    "About": "Returns an abstract syntax tree (AST) that represents access to column columnName of the row within a row expression.",
                    "Explain": "Creates an AST representing access of column \"CustomerName\".UsagePower Query MRowExpression.Column(\"CustomerName\")\u00a0\u00a0Output[\u00a0\u00a0\u00a0\u00a0Kind = \"FieldAccess\",\u00a0\u00a0\u00a0\u00a0Expression = RowExpression.Row,\u00a0\u00a0\u00a0\u00a0MemberName = \"CustomerName\"]",
                    "pages": []
                },
                {
                    "title": "RowExpression.From",
                    "Syntax": "RowExpression.From(function as function) as record",
                    "About": "Returns the abstract syntax tree (AST) for the body of function, normalized into a row expression:The function must be a 1-argument lambda.All references to the function parameter are replaced with RowExpression.Row.All references to columns are replaced with RowExpression.Column(columnName).The AST will be simplified to contain only nodes of the kinds:ConstantInvocationUnaryBinaryIfFieldAccessAn error is raised if a row expression AST cannot be returned for the body of function.This function is identical to ItemExpression.From.",
                    "Explain": "Returns the AST for the body of the function each [CustomerID] = \"ALFKI\".UsagePower Query MRowExpression.From(each [CustomerName] = \"ALFKI\")\u00a0\u00a0Output[\u00a0\u00a0\u00a0\u00a0Kind = \"Binary\",\u00a0\u00a0\u00a0\u00a0Operator = \"Equals\",\u00a0\u00a0\u00a0\u00a0Left = RowExpression.Column(\"CustomerName\"),\u00a0\u00a0\u00a0\u00a0Right =\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Kind = \"Constant\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Value = \"ALFKI\"\u00a0\u00a0\u00a0\u00a0]]",
                    "pages": []
                },
                {
                    "title": "RowExpression.Row",
                    "Syntax": "An abstract syntax tree (AST) node representing the row in a row expression.This value is identical to ItemExpression.Item.",
                    "About": null,
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.AddColumn",
                    "Syntax": "Table.AddColumn(table as table, newColumnName as text, columnGenerator as function, optional columnType as nullable type) as table",
                    "About": "Adds a column named newColumnName to the table table. The values for the column are computed using the specified selection function columnGenerator with each row taken as an input.",
                    "Explain": "Add a number column named \"TotalPrice\" to the table, with each value being the sum of the [Price] and [Shipping] columns.UsagePower Query MTable.AddColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0, Shipping = 10.00],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5.0, Shipping = 15.00],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25.0, Shipping = 10.00]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"TotalPrice\",\u00a0\u00a0\u00a0\u00a0each [Price] + [Shipping],\u00a0\u00a0\u00a0\u00a0type number)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100, Shipping = 10, TotalPrice = 110],\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5, Shipping = 15, TotalPrice = 20],\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25, Shipping = 10, TotalPrice = 35]})",
                    "pages": []
                },
                {
                    "title": "Table.AddFuzzyClusterColumn",
                    "Syntax": "Table.AddFuzzyClusterColumn(table as table, columnName as text, newColumnName as text, optional options as nullable record) as table",
                    "About": "Adds a new column newColumnName to table with representative values of columnName. The representatives are obtained by fuzzily matching values in columnName, for each row.An optional set of options may be included to specify how to compare the key columns. Options include:Culture: Allows grouping records based on culture-specific rules. It can be any valid culture name. For example, a Culture option of \"ja-JP\" groups records based on the Japanese culture. The default value is \"\", which groups based on the Invariant English culture.IgnoreCase: A logical (true/false) value that allows case-insensitive key grouping. For example, when true, \"Grapes\" is grouped with \"grapes\". The default value is true.IgnoreSpace: A logical (true/false) value that allows combining of text parts in order to find groups. For example, when true, \"Gra pes\" is grouped with \"Grapes\". The default value is true.SimilarityColumnName: A name for the column that shows the similarity between an input value and the representative value for that input. The default value is null, in which case a new column for similarities will not be added.Threshold: A number between 0.00 and 1.00 that specifies the similarity score at which two values will be grouped. For example, \"Grapes\" and \"Graes\" (missing the \"p\") are grouped together only if this option is set to less than 0.90. A threshold of 1.00 only allows exact matches. (Note that a fuzzy \"exact match\" might ignore differences like casing, word order, and punctuation.) The default value is 0.80.TransformationTable: A table that allows grouping records based on custom value mappings. It should contain \"From\" and \"To\" columns. For example, \"Grapes\" is grouped with \"Raisins\" if a transformation table is provided with the \"From\" column containing \"Grapes\" and the \"To\" column containing \"Raisins\". Note that the transformation will be applied to all occurrences of the text in the transformation table. With the above transformation table, \"Grapes are sweet\" will also be grouped with \"Raisins are sweet\".",
                    "Explain": "Find the representative values for the location of the employees.UsagePower Query MTable.AddFuzzyClusterColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 1, Location = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 2, Location = \"seattl\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 3, Location = \"Vancouver\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 4, Location = \"Seatle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 5, Location = \"vancover\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 6, Location = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 7, Location = \"Vancouver\"]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [EmployeeID = nullable number, Location = nullable text]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0\"Location\",\u00a0\u00a0\u00a0\u00a0\"Location_Cleaned\",\u00a0\u00a0\u00a0\u00a0[IgnoreCase = true, IgnoreSpace = true])OutputTable.FromRecords(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 1, Location = \"Seattle\", Location_Cleaned = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 2, Location = \"seattl\", Location_Cleaned = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 3, Location = \"Vancouver\", Location_Cleaned = \"Vancouver\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 4, Location = \"Seatle\", Location_Cleaned = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 5, Location = \"vancover\", Location_Cleaned = \"Vancouver\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 6, Location = \"Seattle\", Location_Cleaned = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 7, Location = \"Vancouver\", Location_Cleaned = \"Vancouver\"]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0type table [EmployeeID = nullable number, Location = nullable text, Location_Cleaned = nullable text])",
                    "pages": []
                },
                {
                    "title": "Table.AddIndexColumn",
                    "Syntax": "Table.AddIndexColumn(table as table, newColumnName as text, optional initialValue as nullable number, optional increment as nullable number, optional columnType as nullable type) as table",
                    "About": "Appends a column named newColumnName to the table with explicit position values. An optional value, initialValue, the initial index value. An optional value, increment, specifies how much to increment each index value.",
                    "Explain": "Example 1Add an index column named \"Index\" to the table.UsagePower Query MTable.AddIndexColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Index\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\", Index = 0],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\", Index = 1],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\", Index = 2],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\", Index = 3]})Example 2Add an index column named \"index\", starting at value 10 and incrementing by 5, to the table.UsagePower Query MTable.AddIndexColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Index\",\u00a0\u00a0\u00a0\u00a010,\u00a0\u00a0\u00a0\u00a05)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\", Index = 10],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\", Index = 15],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\", Index = 20],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\", Index = 25]})",
                    "pages": []
                },
                {
                    "title": "Table.AddJoinColumn",
                    "Syntax": "Table.AddJoinColumn(table1 as table, key1 as any, table2 as function, key2 as any, newColumnName as text) as table",
                    "About": "Joins the rows of table1 with the rows of table2 based on the equality of the values of the key columns selected by key1 (for table1) and key2 (for table2). The results are entered into the column named newColumnName. This function behaves similarly to Table.Join with a JoinKind of LeftOuter except that the join results are presented in a nested rather than flattened fashion.",
                    "Explain": "Add a join column to ({[saleID = 1, item = \"Shirt\"], [saleID = 2, item = \"Hat\"]}) named \"price/stock\" from the table ({[saleID = 1, price = 20], [saleID = 2, price = 10]}) joined on [saleID].UsagePower Query MTable.AddJoinColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[saleID = 1, item = \"Shirt\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[saleID = 2, item = \"Hat\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"saleID\",\u00a0\u00a0\u00a0\u00a0() => Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[saleID = 1, price = 20, stock = 1234],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[saleID = 2, price = 10, stock = 5643]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"saleID\",\u00a0\u00a0\u00a0\u00a0\"price\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0saleID = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0item = \"Shirt\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0price = Table.FromRecords({[saleID = 1, price = 20, stock = 1234]})\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0saleID = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0item = \"Hat\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0price = Table.FromRecords({[saleID = 2, price = 10, stock = 5643]})\u00a0\u00a0\u00a0\u00a0]})",
                    "pages": []
                },
                {
                    "title": "Table.AddKey",
                    "Syntax": "Table.AddKey(table as table, columns as list, isPrimary as logical) as table",
                    "About": "Adds a key to table, where columns is the list of column names that define the key, and isPrimary specifies whether the key is primary.",
                    "Explain": "Add a single-column primary key to a table.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0table = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Id = 1, Name = \"Hello There\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Id = 2, Name = \"Good Bye\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0resultTable = Table.AddKey(table, {\"Id\"}, true)in\u00a0\u00a0\u00a0\u00a0resultTableOutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Id = 1, Name = \"Hello There\"],\u00a0\u00a0\u00a0\u00a0[Id = 2, Name = \"Good Bye\"]})",
                    "pages": []
                },
                {
                    "title": "Table.AddRankColumn",
                    "Syntax": "Table.AddRankColumn(table as table, newColumnName as text, comparisonCriteria as any, optional options as nullable record) as table",
                    "About": "Appends a column named newColumnName to the table with the ranking of one or more other columns described by comparisonCriteria. The RankKind option in options can be used by advanced users to pick a more-specific ranking method.",
                    "Explain": "Add a column named RevenueRank to the table which ranks the Revenue column from highest to lowest.UsagePower Query MTable.AddRankColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Revenue = 200],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Revenue = 100],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Revenue = 200],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Revenue = 50]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"RevenueRank\",\u00a0\u00a0\u00a0\u00a0{\"Revenue\", Order.Descending},\u00a0\u00a0\u00a0\u00a0[RankKind = RankKind.Competition])OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Revenue = 200, RevenueRank = 1],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Revenue = 200, RevenueRank = 1],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Revenue = 100, RevenueRank = 3],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Revenue = 50, RevenueRank = 4]})",
                    "pages": []
                },
                {
                    "title": "Table.AggregateTableColumn",
                    "Syntax": "Table.AggregateTableColumn(table as table, column as text, aggregations as list) as table",
                    "About": "Aggregates tables in table[column] into multiple columns containing aggregate values for the tables. aggregations is used to specify the columns containing the tables to aggregate, the aggregation functions to apply to the tables to generate their values, and the names of the aggregate columns to create.",
                    "Explain": "Aggregate table columns in [t] in the table {[t = {[a=1, b=2, c=3], [a=2,b=4,c=6]}, b = 2]} into the sum of [t.a], the min and max of [t.b], and the count of values in [t.a].UsagePower Query MTable.AggregateTableColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2, c = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4, c = 6]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b = 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [t = table [a = number, b = number, c = number], b = number]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0\"t\",\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"a\", List.Sum, \"sum of t.a\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"b\", List.Min, \"min of t.b\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"b\", List.Max, \"max of t.b\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"a\", List.Count, \"count of t.a\"}\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({[#\"sum of t.a\" = 3, #\"min of t.b\" = 2, #\"max of t.b\" = 4, #\"count of t.a\" = 2, b = 2]})",
                    "pages": []
                },
                {
                    "title": "Table.AlternateRows",
                    "Syntax": "Table.AlternateRows(table as table, offset as number, skip as number, take as number) as table",
                    "About": "Keeps the initial offset then alternates taking and skipping the following rows.table: The input table.offset: The number of rows to keep before starting iterations.skip: The number of rows to remove in each iteration.take: The number of rows to keep in each iteration.",
                    "Explain": "Return a table from the table that, starting at the first row, skips 1 value and then keeps 1 value.UsagePower Query MTable.AlternateRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})",
                    "pages": []
                },
                {
                    "title": "Table.ApproximateRowCount",
                    "Syntax": "Table.ApproximateRowCount(table as table) as number",
                    "About": "Returns the approximate number of rows in the table, or an error if the data source doesn't support approximation.",
                    "Explain": "Estimate the number of distinct combinations of city and state in a large table, which can be used as a cardinality estimate for the columns. Cardinality estimates are important enough that various data sources (such as SQL Server) support this particular approximation, often using an algorithm called HyperLogLog.UsagePower Query MTable.ApproximateRowCount(Table.Distinct(Table.SelectColumns(sqlTable, {\"city\", \"state\"})))Outputnumber",
                    "pages": []
                },
                {
                    "title": "Table.Buffer",
                    "Syntax": "Table.Buffer(table as table, optional options as nullable record) as table",
                    "About": "Buffers a table in memory, isolating it from external changes during evaluation. Buffering is shallow. It forces the evaluation of any scalar cell values, but leaves non-scalar values (records, lists, tables, and so on) as-is.Note that using this function might or might not make your queries run faster. In some cases, it can make your queries run more slowly due to the added cost of reading all the data and storing it in memory, as well as the fact that buffering prevents downstream folding. If the data doesn't need to be buffered but you just want to prevent downstream folding, use Table.StopFolding instead.",
                    "Explain": "Load all the rows of a SQL table into memory, so that any downstream operations will no longer be able to query the SQL server.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0Source = Sql.Database(\"SomeSQLServer\", \"MyDb\"),\u00a0\u00a0\u00a0\u00a0MyTable = Source{[Item=\"MyTable\"]}[Data],\u00a0\u00a0\u00a0\u00a0BufferMyTable = Table.Buffer(dbo_MyTable)in\u00a0\u00a0\u00a0\u00a0BufferMyTableOutputtable",
                    "pages": []
                },
                {
                    "title": "Table.Column",
                    "Syntax": "Table.Column(table as table, column as text) as list",
                    "About": "Returns the column of data specified by column from the table table as a list.",
                    "Explain": "Returns the values from the [Name] column in the table.UsagePower Query MTable.Column(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Name\")Output{\"Bob\", \"Jim\", \"Paul\", \"Ringo\"}",
                    "pages": []
                },
                {
                    "title": "Table.ColumnCount",
                    "Syntax": "Table.ColumnCount(table as table) as number",
                    "About": "Returns the number of columns in the table table.",
                    "Explain": "Find the number of columns in the table.UsagePower Query MTable.ColumnCount(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}))Output3",
                    "pages": []
                },
                {
                    "title": "Table.ColumnNames",
                    "Syntax": "Table.ColumnNames(table as table) as list",
                    "About": "Returns the column names in the table table as a list of text.",
                    "Explain": "Find the column names of the table.UsagePower Query MTable.ColumnNames(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}))Output{\"CustomerID\", \"Name\", \"Phone\"}",
                    "pages": []
                },
                {
                    "title": "Table.ColumnsOfType",
                    "Syntax": "Table.ColumnsOfType(table as table, listOfTypes as list) as list",
                    "About": "Returns a list with the names of the columns from table table that match the types specified in listOfTypes.",
                    "Explain": "Return the names of columns of type Number.Type from the table.UsagePower Query MTable.ColumnsOfType(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{[a = 1, b = \"hello\"]},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table[a = Number.Type, b = Text.Type]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0{type number})Output{\"a\"}",
                    "pages": []
                },
                {
                    "title": "Table.Combine",
                    "Syntax": "Table.Combine(tables as list, optional columns as any) as table",
                    "About": "Returns a table that is the result of merging a list of tables, tables. The resulting table will have a row type structure defined by columns or by a union of the input types if columns is not specified.",
                    "Explain": "Example 1Merge the three tables together.UsagePower Query MTable.Combine({\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})Example 2Merge three tables with different structures.UsagePower Query MTable.Combine({\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Fax = \"987-6543\", Phone = \"838-7171\"]}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Cell = \"543-7890\"]})})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Phone = \"123-4567\", Fax = null, Cell = null],\u00a0\u00a0\u00a0\u00a0[Name = null, Phone = \"838-7171\", Fax = \"987-6543\", Cell = null],\u00a0\u00a0\u00a0\u00a0[Name = null, Phone = null, Fax = null, Cell = \"543-7890\"]})Example 3Merge two tables and project onto the given type.UsagePower Query MTable.Combine(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Fax = \"987-6543\", Phone = \"838-7171\"]}),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Cell = \"543-7890\"]})\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"Name\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = null, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = null, Name = null],\u00a0\u00a0\u00a0\u00a0[CustomerID = null, Name = null]})",
                    "pages": []
                },
                {
                    "title": "Table.CombineColumns",
                    "Syntax": "Table.CombineColumns(table as table, sourceColumns as list, combiner as function, column as text) as table",
                    "About": "Table.CombineColumns merges columns using a combiner function to produce a new column. Table.CombineColumns is the inverse of Table.SplitColumn.",
                    "Explain": "Combine the last and first names into a new column, separated by a comma.UsagePower Query MTable.CombineColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[FirstName = \"Bob\", LastName = \"Smith\"]}),\u00a0\u00a0\u00a0\u00a0{\"LastName\", \"FirstName\"},\u00a0\u00a0\u00a0\u00a0Combiner.CombineTextByDelimiter(\",\", QuoteStyle.None),\u00a0\u00a0\u00a0\u00a0\"FullName\")OutputTable.FromRecords({[FullName = \"Smith,Bob\"]})",
                    "pages": []
                },
                {
                    "title": "Table.CombineColumnsToRecord",
                    "Syntax": "Table.CombineColumnsToRecord(table as table, newColumnName as text, sourceColumns as list, optional options as nullable record) as table",
                    "About": "Combines the specified columns of table into a new record-valued column named newColumnName where each record has field names and values corresponding to the column names and values of the columns that were combined. If a record is specified for options, the following options may be provided:DisplayNameColumn: When specified as text, indicates that the given column name should be treated as the display name of the record. This need not be one of the columns in the record itself.TypeName: When specified as text, supplies a logical type name for the resulting record which can be used during data load to drive behavior by the loading environment.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.ConformToPageReader",
                    "Syntax": "Table.ConformToPageReader(table as table, shapingFunction as function) as table",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.Contains",
                    "Syntax": "Table.Contains(table as table, row as record, optional equationCriteria as any) as logical",
                    "About": "Indicates whether the specified record, row, appears as a row in the table. An optional parameter equationCriteria may be specified to control comparison between the rows of the table.",
                    "Explain": "Example 1Determine if the table contains the row.UsagePower Query MTable.Contains(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\"])OutputtrueExample 2Determine if the table contains the row.UsagePower Query MTable.Contains(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0[Name = \"Ted\"])OutputfalseExample 3Determine if the table contains the row comparing only the column [Name].UsagePower Query MTable.Contains(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0\"Name\")Outputtrue",
                    "pages": []
                },
                {
                    "title": "Table.ContainsAll",
                    "Syntax": "Table.ContainsAll(table as table, rows as list, optional equationCriteria as any) as logical",
                    "About": "Indicates whether all the specified records in the list of records rows, appear as rows in the table. An optional parameter equationCriteria may be specified to control comparison between the rows of the table.",
                    "Explain": "Example 1Determine if the table contains all the rows, comparing only the column [CustomerID].UsagePower Query MTable.ContainsAll(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bill\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Fred\"]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\"CustomerID\")OutputtrueExample 2Determine if the table contains all the rows.UsagePower Query MTable.ContainsAll(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bill\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Fred\"]\u00a0\u00a0\u00a0\u00a0})Outputfalse",
                    "pages": []
                },
                {
                    "title": "Table.ContainsAny",
                    "Syntax": "Table.ContainsAny(table as table, rows as list, optional equationCriteria as any) as logical",
                    "About": "Indicates whether any the specified records in the list of records rows, appear as rows in the table. An optional parameter equationCriteria may be specified to control comparison between the rows of the table.",
                    "Explain": "Example 1Determine if the table ({[a = 1, b = 2], [a = 3, b = 4]}) contains the rows [a = 1, b = 2] or [a = 3, b = 5].UsagePower Query MTable.ContainsAny(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 5]\u00a0\u00a0\u00a0\u00a0})OutputtrueExample 2Determine if the table ({[a = 1, b = 2], [a = 3, b = 4]}) contains the rows [a = 1, b = 3] or [a = 3, b = 5].UsagePower Query MTable.ContainsAny(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 5]\u00a0\u00a0\u00a0\u00a0})OutputfalseExample 3Determine if the table (Table.FromRecords({[a = 1, b = 2], [a = 3, b = 4]})) contains the rows [a = 1, b = 3] or [a = 3, b = 5] comparing only the column [a].UsagePower Query MTable.ContainsAny(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 5]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\"a\")Outputtrue",
                    "pages": []
                },
                {
                    "title": "Table.DemoteHeaders",
                    "Syntax": "Table.DemoteHeaders(table as table) as table",
                    "About": "Demotes the column headers (i.e. column names) to the first row of values. The default column names are \"Column1\", \"Column2\" and so on.",
                    "Explain": "Demote the first row of values in the table.UsagePower Query MTable.DemoteHeaders(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]\u00a0\u00a0\u00a0\u00a0}))OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = \"CustomerID\", Column2 = \"Name\", Column3 = \"Phone\"],\u00a0\u00a0\u00a0\u00a0[Column1 = 1, Column2 = \"Bob\", Column3 = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[Column1 = 2, Column2 = \"Jim\", Column3 = \"987-6543\"]})",
                    "pages": []
                },
                {
                    "title": "Table.Distinct",
                    "Syntax": "Table.Distinct(table as table, optional equationCriteria as any) as table",
                    "About": "Removes duplicate rows from the table. An optional parameter, equationCriteria, specifies which columns of the table are tested for duplication. If equationCriteria is not specified, all columns are tested.Because Power Query sometimes offloads certain operations to backend data sources (known as folding), and also sometimes optimizes queries by skipping operations that aren't strictly necessary, in general there's no guarantee which specific duplicate will be preserved. For example, you can't assume that the first row with a unique set of column values will remain, and rows further down in the table will be removed. If you want the duplicate removal to behave predictably, first buffer the table using Table.Buffer.",
                    "Explain": "Example 1Remove the duplicate rows from the table.UsagePower Query MTable.Distinct(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"a\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = \"B\", b = \"b\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"a\"]\u00a0\u00a0\u00a0\u00a0}))OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"a\"],\u00a0\u00a0\u00a0\u00a0[a = \"B\", b = \"b\"]})Example 2Remove the duplicate rows from column [b] in the table ({[a = \"A\", b = \"a\"], [a = \"B\", b = \"a\"], [a = \"A\", b = \"b\"]}).UsagePower Query MTable.Distinct(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"a\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = \"B\", b = \"a\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"b\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"b\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"a\"],\u00a0\u00a0\u00a0\u00a0[a = \"A\", b = \"b\"]})",
                    "pages": []
                },
                {
                    "title": "Table.DuplicateColumn",
                    "Syntax": "Table.DuplicateColumn(table as table, columnName as text, newColumnName as text, optional columnType as nullable type) as table",
                    "About": "Duplicate the column named columnName to the table table. The values and type for the column newColumnName are copied from column columnName.",
                    "Explain": "Duplicate the column \"a\" to a column named \"copied column\" in the table ({[a = 1, b = 2], [a = 3, b = 4]}).UsagePower Query MTable.DuplicateColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a0\"copied column\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2, #\"copied column\" = 1],\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4, #\"copied column\" = 3]})",
                    "pages": []
                },
                {
                    "title": "Table.ExpandListColumn",
                    "Syntax": "Table.ExpandListColumn(table as table, column as text) as table",
                    "About": "Given a table, where a column is a list of values, splits the list into a row for each value. Values in the other columns are duplicated in each new row created.",
                    "Explain": "Split the list column [Name] in the table.UsagePower Query MTable.ExpandListColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[Name = {\"Bob\", \"Jim\", \"Paul\"}, Discount = .15]}),\u00a0\u00a0\u00a0\u00a0\"Name\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Discount = 0.15],\u00a0\u00a0\u00a0\u00a0[Name = \"Jim\", Discount = 0.15],\u00a0\u00a0\u00a0\u00a0[Name = \"Paul\", Discount = 0.15]})",
                    "pages": []
                },
                {
                    "title": "Table.ExpandRecordColumn",
                    "Syntax": "Table.ExpandRecordColumn(table as table, column as text, fieldNames as list, optional newColumnNames as nullable list) as table",
                    "About": "Given the column of records in the input table, creates a table with a column for each field in the record. Optionally, newColumnNames may be specified to ensure unique names for the columns in the new table.table: The original table with the record column to expand.column: The column to expand.fieldNames: The list of fields to expand into columns in the table.newColumnNames: The list of column names to give the new columns. The new column names cannot duplicate any column in the new table.",
                    "Explain": "Expand column [a] in the table ({[a = [aa = 1, bb = 2, cc = 3], b = 2]}) into 3 columns \"aa\", \"bb\" and \"cc\".UsagePower Query MTable.ExpandRecordColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a = [aa = 1, bb = 2, cc = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b = 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a0{\"aa\", \"bb\", \"cc\"})OutputTable.FromRecords({[aa = 1, bb = 2, cc = 3, b = 2]})",
                    "pages": []
                },
                {
                    "title": "Table.ExpandTableColumn",
                    "Syntax": "Table.ExpandTableColumn(table as table, column as text, columnNames as list, optional newColumnNames as nullable list) as table",
                    "About": "Expands tables in table[column] into multiple rows and columns. columnNames is used to select the columns to expand from the inner table. Specify newColumnNames to avoid conflicts between existing columns and new columns.",
                    "Explain": "Expand table columns in [a] in the table ({[t = {[a=1, b=2, c=3], [a=2,b=4,c=6]}, b = 2]}) into 3 columns [t.a], [t.b] and [t.c].UsagePower Query MTable.ExpandTableColumn(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2, c = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4, c = 6]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b = 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"t\",\u00a0\u00a0\u00a0\u00a0{\"a\", \"b\", \"c\"},\u00a0\u00a0\u00a0\u00a0{\"t.a\", \"t.b\", \"t.c\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[t.a = 1, t.b = 2, t.c = 3, b = 2],\u00a0\u00a0\u00a0\u00a0[t.a = 2, t.b = 4, t.c = 6, b = 2]})",
                    "pages": []
                },
                {
                    "title": "Table.FillDown",
                    "Syntax": "Table.FillDown(table as table, columns as list) as table",
                    "About": "Returns a table from the table specified where the value of a previous cell is propagated to the null-valued cells below in the columns specified.",
                    "Explain": "Return a table with the null values in column [Place] filled with the value above them from the table.UsagePower Query MTable.FillDown(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Place = 1, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Place = null, Name = \"John\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Place = 2, Name = \"Brad\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Place = 3, Name = \"Mark\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Place = null, Name = \"Tom\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Place = null, Name = \"Adam\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"Place\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Place = 1, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0[Place = 1, Name = \"John\"],\u00a0\u00a0\u00a0\u00a0[Place = 2, Name = \"Brad\"],\u00a0\u00a0\u00a0\u00a0[Place = 3, Name = \"Mark\"],\u00a0\u00a0\u00a0\u00a0[Place = 3, Name = \"Tom\"],\u00a0\u00a0\u00a0\u00a0[Place = 3, Name = \"Adam\"]})",
                    "pages": []
                },
                {
                    "title": "Table.FillUp",
                    "Syntax": "Table.FillUp(table as table, columns as list) as table",
                    "About": "Returns a table from the table specified where the value of the next cell is propagated to the null-valued cells above in the columns specified.",
                    "Explain": "Return a table with the null values in column [Column2] filled with the value below them from the table.UsagePower Query MTable.FillUp(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 1, Column2 = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 3, Column2 = null],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 5, Column2 = 3]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"Column2\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = 1, Column2 = 2],\u00a0\u00a0\u00a0\u00a0[Column1 = 3, Column2 = 3],\u00a0\u00a0\u00a0\u00a0[Column1 = 5, Column2 = 3]})",
                    "pages": []
                },
                {
                    "title": "Table.FilterWithDataTable",
                    "Syntax": "Table.FilterWithDataTable(table as table, dataTableIdentifier as text) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.FindText",
                    "Syntax": "Table.FindText(table as table, text as text) as table",
                    "About": "Returns a table containing only the rows that have the specified text within one of their cells or any part thereof.",
                    "Explain": "Find the rows in the table that contain \"Bob\".UsagePower Query MTable.FindText(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Bob\")OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.First",
                    "Syntax": "Table.First(table as table, optional default as any) as any",
                    "About": "Returns the first row of the table or an optional default value, default, if the table is empty.",
                    "Explain": "Example 1Find the first row of the table.UsagePower Query MTable.First(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}))Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]Example 2Find the first row of the table ({}) or return [a = 0, b = 0] if empty.UsagePower Query MTable.First(Table.FromRecords({}), [a = 0, b = 0])Output[a = 0, b = 0]",
                    "pages": []
                },
                {
                    "title": "Table.FirstN",
                    "Syntax": "Table.FirstN(table as table, countOrCondition as any) as table",
                    "About": "Returns the first row(s) of the table table, depending on the value of countOrCondition:If countOrCondition is a number, that many rows (starting at the top) will be returned.If countOrCondition is a condition, the rows that meet the condition will be returned until a row does not meet the condition.",
                    "Explain": "Example 1Find the first two rows of the table.UsagePower Query MTable.FirstN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a02)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]})Example 2Find the first rows where [a] > 0 in the table.UsagePower Query MTable.FirstN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = -5, b = -6]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each [a] > 0)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4]})",
                    "pages": []
                },
                {
                    "title": "Table.FirstValue",
                    "Syntax": "Table.FirstValue(table as table, optional default as any) as any",
                    "About": "Returns the first column of the first row of the table table or a specified default value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.FromColumns",
                    "Syntax": "Table.FromColumns(lists as list, optional columns as any) as table",
                    "About": "Creates a table of type columns from a list lists containing nested lists with the column names and values. If some columns have more values then others, the missing values will be filled with the default value, 'null', if the columns are nullable.",
                    "Explain": "Example 1Return a table from a list of customer names in a list. Each value in the customer list item becomes a row value, and each list becomes a column.UsagePower Query MTable.FromColumns({\u00a0\u00a0\u00a0\u00a0{1, \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0{2, \"Jim\", \"987-6543\"},\u00a0\u00a0\u00a0\u00a0{3, \"Paul\", \"543-7890\"}})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = 1, Column2 = 2, Column3 = 3],\u00a0\u00a0\u00a0\u00a0[Column1 = \"Bob\", Column2 = \"Jim\", Column3 = \"Paul\"],\u00a0\u00a0\u00a0\u00a0[Column1 = \"123-4567\", Column2 = \"987-6543\", Column3 = \"543-7890\"]})Example 2Create a table from a given list of columns and a list of column names.UsagePower Query MTable.FromColumns(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1, \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{2, \"Jim\", \"987-6543\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{3, \"Paul\", \"543-7890\"}\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"Name\", \"Phone\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = 2, Phone = 3],\u00a0\u00a0\u00a0\u00a0[CustomerID = \"Bob\", Name = \"Jim\", Phone = \"Paul\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = \"123-4567\", Name = \"987-6543\", Phone = \"543-7890\"]})Example 3Create a table with different number of columns per row. The missing row value is null.UsagePower Query MTable.FromColumns(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1, 2, 3},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{4, 5},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{6, 7, 8, 9}\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0{\"column1\", \"column2\", \"column3\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[column1 = 1, column2 = 4, column3 = 6],\u00a0\u00a0\u00a0\u00a0[column1 = 2, column2 = 5, column3 = 7],\u00a0\u00a0\u00a0\u00a0[column1 = 3, column2 = null, column3 = 8],\u00a0\u00a0\u00a0\u00a0[column1 = null, column2 = null, column3 = 9]})",
                    "pages": []
                },
                {
                    "title": "Table.FromList",
                    "Syntax": "Table.FromList(list as list, optional splitter as nullable function, optional columns as any, optional default as any, optional extraValues as nullable number) as table",
                    "About": "Converts a list, list into a table by applying the optional splitting function, splitter, to each item in the list. By default, the list is assumed to be a list of text values that is split by commas. Optional columns may be the number of columns, a list of columns or a TableType. Optional default and extraValues may also be specified.",
                    "Explain": "Example 1Create a table from the list with the column named \"Letters\" using the default splitter.UsagePower Query MTable.FromList({\"a\", \"b\", \"c\", \"d\"}, null, {\"Letters\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Letters = \"a\"],\u00a0\u00a0\u00a0\u00a0[Letters = \"b\"],\u00a0\u00a0\u00a0\u00a0[Letters = \"c\"],\u00a0\u00a0\u00a0\u00a0[Letters = \"d\"]})Example 2Create a table from the list using the Record.FieldValues splitter with the resulting table having \"CustomerID\" and \"Name\" as column names.UsagePower Query MTable.FromList(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\"]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0Record.FieldValues,\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"Name\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\"]})",
                    "pages": []
                },
                {
                    "title": "Table.FromPartitions",
                    "Syntax": "Table.FromPartitions(partitionColumn as text, partitions as list, optional partitionColumnType as nullable type) as table",
                    "About": "Returns a table that is the result of combining a set of partitioned tables, partitions. partitionColumn is the name of the column to add. The type of the column defaults to any, but can be specified by partitionColumnType.",
                    "Explain": "Find item type from the list {number}.UsagePower Query MTable.FromPartitions(\u00a0\u00a0\u00a0\u00a0\"Year\",\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01994,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromPartitions(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Month\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Jan\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromPartitions(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Day\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1, #table({\"Foo\"}, {{\"Bar\"}})},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{2, #table({\"Foo\"}, {{\"Bar\"}})}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Feb\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromPartitions(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Day\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{3, #table({\"Foo\"}, {{\"Bar\"}})},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{4, #table({\"Foo\"}, {{\"Bar\"}})}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Foo = \"Bar\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Day = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Month = \"Jan\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Year = 1994\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Foo = \"Bar\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Day = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Month = \"Jan\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Year = 1994\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Foo = \"Bar\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Day = 3,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Month = \"Feb\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Year = 1994\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Foo = \"Bar\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Day = 4,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Month = \"Feb\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Year = 1994\u00a0\u00a0\u00a0\u00a0]})",
                    "pages": []
                },
                {
                    "title": "Table.FromRecords",
                    "Syntax": "Table.FromRecords(records as list, optional columns as any, optional missingField as nullable number) as table",
                    "About": "Converts records, a list of records, into a table.",
                    "Explain": "Example 1Create a table from records, using record field names as column names.UsagePower Query MTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})Example 2Create a table from records with typed columns and select the number columns.UsagePower Query MTable.ColumnsOfType(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{[CustomerID = 1, Name = \"Bob\"]},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table[CustomerID = Number.Type, Name = Text.Type]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0{type number})Output{\"CustomerID\"}",
                    "pages": []
                },
                {
                    "title": "Table.FromRows",
                    "Syntax": "Table.FromRows(rows as list, optional columns as any) as table",
                    "About": "Creates a table from the list rows where each element of the list is an inner list that contains the column values for a single row. An optional list of column names, a table type, or a number of columns could be provided for columns.",
                    "Explain": "Example 1Return a table with column [CustomerID] with values {1, 2}, column [Name] with values {\"Bob\", \"Jim\"}, and column [Phone] with values {\"123-4567\", \"987-6543\"}.UsagePower Query MTable.FromRows(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1, \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{2, \"Jim\", \"987-6543\"}\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"Name\", \"Phone\"}OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]})Example 2Return a table with column [CustomerID] with values {1, 2}, column [Name] with values {\"Bob\", \"Jim\"}, and column [Phone] with values {\"123-4567\", \"987-6543\"}, where [CustomerID] is number type, and [Name] and [Phone] are text types.UsagePower Query MTable.FromRows(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1, \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{2, \"Jim\", \"987-6543\"}\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0type table [CustomerID = number, Name = text, Phone = text])OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]})",
                    "pages": []
                },
                {
                    "title": "Table.FromValue",
                    "Syntax": "Table.FromValue(value as any, optional options as nullable record) as table",
                    "About": "Creates a table with a column containing the provided value or list of values, value. An optional record parameter, options, may be specified to control the following options:DefaultColumnName: The column name used when constructing a table from a list or scalar value.",
                    "Explain": "Example 1Create a table from the value 1.UsagePower Query MTable.FromValue(1)OutputTable.FromRecords({[Value = 1]})Example 2Create a table from the list.UsagePower Query MTable.FromValue({1, \"Bob\", \"123-4567\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Value = 1],\u00a0\u00a0\u00a0\u00a0[Value = \"Bob\"],\u00a0\u00a0\u00a0\u00a0[Value = \"123-4567\"]})Example 3Create a table from the value 1, with a custom column name.UsagePower Query MTable.FromValue(1, [DefaultColumnName = \"MyValue\"])OutputTable.FromRecords({[MyValue = 1]})",
                    "pages": []
                },
                {
                    "title": "Table.FuzzyGroup",
                    "Syntax": "Table.FuzzyGroup(table as table, key as any, aggregatedColumns as list, optional options as nullable record) as table",
                    "About": "Groups the rows of table by fuzzily matching values in the specified column, key, for each row. For each group, a record is constructed containing the key columns (and their values) along with any aggregated columns specified by aggregatedColumns. This function cannot guarantee to return a fixed order of rows.An optional set of options may be included to specify how to compare the key columns. Options include:Culture: Allows grouping records based on culture-specific rules. It can be any valid culture name. For example, a Culture option of \"ja-JP\" groups records based on the Japanese culture. The default value is \"\", which groups based on the Invariant English culture.IgnoreCase: A logical (true/false) value that allows case-insensitive key grouping. For example, when true, \"Grapes\" is grouped with \"grapes\". The default value is true.IgnoreSpace: A logical (true/false) value that allows combining of text parts in order to find groups. For example, when true, \"Gra pes\" is grouped with \"Grapes\". The default value is true.SimilarityColumnName: A name for the column that shows the similarity between an input value and the representative value for that input. The default value is null, in which case a new column for similarities will not be added.Threshold: A number between 0.00 and 1.00 that specifies the similarity score at which two values will be grouped. For example, \"Grapes\" and \"Graes\" (missing the \"p\") are grouped together only if this option is set to less than 0.90. A threshold of 1.00 only allows exact matches. (Note that a fuzzy \"exact match\" might ignore differences like casing, word order, and punctuation.) The default value is 0.80.TransformationTable: A table that allows grouping records based on custom value mappings. It should contain \"From\" and \"To\" columns. For example, \"Grapes\" is grouped with \"Raisins\" if a transformation table is provided with the \"From\" column containing \"Grapes\" and the \"To\" column containing \"Raisins\". Note that the transformation will be applied to all occurrences of the text in the transformation table. With the above transformation table, \"Grapes are sweet\" will also be grouped with \"Raisins are sweet\".",
                    "Explain": "Group the table adding an aggregate column [Count] that contains the number of employees in each location (each Table.RowCount(_)).UsagePower Query MTable.FuzzyGroup(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 1, Location = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 2, Location = \"seattl\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 3, Location = \"Vancouver\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 4, Location = \"Seatle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 5, Location = \"vancover\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 6, Location = \"Seattle\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EmployeeID = 7, Location = \"Vancouver\"]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [EmployeeID = nullable number, Location = nullable text]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0\"Location\",\u00a0\u00a0\u00a0\u00a0{\"Count\", each Table.RowCount(_)},\u00a0\u00a0\u00a0\u00a0[IgnoreCase = true, IgnoreSpace = true])OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Location = \"Seattle\", Count = 4],\u00a0\u00a0\u00a0\u00a0[Location = \"Vancouver\", Count = 3]})",
                    "pages": []
                },
                {
                    "title": "Table.FuzzyJoin",
                    "Syntax": "Table.FuzzyJoin(table1 as table, key1 as any, table2 as table, key2 as any, optional joinKind as nullable number, optional joinOptions as nullable record) as table",
                    "About": "Joins the rows of table1 with the rows of table2 based on a fuzzy matching of the values of the key columns selected by key1 (for table1) and key2 (for table2).Fuzzy matching is a comparison based on similarity of text rather than equality of text.By default, an inner join is performed, however an optional joinKind may be included to specify the type of join. Options include:JoinKind.InnerJoinKind.LeftOuterJoinKind.RightOuterJoinKind.FullOuterJoinKind.LeftAntiJoinKind.RightAntiAn optional set of joinOptions may be included to specify how to compare the key columns. Options include:ConcurrentRequests: A number between 1 and 8 that specifies the number of parallel threads to use for fuzzy matching. The default value is 1.Culture: Allows matching records based on culture-specific rules. It can be any valid culture name. For example, a Culture option of \"ja-JP\" matches records based on the Japanese culture. The default value is \"\", which matches based on the Invariant English culture.IgnoreCase: A logical (true/false) value that allows case-insensitive key matching. For example, when true, \"Grapes\" is matched with \"grapes\". The default value is true.IgnoreSpace: A logical (true/false) value that allows combining of text parts in order to find matches. For example, when true, \"Gra pes\" is matched with \"Grapes\". The default value is true.NumberOfMatches: A whole number that specifies the maximum number of matching rows that can be returned for every input row. For example, a value of 1 will return at most one matching row for each input row. If this option is not provided, all matching rows are returned.SimilarityColumnName: A name for the column that shows the similarity between an input value and the representative value for that input. The default value is null, in which case a new column for similarities will not be added.Threshold: A number between 0.00 and 1.00 that specifies the similarity score at which two values will be matched. For example, \"Grapes\" and \"Graes\" (missing the \"p\") are matched only if this option is set to less than 0.90. A threshold of 1.00 only allows exact matches. (Note that a fuzzy \"exact match\" might ignore differences like casing, word order, and punctuation.) The default value is 0.80.TransformationTable: A table that allows matching records based on custom value mappings. It should contain \"From\" and \"To\" columns. For example, \"Grapes\" is matched with \"Raisins\" if a transformation table is provided with the \"From\" column containing \"Grapes\" and the \"To\" column containing \"Raisins\". Note that the transformation will be applied to all occurrences of the text in the transformation table. With the above transformation table, \"Grapes are sweet\" will also be matched with \"Raisins are sweet\".",
                    "Explain": "Left inner fuzzy join of two tables based on [FirstName]UsagePower Query MTable.FuzzyJoin(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, FirstName1 = \"Bob\", Phone = \"555-1234\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, FirstName1 = \"Robert\", Phone = \"555-4567\"]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [CustomerID = nullable number, FirstName1 = nullable text, Phone = nullable text]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0{\"FirstName1\"},\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerStateID = 1, FirstName2 = \"Bob\", State = \"TX\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerStateID = 2, FirstName2 = \"bOB\", State = \"CA\"]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [CustomerStateID = nullable number, FirstName2 = nullable text, State = nullable text]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0{\"FirstName2\"},\u00a0\u00a0\u00a0\u00a0JoinKind.LeftOuter,\u00a0\u00a0\u00a0\u00a0[IgnoreCase = true, IgnoreSpace = false])OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerID = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName1 = \"Bob\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Phone = \"555-1234\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerStateID = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName2 = \"Bob\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = \"TX\"\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerID = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName1 = \"Bob\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Phone = \"555-1234\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerStateID = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName2 = \"bOB\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = \"CA\"\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerID = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName1 = \"Robert\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Phone = \"555-4567\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerStateID = null,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName2 = null,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = null\u00a0\u00a0\u00a0\u00a0]})",
                    "pages": []
                },
                {
                    "title": "Table.FuzzyNestedJoin",
                    "Syntax": "Table.FuzzyNestedJoin(table1 as table, key1 as any, table2 as table, key2 as any, newColumnName as text, optional joinKind as nullable number, optional joinOptions as nullable record) as table",
                    "About": "Joins the rows of table1 with the rows of table2 based on a fuzzy matching of the values of the key columns selected by key1 (for table1) and key2 (for table2). The results are returned in a new column named newColumnName.Fuzzy matching is a comparison based on similarity of text rather than equality of text.The optional joinKind specifies the kind of join to perform. By default, a left outer join is performed if a joinKind is not specified. Options include:JoinKind.InnerJoinKind.LeftOuterJoinKind.RightOuterJoinKind.FullOuterJoinKind.LeftAntiJoinKind.RightAntiAn optional set of joinOptions may be included to specify how to compare the key columns. Options include:ConcurrentRequests: A number between 1 and 8 that specifies the number of parallel threads to use for fuzzy matching. The default value is 1.Culture: Allows matching records based on culture-specific rules. It can be any valid culture name. For example, a Culture option of \"ja-JP\" matches records based on the Japanese culture. The default value is \"\", which matches based on the Invariant English culture.IgnoreCase: A logical (true/false) value that allows case-insensitive key matching. For example, when true, \"Grapes\" is matched with \"grapes\". The default value is true.IgnoreSpace: A logical (true/false) value that allows combining of text parts in order to find matches. For example, when true, \"Gra pes\" is matched with \"Grapes\". The default value is true.NumberOfMatches: A whole number that specifies the maximum number of matching rows that can be returned for every input row. For example, a value of 1 will return at most one matching row for each input row. If this option is not provided, all matching rows are returned.SimilarityColumnName: A name for the column that shows the similarity between an input value and the representative value for that input. The default value is null, in which case a new column for similarities will not be added.Threshold: A number between 0.00 and 1.00 that specifies the similarity score at which two values will be matched. For example, \"Grapes\" and \"Graes\" (missing the \"p\") are matched only if this option is set to less than 0.90. A threshold of 1.00 only allows exact matches. (Note that a fuzzy \"exact match\" might ignore differences like casing, word order, and punctuation.) The default value is 0.80.TransformationTable: A table that allows matching records based on custom value mappings. It should contain \"From\" and \"To\" columns. For example, \"Grapes\" is matched with \"Raisins\" if a transformation table is provided with the \"From\" column containing \"Grapes\" and the \"To\" column containing \"Raisins\". Note that the transformation will be applied to all occurrences of the text in the transformation table. With the above transformation table, \"Grapes are sweet\" will also be matched with \"Raisins are sweet\".",
                    "Explain": "Left inner fuzzy join of two tables based on [FirstName]UsagePower Query MTable.FuzzyNestedJoin(\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, FirstName1 = \"Bob\", Phone = \"555-1234\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, FirstName1 = \"Robert\", Phone = \"555-4567\"]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [CustomerID = nullable number, FirstName1 = nullable text, Phone = nullable text]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0{\"FirstName1\"},\u00a0\u00a0\u00a0\u00a0Table.FromRecords(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerStateID = 1, FirstName2 = \"Bob\", State = \"TX\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerStateID = 2, FirstName2 = \"bOB\", State = \"CA\"]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type table [CustomerStateID = nullable number, FirstName2 = nullable text, State = nullable text]\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0{\"FirstName2\"},\u00a0\u00a0\u00a0\u00a0\"NestedTable\",\u00a0\u00a0\u00a0\u00a0JoinKind.LeftOuter,\u00a0\u00a0\u00a0\u00a0[IgnoreCase = true, IgnoreSpace = false])OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerID = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName1 = \"Bob\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Phone = \"555-1234\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NestedTable = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerStateID = 1,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName2 = \"Bob\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = \"TX\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerStateID = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName2 = \"bOB\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = \"CA\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0})\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CustomerID = 2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FirstName1 = \"Robert\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Phone = \"555-4567\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NestedTable = Table.FromRecords({})\u00a0\u00a0\u00a0\u00a0]})",
                    "pages": []
                },
                {
                    "title": "Table.Group",
                    "Syntax": "Table.Group(table as table, key as any, aggregatedColumns as list, optional groupKind as nullable number, optional comparer as nullable function) as table",
                    "About": "Groups the rows of table by the key columns defined by key. The key can either be a single column name, or a list of column names. For each group, a record is constructed containing the key columns (and their values), along with any aggregated columns specified by aggregatedColumns. Optionally, groupKind and comparer may also be specified.If the data is already sorted by the key columns, then a groupKind of GroupKind.Local can be provided. This may improve the performance of grouping in certain cases, since all the rows with a given set of key values are assumed to be contiguous.When passing a comparer, note that if it treats differing keys as equal, a row may be placed in a group whose keys differ from its own.This function does not guarantee the ordering of the rows it returns.",
                    "Explain": "Group the table adding an aggregate column [total] which contains the sum of prices (\"each List.Sum([price])\").UsagePower Query MTable.Group(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, price = 20],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, price = 10],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, price = 20],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, price = 10],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, price = 20],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, price = 5]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"CustomerID\",\u00a0\u00a0\u00a0\u00a0{\"total\", each List.Sum([price])})OutputTable.FromRecords(\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, total = 30],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, total = 30],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, total = 25]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"total\"})",
                    "pages": []
                },
                {
                    "title": "Table.HasColumns",
                    "Syntax": "Table.HasColumns(table as table, columns as any) as logical",
                    "About": "Indicates whether the table contains the specified column(s), columns. Returns true if the table contains the column(s), false otherwise.",
                    "Explain": "Example 1Determine if the table has the column [Name].UsagePower Query MTTable.HasColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Name\")OutputtrueExample 2Find if the table has the column [Name] and [PhoneNumber].UsagePower Query MTable.HasColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"Name\", \"PhoneNumber\"})Outputfalse",
                    "pages": []
                },
                {
                    "title": "Table.InsertRows",
                    "Syntax": "Table.InsertRows(table as table, offset as number, rows as list) as table",
                    "About": "Returns a table with the list of rows, rows, inserted into the table at the given position, offset. Each column in the row to insert must match the column types of the table.",
                    "Explain": "Example 1Insert the row into the table at position 1.UsagePower Query MTable.InsertRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a0{[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]})Example 2Insert two rows into the table at position 1.UsagePower Query MTable.InsertRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})",
                    "pages": []
                },
                {
                    "title": "Table.IsDistinct",
                    "Syntax": "Table.IsDistinct(table as table, optional comparisonCriteria as any) as logical",
                    "About": "Indicates whether the table contains only distinct rows (no duplicates). Returns true if the rows are distinct, false otherwise. An optional parameter, comparisonCriteria, specifies which columns of the table are tested for duplication. If comparisonCriteria is not specified, all columns are tested.",
                    "Explain": "Example 1Determine if the table is distinct.UsagePower Query MTable.IsDistinct(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}))OutputtrueExample 2Determine if the table is distinct in column.UsagePower Query MTable.IsDistinct(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 5, Name = \"Bob\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Name\")Outputfalse",
                    "pages": []
                },
                {
                    "title": "Table.IsEmpty",
                    "Syntax": "Table.IsEmpty(table as table) as logical",
                    "About": "Indicates whether the table contains any rows. Returns true if there are no rows (i.e. the table is empty), false otherwise.",
                    "Explain": "Example 1Determine if the table is empty.UsagePower Query MTable.IsEmpty(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}))OutputfalseExample 2Determine if the table ({}) is empty.UsagePower Query MTable.IsEmpty(Table.FromRecords({}))Outputtrue",
                    "pages": []
                },
                {
                    "title": "Table.Join",
                    "Syntax": "Table.Join(table1 as table, key1 as any, table2 as table, key2 as any, optional joinKind as nullable number, optional joinAlgorithm as nullable number, optional keyEqualityComparers as nullable list) as table",
                    "About": "Joins the rows of table1 with the rows of table2 based on the equality of the values of the key columns selected by key1 (for table1) and key2 (for table2).By default, an inner join is performed, however an optional joinKind may be included to specify the type of join. Options include:JoinKind.InnerJoinKind.LeftOuterJoinKind.RightOuterJoinKind.FullOuterJoinKind.LeftAntiJoinKind.RightAntiAn optional set of keyEqualityComparers may be included to specify how to compare the key columns. This feature is currently intended for internal use only.",
                    "Explain": "Join two tables using a single key column.UsagePower Query MTable.Join(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"CustomerID\",\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"CustomerID\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\", OrderID = 1, Item = \"Fishing rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\", OrderID = 2, Item = \"1 lb. worms\", Price = 5],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\", OrderID = 3, Item = \"Fishing net\", Price = 25],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\", OrderID = 4, Item = \"Fish tazer\", Price = 200],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\", OrderID = 5, Item = \"Bandaids\", Price = 2],\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\", OrderID = 6, Item = \"Tackle box\", Price = 20]})",
                    "pages": []
                },
                {
                    "title": "Table.Keys",
                    "Syntax": "Table.Keys(table as table) as list",
                    "About": "Returns the keys of the specified table.",
                    "Explain": "Get the list of keys for a table.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0table = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Id = 1, Name = \"Hello There\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Id = 2, Name = \"Good Bye\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0tableWithKeys = Table.AddKey(table, {\"Id\"}, true),\u00a0\u00a0\u00a0\u00a0keys = Table.Keys(tableWithKeys)in\u00a0\u00a0\u00a0\u00a0keysOutput{[Columns = {\"Id\"}, Primary = true]}",
                    "pages": []
                },
                {
                    "title": "Table.Last",
                    "Syntax": "Table.Last(table as table, optional default as any) as any",
                    "About": "Returns the last row of the table or an optional default value, default, if the table is empty.",
                    "Explain": "Example 1Find the last row of the table.UsagePower Query MTable.Last(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}))Output[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]Example 2Find the last row of the table ({}) or return [a = 0, b = 0] if empty.UsagePower Query MTable.Last(Table.FromRecords({}), [a = 0, b = 0])Output[a = 0, b = 0]",
                    "pages": []
                },
                {
                    "title": "Table.LastN",
                    "Syntax": "Table.LastN(table as table, countOrCondition as any) as table",
                    "About": "Returns the last row(s) from the table, table, depending on the value of countOrCondition:If countOrCondition is a number, that many rows will be returned starting from position (end - countOrCondition).If countOrCondition is a condition, the rows that meet the condition will be returned in ascending position until a row does not meet the condition.",
                    "Explain": "Example 1Find the last two rows of the table.UsagePower Query MTable.LastN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a02)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})Example 2Find the last rows where [a] > 0 in the table.UsagePower Query MTable.LastN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = -1, b = -2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 5, b = 6]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each _ [a] > 0OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4],\u00a0\u00a0\u00a0\u00a0[a = 5, b = 6]})",
                    "pages": []
                },
                {
                    "title": "Table.MatchesAllRows",
                    "Syntax": "Table.MatchesAllRows(table as table, condition as function) as logical",
                    "About": "Indicates whether all the rows in the table match the given condition. Returns true if all of the rows match, false otherwise.",
                    "Explain": "Example 1Determine whether all of the row values in column [a] are even in the table.UsagePower Query MTable.MatchesAllRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 8]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each Number.Mod([a], 2) = 0)OutputtrueExample 2Find if all of the row values are [a = 1, b = 2], in the table ({[a = 1, b = 2], [a = 3, b = 4]}).UsagePower Query MTable.MatchesAllRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = -3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each _ = [a = 1, b = 2])Outputfalse",
                    "pages": []
                },
                {
                    "title": "Table.MatchesAnyRows",
                    "Syntax": "Table.MatchesAnyRows(table as table, condition as function) as logical",
                    "About": "Indicates whether any the rows in the table match the given condition. Returns true if any of the rows match, false otherwise.",
                    "Explain": "Example 1Determine whether any of the row values in column [a] are even in the table ({[a = 2, b = 4], [a = 6, b = 8]}).UsagePower Query MTable.MatchesAnyRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 8]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each Number.Mod([a], 2) = 0)OutputfalseExample 2Determine whether any of the row values are [a = 1, b = 2], in the table ({[a = 1, b = 2], [a = 3, b = 4]}).UsagePower Query MTable.MatchesAnyRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = -3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each _ = [a = 1, b = 2])Outputtrue",
                    "pages": []
                },
                {
                    "title": "Table.Max",
                    "Syntax": "Table.Max(table as table, comparisonCriteria as any, optional default as any) as any",
                    "About": "Returns the largest row in the table, given the comparisonCriteria. If the table is empty, the optional default value is returned.",
                    "Explain": "Example 1Find the row with the largest value in column [a] in the table ({[a = 2, b = 4], [a = 6, b = 8]}).UsagePower Query MTable.Max(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 8]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\")Output[a = 6, b = 8]Example 2Find the row with the largest value in column [a] in the table ({}). Return -1 if empty.UsagePower Query MTable.Max(#table({\"a\"}, {}), \"a\", -1)Output-1",
                    "pages": []
                },
                {
                    "title": "Table.MaxN",
                    "Syntax": "Table.MaxN(table as table, comparisonCriteria as any, countOrCondition as any) as table",
                    "About": "Returns the largest row(s) in the table, given the comparisonCriteria. After the rows are sorted, the countOrCondition parameter must be specified to further filter the result. Note the sorting algorithm cannot guarantee a fixed sorted result. The countOrCondition parameter can take multiple forms:If a number is specified, a list of up to countOrCondition items in ascending order is returned.If a condition is specified, a list of items that initially meet the condition is returned. Once an item fails the condition, no further items are considered.",
                    "Explain": "Example 1Find the row with the largest value in column [a] with the condition [a] > 0, in the table. The rows are sorted before the filter is applied.UsagePower Query MTable.MaxN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 0, b = 0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 2]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a0each [a] > 0)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = 6, b = 2],\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4]})Example 2Find the row with the largest value in column [a] with the condition [b] > 0, in the table. The rows are sorted before the filter is applied.UsagePower Query MTable.MaxN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 8, b = 0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 2]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a0each [b] > 0)OutputTable.FromRecords({})",
                    "pages": []
                },
                {
                    "title": "Table.Min",
                    "Syntax": "Table.Min(table as table, comparisonCriteria as any, optional default as any) as any",
                    "About": "Returns the smallest row in the table, given the comparisonCriteria. If the table is empty, the optional default value is returned.",
                    "Explain": "Example 1Find the row with the smallest value in column [a] in the table.UsagePower Query MTable.Min(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 8]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\")Output[a = 2, b = 4]Example 2Find the row with the smallest value in column [a] in the table. Return -1 if empty.UsagePower Query MTable.Min(#table({\"a\"}, {}), \"a\", -1)Output-1",
                    "pages": []
                },
                {
                    "title": "Table.MinN",
                    "Syntax": "Table.MinN(table as table, comparisonCriteria as any, countOrCondition as any) as table",
                    "About": "Returns the smallest row(s) in the table, given the comparisonCriteria. After the rows are sorted, the countOrCondition parameter must be specified to further filter the result. Note the sorting algorithm cannot guarantee a fixed sorted result. The countOrCondition parameter can take multiple forms:If a number is specified, a list of up to countOrCondition items in ascending order is returned.If a condition is specified, a list of items that initially meet the condition is returned. Once an item fails the condition, no further items are considered.",
                    "Explain": "Example 1Find the row with the smallest value in column [a] with the condition [a] < 3, in the table. The rows are sorted before the filter is applied.UsagePower Query MTable.MinN(\u00a0\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 0, b = 0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a0\u00a0each [a] < 3\u00a0)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = 0, b = 0],\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4]})Example 2Find the row with the smallest value in column [a] with the condition [b] < 0, in the table. The rows are sorted before the filter is applied.UsagePower Query MTable.MinN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 8, b = 0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 2]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a0each [b] < 0)OutputTable.FromRecords({})",
                    "pages": []
                },
                {
                    "title": "Table.NestedJoin",
                    "Syntax": "Table.NestedJoin(table1 as table, key1 as any, table2 as any, key2 as any, newColumnName as text, optional joinKind as nullable number, optional keyEqualityComparers as nullable list) as table",
                    "About": "Joins the rows of table1 with the rows of table2 based on the equality of the values of the key columns selected by key1 (for table1) and key2 (for table2). The results are entered into the column named newColumnName.The optional joinKind specifies the kind of join to perform. By default, a left outer join is performed if a joinKind is not specified.An optional set of keyEqualityComparers may be included to specify how to compare the key columns. This keyEqualityComparers feature is currently intended for internal use only.",
                    "Explain": "Join two tables using a single key column.UsagePower Query MTable.NestedJoin(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerToCall = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerToCall = 3]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"CustomerToCall\"},\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"CustomerID\"},\u00a0\u00a0\u00a0\u00a0\"CustomerDetails\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerToCall = 1, CustomerDetails = Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})],\u00a0\u00a0\u00a0\u00a0[CustomerToCall = 3, CustomerDetails = Table.FromRecords({[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})]})",
                    "pages": []
                },
                {
                    "title": "Table.Partition",
                    "Syntax": "Table.Partition(table as table, column as text, groups as number, hash as function) as list",
                    "About": "Partitions the table into a list of groups number of tables, based on the value of the column and a hash function. The hash function is applied to the value of the column row to obtain a hash value for the row. The hash value modulo groups determines in which of the returned tables the row will be placed.table: The table to partition.column: The column to hash to determine which returned table the row is in.groups: The number of tables the input table will be partitioned into.hash: The function applied to obtain a hash value.",
                    "Explain": "Partition the table ({[a = 2, b = 4], [a = 6, b = 8], [a = 2, b = 4], [a = 1, b = 4]}) into 2 tables on column [a], using the value of the columns as the hash function.UsagePower Query MTable.Partition(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"a\",\u00a0\u00a0\u00a0\u00a02,\u00a0\u00a0\u00a0\u00a0each _)Output{\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0})}",
                    "pages": []
                },
                {
                    "title": "Table.PartitionValues",
                    "Syntax": "Table.PartitionValues(table as table) as table",
                    "About": "Returns information about how a table is partitioned. A table is returned where each column is a partition column in the original table, and each row corresponds to a partition in the original table.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.Pivot",
                    "Syntax": "Table.Pivot(table as table, pivotValues as list, attributeColumn as text, valueColumn as text, optional aggregationFunction as nullable function) as table",
                    "About": "Given a table and attribute column containing pivotValues, creates new columns for each of the pivot values and assigns them values from the valueColumn. An optional aggregationFunction can be provided to handle multiple occurrence of the same key value in the attribute column.",
                    "Explain": "Example 1Take the values \"a\", \"b\", and \"c\" in the attribute column of table ({ [ key = \"x\", attribute = \"a\", value = 1 ], [ key = \"x\", attribute = \"c\", value = 3 ], [ key = \"y\", attribute = \"a\", value = 2 ], [ key = \"y\", attribute = \"b\", value = 4 ] }) and pivot them into their own column.UsagePower Query MTable.Pivot(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"a\", value = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"c\", value = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"y\", attribute = \"a\", value = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"y\", attribute = \"b\", value = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"a\", \"b\", \"c\"},\u00a0\u00a0\u00a0\u00a0\"attribute\",\u00a0\u00a0\u00a0\u00a0\"value\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[key = \"x\", a = 1, b = null, c = 3],\u00a0\u00a0\u00a0\u00a0[key = \"y\", a = 2, b = 4, c = null]})Example 2Take the values \"a\", \"b\", and \"c\" in the attribute column of table ({ [ key = \"x\", attribute = \"a\", value = 1 ], [ key = \"x\", attribute = \"c\", value = 3 ], [ key = \"x\", attribute = \"c\", value = 5 ], [ key = \"y\", attribute = \"a\", value = 2 ], [ key = \"y\", attribute = \"b\", value = 4 ] }) and pivot them into their own column. The attribute \"c\" for key \"x\" has multiple values associated with it, so use the function List.Max to resolve the conflict.UsagePower Query MTable.Pivot(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"a\", value = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"c\", value = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"c\", value = 5],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"y\", attribute = \"a\", value = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"y\", attribute = \"b\", value = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"a\", \"b\", \"c\"},\u00a0\u00a0\u00a0\u00a0\"attribute\",\u00a0\u00a0\u00a0\u00a0\"value\",\u00a0\u00a0\u00a0\u00a0List.Max)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[key = \"x\", a = 1, b = null, c = 5],\u00a0\u00a0\u00a0\u00a0[key = \"y\", a = 2, b = 4, c = null]})",
                    "pages": []
                },
                {
                    "title": "Table.PositionOf",
                    "Syntax": "Table.PositionOf(table as table, row as record, optional occurrence as any, optional equationCriteria as any) as any",
                    "About": "Returns the row position of the first occurrence of the row in the table specified. Returns -1 if no occurrence is found.table: The input table.row: The row in the table to find the position of.occurrence: [Optional] Specifies which occurrences of the row to return.equationCriteria: [Optional] Controls the comparison between the table rows.",
                    "Explain": "Example 1Find the position of the first occurrence of [a = 2, b = 4] in the table ({[a = 2, b = 4], [a = 6, b = 8], [a = 2, b = 4], [a = 1, b = 4]}).UsagePower Query MTable.PositionOf(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4])Output0Example 2Find the position of the second occurrence of [a = 2, b = 4] in the table ({[a = 2, b = 4], [a = 6, b = 8], [a = 2, b = 4], [a = 1, b = 4]}).UsagePower Query MTable.PositionOf(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a01)Output2Example 3Find the position of all the occurrences of [a = 2, b = 4] in the table ({[a = 2, b = 4], [a = 6, b = 8], [a = 2, b = 4], [a = 1, b = 4]}).UsagePower Query MTable.PositionOf(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0Occurrence.All)Output{0, 2}",
                    "pages": []
                },
                {
                    "title": "Table.PositionOfAny",
                    "Syntax": "Table.PositionOfAny(table as table, rows as list, optional occurrence as nullable number, optional equationCriteria as any) as any",
                    "About": "Returns the row(s) position(s) from the table of the first occurrence of the list of rows. Returns -1 if no occurrence is found.table: The input table.rows: The list of rows in the table to find the positions of.occurrence: [Optional] Specifies which occurrences of the row to return.`equationCriteria: [Optional] Controls the comparison between the table rows.",
                    "Explain": "Example 1Find the position of the first occurrence of [a = 2, b = 4] or [a = 6, b = 8] in the table ({[a = 2, b = 4], [a = 6, b = 8], [a = 2, b = 4], [a = 1, b = 4]}).UsagePower Query MTable.PositionOfAny(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 8]\u00a0\u00a0\u00a0\u00a0})Output0Example 2Find the position of all the occurrences of [a = 2, b = 4] or [a = 6, b = 8] in the table ({[a = 2, b = 4], [a = 6, b = 8], [a = 2, b = 4], [a = 1, b = 4]}.UsagePower Query MTable.PositionOfAny(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 8],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 6, b = 8]\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0Occurrence.All)Output{0, 1, 2}",
                    "pages": []
                },
                {
                    "title": "Table.PrefixColumns",
                    "Syntax": "Table.PrefixColumns(table as table, prefix as text) as table",
                    "About": "Returns a table where all the column names from the table provided are prefixed with the given text, prefix, plus a period in the form prefix .ColumnName.",
                    "Explain": "Prefix the columns with \"MyTable\" in the table.UsagePower Query MTable.PrefixColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0\"MyTable\")OutputTable.FromRecords({[MyTable.CustomerID = 1, MyTable.Name = \"Bob\", MyTable.Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.Profile",
                    "Syntax": "Table.Profile(table as table, optional additionalAggregates as nullable list) as table",
                    "About": "Returns a profile for the columns in table.The following information is returned for each column (when applicable):minimummaximumaveragestandard deviationcountnull countdistinct count",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.PromoteHeaders",
                    "Syntax": "Table.PromoteHeaders(table as table, optional options as nullable record) as table",
                    "About": "Promotes the first row of values as the new column headers (i.e. column names). By default, only text or number values are promoted to headers. Valid options:PromoteAllScalars: If set to true, all the scalar values in the first row are promoted to headers using the Culture, if specified (or current document locale). For values that cannot be converted to text, a default column name will be used.Culture: A culture name specifying the culture for the data.",
                    "Explain": "Example 1Promote the first row of values in the table.UsagePower Query MTable.PromoteHeaders(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = \"CustomerID\", Column2 = \"Name\", Column3 = #date(1980, 1, 1)],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 1, Column2 = \"Bob\", Column3 = #date(1980, 1, 1)]\u00a0\u00a0\u00a0\u00a0}))OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Column3 = #date(1980, 1, 1)]})Example 2Promote all the scalars in the first row of the table to headers.UsagePower Query MTable.PromoteHeaders(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Rank = 1, Name = \"Name\", Date = #date(1980, 1, 1)],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Rank = 1, Name = \"Bob\", Date = #date(1980, 1, 1)]}\u00a0\u00a0\u00a0\u00a0),\u00a0\u00a0\u00a0\u00a0[PromoteAllScalars = true, Culture = \"en-US\"])OutputTable.FromRecords({[1 = 1, Name = \"Bob\", #\"1/1/1980\" = #date(1980, 1, 1)]})",
                    "pages": []
                },
                {
                    "title": "Table.Range",
                    "Syntax": "Table.Range(table as table, offset as number, optional count as nullable number) as table",
                    "About": "Returns the rows from the table starting at the specified offset. An optional parameter, count, specifies how many rows to return. By default, all the rows after the offset are returned.",
                    "Explain": "Example 1Return all the rows starting at offset 1 in the table.UsagePower Query MTable.Range(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 2Return one row starting at offset 1 in the table.UsagePower Query MTable.Range(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]})",
                    "pages": []
                },
                {
                    "title": "Table.RemoveColumns",
                    "Syntax": "Table.RemoveColumns(table as table, columns as any, optional missingField as nullable number) as table",
                    "About": "Removes the specified columns from the table provided. If the specified column doesn't exist, an error is raised unless the optional parameter missingField specifies an alternative behavior (for example, MissingField.UseNull or MissingField.Ignore).",
                    "Explain": "Example 1Remove column [Phone] from the table.UsagePower Query MTable.RemoveColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0\"Phone\")OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\"]})Example 2Try to remove a non-existent column from the table.UsagePower Query MTable.RemoveColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0\"Address\")Output[Expression.Error] The column 'Address' of the table wasn't found.",
                    "pages": []
                },
                {
                    "title": "Table.RemoveFirstN",
                    "Syntax": "Table.RemoveFirstN(table as table, optional countOrCondition as any) as table",
                    "About": "Returns a table that does not contain the first specified number of rows, countOrCondition, of the table table. The number of rows removed depends on the optional parameter countOrCondition.If countOrCondition is omitted only the first row is removed.If countOrCondition is a number, that many rows (starting at the top) will be removed.If countOrCondition is a condition, the rows that meet the condition will be removed until a row does not meet the condition.",
                    "Explain": "Example 1Remove the first row of the table.UsagePower Query MTable.RemoveFirstN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 2Remove the first two rows of the table.UsagePower Query MTable.RemoveFirstN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a02)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 3Remove the first rows where [CustomerID] <=2 of the table.UsagePower Query MTable.RemoveFirstN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"] ,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"] ,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\u00a0each [CustomerID] <= 2)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})",
                    "pages": []
                },
                {
                    "title": "Table.RemoveLastN",
                    "Syntax": "Table.RemoveLastN(table as table, optional countOrCondition as any) as table",
                    "About": "Returns a table that does not contain the last countOrCondition rows of the table table. The number of rows removed depends on the optional parameter countOrCondition.If countOrCondition is omitted only the last row is removed.If countOrCondition is a number, that many rows (starting at the bottom) will be removed.If countOrCondition is a condition, the rows that meet the condition will be removed until a row does not meet the condition.",
                    "Explain": "Example 1Remove the last row of the table.UsagePower Query MTable.RemoveLastN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]})Example 2Remove the last rows where [CustomerID] > 2 of the table.UsagePower Query MTable.RemoveLastN(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each [CustomerID] >= 2)OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.RemoveMatchingRows",
                    "Syntax": "Table.RemoveMatchingRows(table as table, rows as list, optional equationCriteria as any) as table",
                    "About": "Removes all occurrences of the specified rows from the table. An optional parameter equationCriteria may be specified to control the comparison between the rows of the table.",
                    "Explain": "Remove any rows where [a = 1] from the table ({[a = 1, b = 2], [a = 3, b = 4], [a = 1, b = 6]}).UsagePower Query MTable.RemoveMatchingRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 6]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{[a = 1]},\u00a0\u00a0\u00a0\u00a0\"a\")OutputTable.FromRecords({[a = 3, b = 4]})",
                    "pages": []
                },
                {
                    "title": "Table.RemoveRows",
                    "Syntax": "Table.RemoveRows(table as table, offset as number, optional count as nullable number) as table",
                    "About": "Removes count of rows from the beginning of the table, starting at the offset specified. A default count of 1 is used if the count parameter isn't provided.",
                    "Explain": "Example 1Remove the first row from the table.UsagePower Query MTable.RemoveRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a00)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 2Remove the row at position 1 from the table.UsagePower Query MTable.RemoveRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 3Remove two rows starting at position 1 from the table.UsagePower Query MTable.RemoveRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a02)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})",
                    "pages": []
                },
                {
                    "title": "Table.RemoveRowsWithErrors",
                    "Syntax": "Table.RemoveRowsWithErrors(table as table, optional columns as nullable list) as table",
                    "About": "Returns a table with the rows removed from the input table that contain an error in at least one of the cells. If a columns list is specified, then only the cells in the specified columns are inspected for errors.",
                    "Explain": "Remove error value from first row.UsagePower Query MTable.RemoveRowsWithErrors(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = ...],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 3]\u00a0\u00a0\u00a0\u00a0}))OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = 2],\u00a0\u00a0\u00a0\u00a0[Column1 = 3]})",
                    "pages": []
                },
                {
                    "title": "Table.RenameColumns",
                    "Syntax": "Table.RenameColumns(table as table, renames as list, optional missingField as nullable number) as table",
                    "About": "Performs the given renames to the columns in table table. A replacement operation renames consists of a list of two values, the old column name and new column name, provided in a list. If the column doesn't exist, an exception is thrown unless the optional parameter missingField specifies an alternative (eg. MissingField.UseNull or MissingField.Ignore).",
                    "Explain": "Example 1Replace the column name \"CustomerNum\" with \"CustomerID\" in the table.UsagePower Query MTable.RenameColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerNum = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0{\"CustomerNum\", \"CustomerID\"})OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})Example 2Replace the column name \"CustomerNum\" with \"CustomerID\" and \"PhoneNum\" with \"Phone\" in the table.UsagePower Query MTable.RenameColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerNum = 1, Name = \"Bob\", PhoneNum = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"CustomerNum\", \"CustomerID\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"PhoneNum\", \"Phone\"}\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})Example 3Replace the column name \"NewCol\" with \"NewColumn\" in the table, and ignore if the column doesn't exist.UsagePower Query MTable.RenameColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0{\"NewCol\", \"NewColumn\"},\u00a0\u00a0\u00a0\u00a0MissingField.Ignore)OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.ReorderColumns",
                    "Syntax": "Table.ReorderColumns(table as table, columnOrder as list, optional missingField as nullable number) as table",
                    "About": "Returns a table from the input table, with the columns in the order specified by columnOrder. Columns that are not specified in the list will not be reordered. If the column doesn't exist, an exception is thrown unless the optional parameter missingField specifies an alternative (eg. MissingField.UseNull or MissingField.Ignore).",
                    "Explain": "Example 1Switch the order of the columns [Phone] and [Name] in the table.UsagePower Query MTable.ReorderColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Phone = \"123-4567\", Name = \"Bob\"]}),\u00a0\u00a0\u00a0\u00a0{\"Name\", \"Phone\"})OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})Example 2Switch the order of the columns [Phone] and [Address] or use \"MissingField.Ignore\" in the table. It doesn't change the table because column [Address] doesn't exist.UsagePower Query MTable.ReorderColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0{\"Phone\", \"Address\"},\u00a0\u00a0\u00a0\u00a0MissingField.Ignore)OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.Repeat",
                    "Syntax": "Table.Repeat(table as table, count as number) as table",
                    "About": "Returns a table with the rows from the input table repeated the specified count times.",
                    "Explain": "Repeat the rows in the table two times.UsagePower Query MTable.Repeat(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = \"hello\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = \"world\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a02OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = 1, b = \"hello\"],\u00a0\u00a0\u00a0\u00a0[a = 3, b = \"world\"],\u00a0\u00a0\u00a0\u00a0[a = 1, b = \"hello\"],\u00a0\u00a0\u00a0\u00a0[a = 3, b = \"world\"]})",
                    "pages": []
                },
                {
                    "title": "Table.ReplaceErrorValues",
                    "Syntax": "Table.ReplaceErrorValues(table as table, errorReplacement as list) as table",
                    "About": "Replaces the error values in the specified columns of the table with the new values in the errorReplacement list. The format of the list is {{column1, value1}, ...}. There may only be one replacement value per column, specifying the column more than once will result in an error.",
                    "Explain": "Example 1Replace the error value with the text \"world\" in the table.UsagePower Query MTable.ReplaceErrorValues(\u00a0\u00a0\u00a0\u00a0Table.FromRows({{1, \"hello\"}, {3, ...}}, {\"A\", \"B\"}),\u00a0\u00a0\u00a0\u00a0{\"B\", \"world\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"hello\"],\u00a0\u00a0\u00a0\u00a0[A = 3, B = \"world\"]})Example 2Replace the error value in column A with the text \"hello\" and in column B with the text \"world\" in the table.UsagePower Query MTable.ReplaceErrorValues(\u00a0\u00a0\u00a0\u00a0Table.FromRows({{..., ...}, {1, 2}}, {\"A\", \"B\"}),\u00a0\u00a0\u00a0\u00a0{{\"A\", \"hello\"}, {\"B\", \"world\"}})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = \"hello\", B = \"world\"],\u00a0\u00a0\u00a0\u00a0[A = 1, B = 2]})",
                    "pages": []
                },
                {
                    "title": "Table.ReplaceKeys",
                    "Syntax": "Table.ReplaceKeys(table as table, keys as list) as table",
                    "About": "Replaces the keys of the specified table.",
                    "Explain": "Replace the existing keys of a table.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0table = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Id = 1, Name = \"Hello There\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Id = 2, Name = \"Good Bye\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0tableWithKeys = Table.AddKey(table, {\"Id\"}, true),\u00a0\u00a0\u00a0\u00a0resultTable = Table.ReplaceKeys(tableWithKeys, {[Columns = {\"Id\"}, Primary = false]})in\u00a0\u00a0\u00a0\u00a0resultTableOutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Id = 1, Name = \"Hello There\"],\u00a0\u00a0\u00a0\u00a0[Id = 2, Name = \"Good Bye\"]})",
                    "pages": []
                },
                {
                    "title": "Table.ReplaceMatchingRows",
                    "Syntax": "Table.ReplaceMatchingRows(table as table, replacements as list, optional equationCriteria as any) as table",
                    "About": "Replaces all the specified rows in the table with the provided ones. The rows to replace and the replacements are specified in replacements, using {old, new} formatting. An optional equationCriteria parameter may be specified to control comparison between the rows of the table.",
                    "Explain": "Replace the rows [a = 1, b = 2] and [a = 2, b = 3] with [a = -1, b = -2],[a = -2, b = -3] in the table.UsagePower Query MTable.ReplaceMatchingRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2, b = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{[a = 1, b = 2], [a = -1, b = -2]},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{[a = 2, b = 3], [a = -2, b = -3]}\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = -1, b = -2],\u00a0\u00a0\u00a0\u00a0[a = -2, b = -3],\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4],\u00a0\u00a0\u00a0\u00a0[a = -1, b = -2]})",
                    "pages": []
                },
                {
                    "title": "Table.ReplaceRelationshipIdentity",
                    "Syntax": "Table.ReplaceRelationshipIdentity(value as any, identity as text) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.ReplaceRows",
                    "Syntax": "Table.ReplaceRows(table as table, offset as number, count as number, rows as list) as table",
                    "About": "Replaces a specified number of rows, count, in the input table with the specified rows, beginning after the offset. The rows parameter is a list of records.table: The table where the replacement is performed.offset: The number of rows to skip before making the replacement.count: The number of rows to replace.rows: The list of row records to insert into the table at the location specified by the offset.",
                    "Explain": "Starting at position 1, replace 3 rows.UsagePower Query MTable.ReplaceRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 5]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01,\u00a0\u00a0\u00a0\u00a03,\u00a0\u00a0\u00a0\u00a0{[Column1 = 6], [Column1 = 7]})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = 1],\u00a0\u00a0\u00a0\u00a0[Column1 = 6],\u00a0\u00a0\u00a0\u00a0[Column1 = 7],\u00a0\u00a0\u00a0\u00a0[Column1 = 5]})",
                    "pages": []
                },
                {
                    "title": "Table.ReplaceValue",
                    "Syntax": "Table.ReplaceValue(table as table, oldValue as any, newValue as any, replacer as function, columnsToSearch as list) as table",
                    "About": "Replaces oldValue with newValue in specific columns of a table, using the provided replacer function, such as text.Replace or Value.Replace.",
                    "Explain": "Example 1Replace the text \"goodbye\" with \"world\" in column B, matching only the entire value.UsagePower Query MTable.ReplaceValue(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"hello\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = 2, B = \"goodbye\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = 3, B = \"goodbyes\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"goodbye\",\u00a0\u00a0\u00a0\u00a0\"world\",\u00a0\u00a0\u00a0\u00a0Replacer.ReplaceValue,\u00a0\u00a0\u00a0\u00a0{\"B\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"hello\"],\u00a0\u00a0\u00a0\u00a0[A = 2, B = \"world\"],\u00a0\u00a0\u00a0\u00a0[A = 3, B = \"goodbyes\"]})Example 2Replace the text \"ur\" with \"or\" in column B, matching any part of the value.UsagePower Query MTable.ReplaceValue(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"hello\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = 2, B = \"wurld\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"ur\",\u00a0\u00a0\u00a0\u00a0\"or\",\u00a0\u00a0\u00a0\u00a0Replacer.ReplaceText,\u00a0\u00a0\u00a0\u00a0{\"B\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"hello\"],\u00a0\u00a0\u00a0\u00a0[A = 2, B = \"world\"]})Example 3Anonymize the names of US employees.UsagePower Query MTable.ReplaceValue(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Cindy\", Country = \"US\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Country = \"CA\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each if [Country] = \"US\" then [Name] else false,\u00a0\u00a0\u00a0\u00a0each Text.Repeat(\"*\", Text.Length([Name])),\u00a0\u00a0\u00a0\u00a0Replacer.ReplaceValue,\u00a0\u00a0\u00a0\u00a0{\"Name\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Name = \"*****\", Country = \"US\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Country = \"CA\"]})Example 4Anonymize all columns of US employees.UsagePower Query MTable.ReplaceValue(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Cindy\", Country = \"US\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Country = \"CA\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each [Country] = \"US\",\u00a0\u00a0\u00a0\u00a0\"?\",\u00a0\u00a0\u00a0\u00a0(currentValue, isUS, replacementValue) =>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if isUS then\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Text.Repeat(replacementValue, Text.Length(currentValue))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentValue,\u00a0\u00a0\u00a0\u00a0{\"Name\", \"Country\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Name = \"?????\", Country = \"??\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\", Country = \"CA\"]})",
                    "pages": []
                },
                {
                    "title": "Table.ReverseRows",
                    "Syntax": "Table.ReverseRows(table as table) as table",
                    "About": "Returns a table with the rows from the input table in reverse order.",
                    "Explain": "Reverse the rows in the table.UsagePower Query MTable.ReverseRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}))OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.RowCount",
                    "Syntax": "Table.RowCount(table as table) as number",
                    "About": "Returns the number of rows in the table.",
                    "Explain": "Find the number of rows in the table.UsagePower Query MTable.RowCount(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}))Output3",
                    "pages": []
                },
                {
                    "title": "Table.Schema",
                    "Syntax": "Table.Schema(table as table) as table",
                    "About": "Returns a table describing the columns of table.Each row in the table describes the properties of a column of table:",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.SelectColumns",
                    "Syntax": "Table.SelectColumns(table as table, columns as any, optional missingField as nullable number) as table",
                    "About": "Returns the table with only the specified columns.table: The provided table.columns: The list of columns from the table table to return. Columns in the returned table are in the order listed in columns.missingField: (Optional) What to do if the column does not exist. Example: MissingField.UseNull or MissingField.Ignore.",
                    "Explain": "Example 1Only include column [Name].UsagePower Query MTable.SelectColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0\"Name\")OutputPower Query MTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Name = \"Bob\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Jim\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Paul\"],\u00a0\u00a0\u00a0\u00a0[Name = \"Ringo\"]})Example 2Only include columns [CustomerID] and [Name].UsagePower Query MTable.SelectColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"Name\"})OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\"]})Example 3If the included column does not exist, the default result is an error.UsagePower Query MTable.SelectColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0\"NewColumn\")Output[Expression.Error] The field 'NewColumn' of the record wasn't found.Example 4If the included column does not exist, option MissingField.UseNull creates a column of null values.UsagePower Query MTable.SelectColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"NewColumn\"},\u00a0\u00a0\u00a0\u00a0MissingField.UseNull)OutputTable.FromRecords({[CustomerID = 1, NewColumn = null]})",
                    "pages": []
                },
                {
                    "title": "Table.SelectRows",
                    "Syntax": "Table.SelectRows(table as table, condition as function) as table",
                    "About": "Returns a table of rows from the table, that matches the selection condition.",
                    "Explain": "Example 1Select the rows in the table where the values in [CustomerID] column are greater than 2.UsagePower Query MTable.SelectRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each [CustomerID] > 2)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 2Select the rows in the table where the names do not contain a \"B\".UsagePower Query MTable.SelectRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each not Text.Contains([Name], \"B\"))OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})",
                    "pages": []
                },
                {
                    "title": "Table.SelectRowsWithErrors",
                    "Syntax": "Table.SelectRowsWithErrors(table as table, optional columns as nullable list) as table",
                    "About": "Returns a table with only those rows of the input table that contain an error in at least one of the cells. If a columns list is specified, then only the cells in the specified columns are inspected for errors.",
                    "Explain": "Select names of customers with errors in their rows.UsagePower Query MTable.SelectRowsWithErrors(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = ..., Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}))[Name]Output{\"Bob\"}",
                    "pages": []
                },
                {
                    "title": "Table.SingleRow",
                    "Syntax": "Table.SingleRow(table as table) as record",
                    "About": "Returns the single row in the one row table. If the table does not contain exactly one row, an error is raised.",
                    "Explain": "Return the single row in the table.UsagePower Query MTable.SingleRow(Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}))Output[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]",
                    "pages": []
                },
                {
                    "title": "Table.Skip",
                    "Syntax": "Table.Skip(table as table, optional countOrCondition as any) as table",
                    "About": "Returns a table that does not contain the first specified number of rows, countOrCondition, of the table table. The number of rows skipped depends on the optional parameter countOrCondition.If countOrCondition is omitted only the first row is skipped.If countOrCondition is a number, that many rows (starting at the top) will be skipped.If countOrCondition is a condition, the rows that meet the condition will be skipped until a row does not meet the condition.",
                    "Explain": "Example 1Skip the first row of the table.UsagePower Query MTable.Skip(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a01)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 2Skip the first two rows of the table.UsagePower Query MTable.Skip(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a02)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Ringo\", Phone = \"232-1550\"]})Example 3Skip the first rows where [Price] > 25 of the table.UsagePower Query MTable.Skip(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each [Price] > 25)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5],\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25],\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200],\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2],\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20],\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]})",
                    "pages": []
                },
                {
                    "title": "Table.Sort",
                    "Syntax": "Table.Sort(table as table, comparisonCriteria as any) as table",
                    "About": "Sorts the table using the list of one or more column names and optional comparisonCriteria in the form { { col1, comparisonCriteria }, {col2} }.",
                    "Explain": "Example 1Sort the table on column \"OrderID\".UsagePower Query MTable.Sort(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"OrderID\"})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5],\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25],\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200],\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2],\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20],\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]})Example 2Sort the table on column \"OrderID\" in descending order.UsagePower Query MTable.Sort(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"OrderID\", Order.Descending})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20],\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2],\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200],\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25],\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5],\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100]})Example 3Sort the table on column \"CustomerID\" then \"OrderID\", with \"CustomerID\" being in ascending order.UsagePower Query MTable.Sort(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100.0],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", Order.Ascending},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"OrderID\"\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[OrderID = 1, CustomerID = 1, Item = \"Fishing rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[OrderID = 2, CustomerID = 1, Item = \"1 lb. worms\", Price = 5],\u00a0\u00a0\u00a0\u00a0[OrderID = 6, CustomerID = 1, Item = \"Tackle box\", Price = 20],\u00a0\u00a0\u00a0\u00a0[OrderID = 3, CustomerID = 2, Item = \"Fishing net\", Price = 25],\u00a0\u00a0\u00a0\u00a0[OrderID = 4, CustomerID = 3, Item = \"Fish tazer\", Price = 200],\u00a0\u00a0\u00a0\u00a0[OrderID = 5, CustomerID = 3, Item = \"Bandaids\", Price = 2],\u00a0\u00a0\u00a0\u00a0[OrderID = 7, CustomerID = 5, Item = \"Bait\", Price = 3.25],\u00a0\u00a0\u00a0\u00a0[OrderID = 8, CustomerID = 5, Item = \"Fishing Rod\", Price = 100],\u00a0\u00a0\u00a0\u00a0[OrderID = 9, CustomerID = 6, Item = \"Bait\", Price = 3.25]})",
                    "pages": []
                },
                {
                    "title": "Table.Split",
                    "Syntax": "Table.Split(table as table, pageSize as number) as list",
                    "About": "Splits table into a list of tables where the first element of the list is a table containing the first pageSize rows from the source table, the next element of the list is a table containing the next pageSize rows from the source table, and so on.",
                    "Explain": "Split a table of five records into tables with two records each.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0Customers = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Cristina\", Phone = \"232-1550\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 5, Name = \"Anita\", Phone = \"530-1459\"]\u00a0\u00a0\u00a0\u00a0})in\u00a0\u00a0\u00a0\u00a0Table.Split(Customers, 2)Output{\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Cristina\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 5, Name = \"Anita\", Phone = \"530-1459\"]\u00a0\u00a0\u00a0\u00a0})}",
                    "pages": []
                },
                {
                    "title": "Table.SplitAt",
                    "Syntax": "Table.SplitAt(table as table, count as number) as list",
                    "About": "Returns a list containing two tables: a table with the first N rows of table (as specified by count) and a table containing the remaining rows of table. If the tables of the resulting list are enumerated exactly once and in order, the function will enumerate table only once.",
                    "Explain": "Return the first two rows of the table and the remaining rows of the table.UsagePower Query MTable.SplitAt(#table({\"a\", \"b\", \"c\"}, {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}), 2)Output{\u00a0\u00a0\u00a0\u00a0#table({\"a\", \"b\", \"c\"}, {{1, 2, 3}, {4, 5, 6}}),\u00a0\u00a0\u00a0\u00a0#table({\"a\", \"b\", \"c\"}, {{7, 8, 9}})}",
                    "pages": []
                },
                {
                    "title": "Table.SplitColumn",
                    "Syntax": "Table.SplitColumn(table as table, sourceColumn as text, splitter as function, optional columnNamesOrNumber as any, optional default as any, optional extraColumns as any) as table",
                    "About": "Splits the specified columns into a set of additional columns using the specified splitter function.",
                    "Explain": "Split the [Name] column at position of \"i\" into two columnsUsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0Customers = Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name = \"Cristina\", Phone = \"232-1550\"]\u00a0\u00a0\u00a0\u00a0})in\u00a0\u00a0\u00a0\u00a0Table.SplitColumn(Customers, \"Name\", Splitter.SplitTextByDelimiter(\"i\"), 2OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name.1 = \"Bob\", Name.2 = null, Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name.1 = \"J\", Name.2 = \"m\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name.1 = \"Paul\", Name.2 = null, Phone = \"543-7890\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 4, Name.1 = \"Cr\", Name.2 = \"st\", Phone = \"232-1550\"]})",
                    "pages": []
                },
                {
                    "title": "Table.StopFolding",
                    "Syntax": "Table.StopFolding(table as table) as table",
                    "About": "Prevents any downstream operations from being run against the original source of the data in table.",
                    "Explain": "Fetches data from a SQL table in a way that prevents any downstream operations from running as a query on the SQL server.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0Source = Sql.Database(\"SomeSQLServer\", \"MyDb\"),\u00a0\u00a0\u00a0\u00a0MyTable = Source{[Item=\"MyTable\"]}[Data],\u00a0\u00a0\u00a0\u00a0MyLocalTable = Table.StopFolding(dbo_MyTable)in\u00a0\u00a0\u00a0\u00a0MyLocalTableOutputtable",
                    "pages": []
                },
                {
                    "title": "Table.ToColumns",
                    "Syntax": "Table.ToColumns(table as table) as list",
                    "About": "Creates a list of nested lists from the table, table. Each list item is an inner list that contains the column values.",
                    "Explain": "Create a list of the column values from the table.UsagePower Query MTable.ToColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"]\u00a0\u00a0\u00a0\u00a0}))\u00a0Output{{1, 2}, {\"Bob\", \"Jim\"}, {\"123-4567\", \"987-6543\"}}",
                    "pages": []
                },
                {
                    "title": "Table.ToList",
                    "Syntax": "Table.ToList(table as table, optional combiner as nullable function) as list",
                    "About": "Converts a table into a list by applying the specified combining function to each row of values in the table.",
                    "Explain": "Combine the text of each row with a comma.UsagePower Query MTable.ToList(\u00a0\u00a0\u00a0\u00a0Table.FromRows({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{Number.ToText(1), \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{Number.ToText(2), \"Jim\", \"987-6543\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{Number.ToText(3), \"Paul\", \"543-7890\"}\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0Combiner.CombineTextByDelimiter(\",\"))Output{\"1,Bob,123-4567\", \"2,Jim,987-6543\", \"3,Paul,543-7890\"}",
                    "pages": []
                },
                {
                    "title": "Table.ToRecords",
                    "Syntax": "Table.ToRecords(table as table) as list",
                    "About": "Converts a table, table, to a list of records.",
                    "Explain": "Convert the table to a list of records.UsagePower Query MTable.ToRecords(\u00a0\u00a0\u00a0\u00a0Table.FromRows(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1, \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{2, \"Jim\", \"987-6543\"},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{3, \"Paul\", \"543-7890\"}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"CustomerID\", \"Name\", \"Phone\"}\u00a0\u00a0\u00a0\u00a0))Output{\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]}",
                    "pages": []
                },
                {
                    "title": "Table.ToRows",
                    "Syntax": "Table.ToRows(table as table) as list",
                    "About": "Creates a list of nested lists from the table, table. Each list item is an inner list that contains the row values.",
                    "Explain": "Create a list of the row values from the table.UsagePower Query MTable.ToRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 2, Name = \"Jim\", Phone = \"987-6543\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CustomerID = 3, Name = \"Paul\", Phone = \"543-7890\"]\u00a0\u00a0\u00a0\u00a0}))Output{\u00a0\u00a0\u00a0\u00a0{1, \"Bob\", \"123-4567\"},\u00a0\u00a0\u00a0\u00a0{2, \"Jim\", \"987-6543\"},\u00a0\u00a0\u00a0\u00a0{3, \"Paul\", \"543-7890\"}}",
                    "pages": []
                },
                {
                    "title": "Table.TransformColumnNames",
                    "Syntax": "Table.TransformColumnNames(table as table, nameGenerator as function, optional options as nullable record) as table",
                    "About": "Transforms column names by using the given nameGenerator function. Valid options:MaxLength specifies the maximum length of new column names. If the given function results with a longer column name, the long name will be trimmed.Comparer is used to control the comparison while generating new column names. Comparers can be used to provide case-insensitive or culture and locale-aware comparisons.The following built-in comparers are available in the formula language:Comparer.Ordinal: Used to perform an exact ordinal comparisonComparer.OrdinalIgnoreCase: Used to perform an exact ordinal case-insensitive comparisonComparer.FromCulture: Used to perform a culture-aware comparison",
                    "Explain": "Example 1Remove the #(tab) character from column namesUsagePower Query MTable.TransformColumnNames(Table.FromRecords({[#\"Col#(tab)umn\" = 1]}), Text.Clean)OutputTable.FromRecords({[Column = 1]})Example 2Transform column names to generate case-insensitive names of length 6.UsagePower Query MTable.TransformColumnNames(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({[ColumnNum = 1, cOlumnnum = 2, coLumnNUM = 3]}),\u00a0\u00a0\u00a0\u00a0Text.Clean,\u00a0\u00a0\u00a0\u00a0[MaxLength = 6, Comparer = Comparer.OrdinalIgnoreCase])OutputTable.FromRecords({[Column = 1, cOlum1 = 2, coLum2 = 3]})",
                    "pages": []
                },
                {
                    "title": "Table.TransformColumns",
                    "Syntax": "Table.TransformColumns(table as table, transformOperations as list, optional defaultTransformation as nullable function, optional missingField as nullable number) as table",
                    "About": "Transforms table by applying each column operation listed in transformOperations (where the format is { column name, transformation } or { column name, transformation, new column type }). If a defaultTransformation is specified, it will be applied to all columns not listed in transformOperations. If a column listed in transformOperations doesn't exist, an exception is thrown unless the optional parameter missingField specifies an alternative (for example, MissingField.UseNull or MissingField.Ignore).",
                    "Explain": "Example 1Convert the text values in column [A] to number values, and the number values in column [B] to text values.UsagePower Query MTable.TransformColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"1\", B = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"5\", B = 10]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"A\", Number.FromText},\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"B\", Text.From}\u00a0\u00a0\u00a0\u00a0})OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"2\"],\u00a0\u00a0\u00a0\u00a0[A = 5, B = \"10\"]})Example 2Convert the number values in missing column [X] to text values, ignoring columns which don't exist.UsagePower Query MTable.TransformColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"1\", B = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"5\", B = 10]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"X\", Number.FromText},\u00a0\u00a0\u00a0\u00a0null,\u00a0\u00a0\u00a0\u00a0MissingField.Ignore)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = \"1\", B = 2],\u00a0\u00a0\u00a0\u00a0[A = \"5\", B = 10]})Example 3Convert the number values in missing column [X] to text values, defaulting to null on columns which don't exist.UsagePower Query MTable.TransformColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"1\", B = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"5\", B = 10]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"X\", Number.FromText},\u00a0\u00a0\u00a0\u00a0null,\u00a0\u00a0\u00a0\u00a0MissingField.UseNull)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = \"1\", B = 2, X = null],\u00a0\u00a0\u00a0\u00a0[A = \"5\", B = 10, X = null]})Example 4Increment the number values in column [B] and convert them to text values, and convert all other columns to numbers.UsagePower Query MTable.TransformColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"1\", B = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[A = \"5\", B = 10]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"B\", each Text.From(_ + 1), type text},\u00a0\u00a0\u00a0\u00a0Number.FromText)OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[A = 1, B = \"3\"],\u00a0\u00a0\u00a0\u00a0[A = 5, B = \"11\"]})",
                    "pages": []
                },
                {
                    "title": "Table.TransformColumnTypes",
                    "Syntax": "Table.TransformColumnTypes(table as table, typeTransformations as list, optional culture as nullable text) as table",
                    "About": "Returns a table from the input table by applying the transform operation to the columns specified in the parameter typeTransformations (where format is { column name, type name}), using the specified culture in the optional parameter culture (for example, \"en-US\"). If the column doesn't exist, an exception is thrown.",
                    "Explain": "Transform the number values in column [a] to text values from the table ({[a = 1, b = 2], [a = 3, b = 4]}).UsagePower Query MTable.TransformColumnTypes(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1, b = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3, b = 4]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"a\", type text},\u00a0\u00a0\u00a0\u00a0\"en-US\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[a = \"1\", b = 2],\u00a0\u00a0\u00a0\u00a0[a = \"3\", b = 4]})",
                    "pages": []
                },
                {
                    "title": "Table.TransformRows",
                    "Syntax": "Table.TransformRows(table as table, transform as function) as list",
                    "About": "Creates a list by applying the transform operation to each row in table.",
                    "Explain": "Example 1Transform the rows of a table into a list of numbers.UsagePower Query MTable.TransformRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 5]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0each [a])Output{1, 2, 3, 4, 5}Example 2Transform the rows of a numeric table into textual records.UsagePower Query MTable.TransformRows(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 1],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 2],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 4],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a = 5]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0(row) as record => [B = Number.ToText(row[a])])Output{\u00a0\u00a0\u00a0\u00a0[B = \"1\"],\u00a0\u00a0\u00a0\u00a0[B = \"2\"],\u00a0\u00a0\u00a0\u00a0[B = \"3\"],\u00a0\u00a0\u00a0\u00a0[B = \"4\"],\u00a0\u00a0\u00a0\u00a0[B = \"5\"]}",
                    "pages": []
                },
                {
                    "title": "Table.Transpose",
                    "Syntax": "Table.Transpose(table as table, optional columns as any) as table",
                    "About": "Returns a table with columns converted to rows and rows converted to columns from the input table.",
                    "Explain": "Make the rows of the table of name-value pairs into columns.UsagePower Query MTable.Transpose(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Full Name\", Value = \"Fred\"],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Age\", Value = 42],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Name = \"Country\", Value = \"UK\"]\u00a0\u00a0\u00a0\u00a0}))OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[Column1 = \"Full Name\", Column2 = \"Age\", Column3 = \"Country\"],\u00a0\u00a0\u00a0\u00a0[Column1 = \"Fred\", Column2 = 42, Column3 = \"UK\"]})",
                    "pages": []
                },
                {
                    "title": "Table.Unpivot",
                    "Syntax": "Table.Unpivot(table as table, pivotColumns as list, attributeColumn as text, valueColumn as text) as table",
                    "About": "Translates a set of columns in a table into attribute-value pairs, combined with the rest of the values in each row.",
                    "Explain": "Take the columns \"a\", \"b\", and \"c\" in the table ({[ key = \"x\", a = 1, b = null, c = 3 ], [ key = \"y\", a = 2, b = 4, c = null ]}) and unpivot them into attribute-value pairs.UsagePower Query MTable.Unpivot(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"x\", a = 1, b = null, c = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"y\", a = 2, b = 4, c = null]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"a\", \"b\", \"c\"},\u00a0\u00a0\u00a0\u00a0\"attribute\",\u00a0\u00a0\u00a0\u00a0\"value\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"a\", value = 1],\u00a0\u00a0\u00a0\u00a0[key = \"x\", attribute = \"c\", value = 3],\u00a0\u00a0\u00a0\u00a0[key = \"y\", attribute = \"a\", value = 2],\u00a0\u00a0\u00a0\u00a0[key = \"y\", attribute = \"b\", value = 4]})",
                    "pages": []
                },
                {
                    "title": "Table.UnpivotOtherColumns",
                    "Syntax": "Table.UnpivotOtherColumns(table as table, pivotColumns as list, attributeColumn as text, valueColumn as text) as table",
                    "About": "Translates all columns other than a specified set into attribute-value pairs, combined with the rest of the values in each row.",
                    "Explain": "Translates all columns other than a specified set into attribute-value pairs, combined with the rest of the values in each row.UsagePower Query MTable.UnpivotOtherColumns(\u00a0\u00a0\u00a0\u00a0Table.FromRecords({\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"key1\", attribute1 = 1, attribute2 = 2, attribute3 = 3],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[key = \"key2\", attribute1 = 4, attribute2 = 5, attribute3 = 6]\u00a0\u00a0\u00a0\u00a0}),\u00a0\u00a0\u00a0\u00a0{\"key\"},\u00a0\u00a0\u00a0\u00a0\"column1\",\u00a0\u00a0\u00a0\u00a0\"column2\")OutputTable.FromRecords({\u00a0\u00a0\u00a0\u00a0[key = \"key1\", column1 = \"attribute1\", column2 = 1],\u00a0\u00a0\u00a0\u00a0[key = \"key1\", column1 = \"attribute2\", column2 = 2],\u00a0\u00a0\u00a0\u00a0[key = \"key1\", column1 = \"attribute3\", column2 = 3],\u00a0\u00a0\u00a0\u00a0[key = \"key2\", column1 = \"attribute1\", column2 = 4],\u00a0\u00a0\u00a0\u00a0[key = \"key2\", column1 = \"attribute2\", column2 = 5],\u00a0\u00a0\u00a0\u00a0[key = \"key2\", column1 = \"attribute3\", column2 = 6]})",
                    "pages": []
                },
                {
                    "title": "Table.View",
                    "Syntax": "Table.View(table as nullable table, handlers as record) as table",
                    "About": "Returns a view of table where the functions specified in handlers are used in lieu of the default behavior of an operation when the operation is applied to the view.If table is provided, all handler functions are optional. If table isn't provided, the GetType and GetRows handler functions are required. If a handler function isn't specified for an operation, the default behavior of the operation is applied to table instead (except in the case of GetExpression).Handler functions must return a value that is semantically equivalent to the result of applying the operation against table (or the resulting view in the case of GetExpression).If a handler function raises an error, the default behavior of the operation is applied to the view.Table.View can be used to implement folding to a data source\u2014the translation of M queries into source-specific queries (for example, to create T-SQL statements from M queries).Refer to the published Power Query custom connector documentation for a more complete description of Table.View.",
                    "Explain": "Create a basic view that doesn't require accessing the rows in order to determine the type or the row count.UsagePower Query MTable.View(\u00a0\u00a0\u00a0\u00a0null,\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetType = () => type table [CustomerID = number, Name = text, Phone = nullable text],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetRows = () => Table.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]}),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetRowCount = () => 1\u00a0\u00a0\u00a0\u00a0])OutputTable.FromRecords({[CustomerID = 1, Name = \"Bob\", Phone = \"123-4567\"]})",
                    "pages": []
                },
                {
                    "title": "Table.ViewError",
                    "Syntax": "Table.ViewError(errorRecord as record) as record",
                    "About": "Creates a modified error record from errorRecord which won't trigger a fallback when thrown by a handler defined on a view (via Table.View).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Table.ViewFunction",
                    "Syntax": "Table.ViewFunction(function as function) as function",
                    "About": "Creates a view function based on function that can be handled in a view created by Table.View.The OnInvoke handler of Table.View can be used to define a handler for the view function.As with the handlers for built-in operations, if no OnInvoke handler is specified, or if it does not handle the view function, or if an error is raised by the handler, function is applied on top of the view.Refer to the published Power Query custom connector documentation for a more complete description of Table.View and custom view functions.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Tables.GetRelationships",
                    "Syntax": "Tables.GetRelationships(tables as table, optional dataColumn as nullable text) as table",
                    "About": "Gets the relationships among a set of tables. The set tables is assumed to have a structure similar to that of a navigation table. The column defined by dataColumn contains the actual data tables.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "#table",
                    "Syntax": "#table(columns as any, rows as any) as any",
                    "About": "Creates a table value from columns and rows. The columns value can be a list of column names, a table type, a number of columns, or null. The rows value is a list of lists, where each element contains the column values for a single row.",
                    "Explain": "Example 1Create an empty table.UsagePower Query M#table({}, {})Output#table({}, {})Example 2Create a table by inferring the number of columns from the first row.UsagePower Query M#table(null, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Output#table({\"Column1\", \"Column2\"}, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Example 3Create a table by specifying the number of columns.UsagePower Query M#table(2, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Output#table({\"Column1\", \"Column2\"}, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Example 4Create a table by providing a list of column names.UsagePower Query M#table({\"Name\", \"Score\"}, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Output#table({\"Name\", \"Score\"}, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Example 5Create a table with an explicit type.UsagePower Query M#table(type table [Name = text, Score = number], {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Output#table(type table [Name = text, Score = number], {{\"Betty\", 90.3}, {\"Carl\", 89.5}})",
                    "pages": []
                }
            ]
        },
        {
            "title": "Text functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Character.FromNumber",
                    "Syntax": "Character.FromNumber(number as nullable number) as nullable text",
                    "About": "Returns the character equivalent of the number.",
                    "Explain": "Given the number 9, find the character value.UsagePower Query MCharacter.FromNumber(9)Output\"#(tab)\"",
                    "pages": []
                },
                {
                    "title": "Character.ToNumber",
                    "Syntax": "Character.ToNumber(character as nullable text) as nullable number",
                    "About": "Returns the number equivalent of the character, character.",
                    "Explain": "Given the character \"#(tab)\" 9, find the number value.UsagePower Query MCharacter.ToNumber(\"#(tab)\")Output9",
                    "pages": []
                },
                {
                    "title": "Guid.From",
                    "Syntax": "Guid.From(value as nullable text) as nullable text",
                    "About": "Returns a Guid.Type value from the given value. If the given value is null, Guid.From returns null. A check will be performed to determine if the given value is in an acceptable format. Acceptable formats provided in the examples.",
                    "Explain": "Example 1The Guid can be provided as 32 contiguous hexadecimal digits.UsagePower Query MGuid.From(\"05FE1DADC8C24F3BA4C2D194116B4967\")Output\"05fe1dad-c8c2-4f3b-a4c2-d194116b4967\"Example 2The Guid can be provided as 32 hexadecimal digits separated by hyphens into blocks of 8-4-4-4-12.UsagePower Query MGuid.From(\"05FE1DAD-C8C2-4F3B-A4C2-D194116B4967\")Output\"05fe1dad-c8c2-4f3b-a4c2-d194116b4967\"Example 3The Guid can be provided as 32 hexadecimal digits separated by hyphens and enclosed in braces.UsagePower Query MGuid.From(\"{05FE1DAD-C8C2-4F3B-A4C2-D194116B4967}\")Output\"05fe1dad-c8c2-4f3b-a4c2-d194116b4967\"Example 4The Guid can be provided as 32 hexadecimal digits separated by hyphens and enclosed by parentheses.UsagePower Query MGuid.From(\"(05FE1DAD-C8C2-4F3B-A4C2-D194116B4967)\")Output\"05fe1dad-c8c2-4f3b-a4c2-d194116b4967\"",
                    "pages": []
                },
                {
                    "title": "Json.FromValue",
                    "Syntax": "Json.FromValue(value as any, optional encoding as nullable number) as binary",
                    "About": "Produces a JSON representation of a given value value with a text encoding specified by encoding. If encoding is omitted, UTF8 is used. Values are represented as follows:Null, text and logical values are represented as the corresponding JSON typesNumbers are represented as numbers in JSON, except that #infinity, -#infinity and #null are converted to nullLists are represented as JSON arraysRecords are represnted as JSON objectsTables are represented as an array of objectsDates, times, datetimes, datetimezones and durations are represented as ISO-8601 textBinary values are represented as base-64 encoded textTypes and functions produce an error",
                    "Explain": "Convert a complex value to JSON.UsagePower Query MText.FromBinary(Json.FromValue([A = {1, true, \"3\"}, B = #date(2012, 3, 25)]))Output\"{\"\"A\"\":[1,true,\"\"3\"\"],\"\"B\"\":\"\"2012-03-25\"\"}\"",
                    "pages": []
                },
                {
                    "title": "Text.AfterDelimiter",
                    "Syntax": "Text.AfterDelimiter(text as nullable text, delimiter as text, optional index as any) as any",
                    "About": "Returns the portion of text after the specified delimiter. An optional numeric index indicates which occurrence of the delimiter should be considered. An optional list index indicates which occurrence of the delimiter should be considered, as well as whether indexing should be done from the start or end of the input.",
                    "Explain": "Example 1Get the portion of \"111-222-333\" after the (first) hyphen.UsagePower Query MText.AfterDelimiter(\"111-222-333\", \"-\")Output\"222-333\"Example 2Get the portion of \"111-222-333\" after the second hyphen.UsagePower Query MText.AfterDelimiter(\"111-222-333\", \"-\", 1)Output\"333\"Example 3Get the portion of \"111-222-333\" after the second hyphen from the end.UsagePower Query MText.AfterDelimiter(\"111-222-333\", \"-\", {1, RelativePosition.FromEnd})Output\"222-333\"",
                    "pages": []
                },
                {
                    "title": "Text.At",
                    "Syntax": "Text.At(text as nullable text, index as number) as nullable text",
                    "About": "Returns the character in the text value, text at position index. The first character in the text is at position 0.",
                    "Explain": "Find the character at position 4 in string \"Hello, World\".UsagePower Query MText.At(\"Hello, World\", 4)Output\"o\"",
                    "pages": []
                },
                {
                    "title": "Text.BeforeDelimiter",
                    "Syntax": "Text.BeforeDelimiter(text as nullable text, delimiter as text, optional index as any) as any",
                    "About": "Returns the portion of text before the specified delimiter. An optional numeric index indicates which occurrence of the delimiter should be considered. An optional list index indicates which occurrence of the delimiter should be considered, as well as whether indexing should be done from the start or end of the input.",
                    "Explain": "Example 1Get the portion of \"111-222-333\" before the (first) hyphen.UsagePower Query MText.BeforeDelimiter(\"111-222-333\", \"-\")Output\"111\"Example 2Get the portion of \"111-222-333\" before the second hyphen.UsagePower Query MText.BeforeDelimiter(\"111-222-333\", \"-\", 1)Output\"111-222\"Example 3Get the portion of \"111-222-333\" before the second hyphen from the end.UsagePower Query MText.BeforeDelimiter(\"111-222-333\", \"-\", {1, RelativePosition.FromEnd})Output\"111\"",
                    "pages": []
                },
                {
                    "title": "Text.BetweenDelimiters",
                    "Syntax": "Text.BetweenDelimiters(text as nullable text, startDelimiter as text, endDelimiter as text, optional startIndex as any, optional endIndex as any) as any",
                    "About": "Returns the portion of text between the specified startDelimiter and endDelimiter. An optional numeric startIndex indicates which occurrence of the startDelimiter should be considered. An optional list startIndex indicates which occurrence of the startDelimiter should be considered, as well as whether indexing should be done from the start or end of the input. The endIndex is similar, except that indexing is done relative to the startIndex.",
                    "Explain": "Example 1Get the portion of \"111 (222) 333 (444)\" between the (first) open parenthesis and the (first) closed parenthesis that follows it.UsagePower Query MText.BetweenDelimiters(\"111 (222) 333 (444)\", \"(\", \")\")Output\"222\"Example 2Get the portion of \"111 (222) 333 (444)\" between the second open parenthesis and the first closed parenthesis that follows it.UsagePower Query MText.BetweenDelimiters(\"111 (222) 333 (444)\", \"(\", \")\", 1, 0)Output\"444\"Example 3Get the portion of \"111 (222) 333 (444)\" between the second open parenthesis from the end and the second closed parenthesis that follows it.UsagePower Query MText.BetweenDelimiters(\"111 (222) 333 (444)\", \"(\", \")\", {1, RelativePosition.FromEnd}, {1, RelativePosition.FromStart})Output\"222) 333 (444\"",
                    "pages": []
                },
                {
                    "title": "Text.Clean",
                    "Syntax": "Text.Clean(text as nullable text) as nullable text",
                    "About": "Returns a text value with all control characters of text removed.",
                    "Explain": "Remove line feeds and other control characters from a text value.UsagePower Query MText.Clean(\"ABC#(lf)D\")Output\"ABCD\"",
                    "pages": []
                },
                {
                    "title": "Text.Combine",
                    "Syntax": "Text.Combine(texts as list, optional separator as nullable text) as text",
                    "About": "Returns the result of combining the list of text values, texts, into a single text value. Any null values present in texts are ignored. An optional separator used in the final combined text can be specified.",
                    "Explain": "Example 1Combine text values \"Seattle\" and \"WA\".UsagePower Query MText.Combine({\"Seattle\", \"WA\"})Output\"SeattleWA\"Example 2Combine text values \"Seattle\" and \"WA\", separated by a comma and a space.UsagePower Query MText.Combine({\"Seattle\", \"WA\"}, \", \")Output\"Seattle, WA\"Example 3Combine the values \"Seattle\", null, and \"WA\", separated by a comma and a space. (Note that the null is ignored.)UsagePower Query MText.Combine({\"Seattle\", null, \"WA\"}, \", \")Output\"Seattle, WA\"",
                    "pages": []
                },
                {
                    "title": "Text.Contains",
                    "Syntax": "Text.Contains(text as nullable text, substring as text, optional comparer as nullable function) as nullable logical",
                    "About": "Detects whether text contains the value substring. Returns true if the value is found. This function doesn't support wildcards or regular expressions.The optional argument comparer can be used to specify case-insensitive or culture and locale-aware comparisons. The following built-in comparers are available in the formula language:Comparer.Ordinal: Used to perform a case-sensitive ordinal comparisonComparer.OrdinalIgnoreCase: Used to perform a case-insensitive ordinal comparisonComparer.FromCulture: Used to perform a culture-aware comparison",
                    "Explain": "Example 1Find if the text \"Hello World\" contains \"Hello\".UsagePower Query MText.Contains(\"Hello World\", \"Hello\")OutputtrueExample 2Find if the text \"Hello World\" contains \"hello\".UsagePower Query MText.Contains(\"Hello World\", \"hello\")OutputfalseExample 3Find if the text \"Hello World\" contains \"hello\", using a case-insensitive comparer.UsagePower Query MText.Contains(\"Hello World\", \"hello\", Comparer.OrdinalIgnoreCase)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Text.End",
                    "Syntax": "Text.End(text as nullable text, count as number) as nullable text",
                    "About": "Returns a text value that is the last count characters of the text value text.",
                    "Explain": "Get the last 5 characters of the text \"Hello, World\".UsagePower Query MText.End(\"Hello, World\", 5)Output\"World\"",
                    "pages": []
                },
                {
                    "title": "Text.EndsWith",
                    "Syntax": "Text.EndsWith(text as nullable text, substring as text, optional comparer as nullable function) as nullable logical",
                    "About": "Indicates whether the given text, text, ends with the specified value, substring. The indication is case sensitive.comparer is a Comparer which is used to control the comparison. Comparers can be used to provide case-insensitive or culture and locale-aware comparisons.The following built-in comparers are available in the formula language:Comparer.Ordinal: Used to perform an exact ordinal comparisonComparer.OrdinalIgnoreCase: Used to perform an exact ordinal case-insensitive comparisonComparer.FromCulture: Used to perform a culture-aware comparison",
                    "Explain": "Example 1Check if \"Hello, World\" ends with \"world\".UsagePower Query MText.EndsWith(\"Hello, World\", \"world\")OutputfalseExample 2Check if \"Hello, World\" ends with \"World\".UsagePower Query MText.EndsWith(\"Hello, World\", \"World\")Outputtrue",
                    "pages": []
                },
                {
                    "title": "Text.Format",
                    "Syntax": "Text.Format(formatString as text, arguments as any, optional culture as nullable text) as text",
                    "About": "Returns formatted text that is created by applying arguments from a list or record to a format string formatString. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Example 1Format a list of numbers.UsagePower Query MText.Format(\"#{0}, #{1}, and #{2}.\", {17, 7, 22})Output\"17, 7, and 22.\"Example 2Format different data types from a record according to United States English culture.UsagePower Query MText.Format(\u00a0\u00a0\u00a0\u00a0\"The time for the #[distance] km run held in #[city] on #[date] was #[duration].\",\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0city = \"Seattle\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0date = #date(2015, 3, 10),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0duration = #duration(0, 0, 54, 40),\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distance = 10\u00a0\u00a0\u00a0\u00a0],\u00a0\u00a0\u00a0\u00a0\"en-US\")Output\"The time for the 10 km run held in Seattle on 3/10/2015 was 00:54:40.\"",
                    "pages": []
                },
                {
                    "title": "Text.From",
                    "Syntax": "Text.From(value as any, optional culture as nullable text) as nullable text",
                    "About": "Returns the text representation of value. The value can be a number, date, time, datetime, datetimezone, logical, duration or binary value. If the given value is null, Text.From returns null. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Create a text value from the number 3.UsagePower Query MText.From(3)Output\"3\"",
                    "pages": []
                },
                {
                    "title": "Text.FromBinary",
                    "Syntax": "Text.FromBinary(binary as nullable binary, optional encoding as nullable number) as nullable text",
                    "About": "Decodes data, binary, from a binary value in to a text value, using encoding type.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Text.InferNumberType",
                    "Syntax": "Text.InferNumberType(text as text, optional culture as nullable text) as type",
                    "About": "Infers the granular number type (Int64.Type, Double.Type, and so on) of text. An error is raised if text is not a number. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Text.Insert",
                    "Syntax": "Text.Insert(text as nullable text, offset as number, newText as text) as nullable text",
                    "About": "Returns the result of inserting text value newText into the text value text at position offset. Positions start at number 0.",
                    "Explain": "Insert \"C\" between \"B\" and \"D\" in \"ABD\".UsagePower Query MText.Insert(\"ABD\", 2, \"C\")Output\"ABCD\"",
                    "pages": []
                },
                {
                    "title": "Text.Length",
                    "Syntax": "Text.Length(text as nullable text) as nullable number",
                    "About": "Returns the number of characters in the text text.",
                    "Explain": "Find how many characters are in the text \"Hello World\".UsagePower Query MText.Length(\"Hello World\")Output11",
                    "pages": []
                },
                {
                    "title": "Text.Lower",
                    "Syntax": "Text.Lower(text as nullable text, optional culture as nullable text) as nullable text",
                    "About": "Returns the result of converting all characters in text to lowercase. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the lowercase version of \"AbCd\".UsagePower Query MText.Lower(\"AbCd\")Output\"abcd\"",
                    "pages": []
                },
                {
                    "title": "Text.Middle",
                    "Syntax": "Text.Middle(text as nullable text, start as number, optional count as nullable number) as nullable text",
                    "About": "Returns count characters, or through the end of text; at the offset start.",
                    "Explain": "Example 1Find the substring from the text \"Hello World\" starting at index 6 spanning 5 characters.UsagePower Query MText.Middle(\"Hello World\", 6, 5)Output\"World\"Example 2Find the substring from the text \"Hello World\" starting at index 6 through the end.UsagePower Query MText.Middle(\"Hello World\", 6, 20)Output\"World\"",
                    "pages": []
                },
                {
                    "title": "Text.NewGuid",
                    "Syntax": "Text.NewGuid() as text",
                    "About": "Returns a new, random globally unique identifier (GUID).",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Text.PadEnd",
                    "Syntax": "Text.PadEnd(text as nullable text, count as number, optional character as nullable text) as nullable text",
                    "About": "Returns a text value padded to length count by inserting spaces at the end of the text value text. An optional character character can be used to specify the character used for padding. The default pad character is a space.",
                    "Explain": "Example 1Pad the end of a text value so it is 10 characters long.UsagePower Query MText.PadEnd(\"Name\", 10)Output\"Name\u00a0 \u00a0 \u00a0 \"Example 2Pad the end of a text value with \"|\" so it is 10 characters long.UsagePower Query MText.PadEnd(\"Name\", 10, \"|\")Output\"Name||||||\"",
                    "pages": []
                },
                {
                    "title": "Text.PadStart",
                    "Syntax": "Text.PadStart(text as nullable text, count as number, optional character as nullable text) as nullable text",
                    "About": "Returns a text value padded to length count by inserting spaces at the start of the text value text. An optional character character can be used to specify the character used for padding. The default pad character is a space.",
                    "Explain": "Example 1Pad the start of a text value so it is 10 characters long.UsagePower Query MText.PadStart(\"Name\", 10)Output\"\u00a0 \u00a0 \u00a0 Name\"Example 2Pad the start of a text value with \"|\" so it is 10 characters long.UsagePower Query MText.PadStart(\"Name\", 10, \"|\")Output\"||||||Name\"",
                    "pages": []
                },
                {
                    "title": "Text.PositionOf",
                    "Syntax": "Text.PositionOf(text as text, substring as text, optional occurrence as nullable number, optional comparer as nullable function) as any",
                    "About": "Returns the position of the specified occurrence of the text value substring found in text. An optional parameter occurrence may be used to specify which occurrence position to return (first occurrence by default). Returns -1 if substring was not found.comparer is a Comparer which is used to control the comparison. Comparers can be used to provide case-insensitive or culture and locale-aware comparisons.The following built-in comparers are available in the formula language:Comparer.Ordinal: Used to perform an exact ordinal comparisonComparer.OrdinalIgnoreCase: Used to perform an exact ordinal case-insensitive comparisonComparer.FromCulture: Used to perform a culture-aware comparison",
                    "Explain": "Example 1Get the position of the first occurrence of \"World\" in the text \"Hello, World! Hello, World!\".UsagePower Query MText.PositionOf(\"Hello, World! Hello, World!\", \"World\")Output7Example 2Get the position of last occurrence of \"World\" in \"Hello, World! Hello, World!\".UsagePower Query MText.PositionOf(\"Hello, World! Hello, World!\", \"World\", Occurrence.Last)Output21",
                    "pages": []
                },
                {
                    "title": "Text.PositionOfAny",
                    "Syntax": "Text.PositionOfAny(text as text, characters as list, optional occurrence as nullable number) as any",
                    "About": "Returns the first position of any character in the list characters that is found in text. An optional parameter occurrence may be used to specify which occurrence position to return.",
                    "Explain": "Example 1Find the first position of \"W\" or \"H\" in text \"Hello, World!\".UsagePower Query MText.PositionOfAny(\"Hello, World!\", {\"H\", \"W\"})Output0Example 2Find all the positions of \"W\" or \"H\" in text \"Hello, World!\".UsagePower Query MText.PositionOfAny(\"Hello, World!\", {\"H\", \"W\"}, Occurrence.All)Output{0, 7}",
                    "pages": []
                },
                {
                    "title": "Text.Proper",
                    "Syntax": "Text.Proper(text as nullable text, optional culture as nullable text) as nullable text",
                    "About": "Returns the result of capitalizing only the first letter of each word in text value text. All other letters are returned in lowercase. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Use Text.Proper on a simple sentence.UsagePower Query MText.Proper(\"the QUICK BrOWn fOx jUmPs oVER tHe LAzy DoG\")Output\"The Quick Brown Fox Jumps Over The Lazy Dog\"",
                    "pages": []
                },
                {
                    "title": "Text.Range",
                    "Syntax": "Text.Range(text as nullable text, offset as number, optional count as nullable number) as nullable text",
                    "About": "Returns the substring from the text text found at the offset offset. An optional parameter, count, can be included to specify how many characters to return. Throws an error if there aren't enough characters.",
                    "Explain": "Example 1Find the substring from the text \"Hello World\" starting at index 6.UsagePower Query MText.Range(\"Hello World\", 6)Output\"World\"Example 2Find the substring from the text \"Hello World Hello\" starting at index 6 spanning 5 characters.UsagePower Query MText.Range(\"Hello World Hello\", 6, 5)Output\"World\"",
                    "pages": []
                },
                {
                    "title": "Text.Remove",
                    "Syntax": "Text.Remove(text as nullable text, removeChars as any) as nullable text",
                    "About": "Removes all occurrences of a character or list of characters from a text value. The removeChars parameter can be a character value or a list of character values.",
                    "Explain": "Remove characters , and ; from the text value.UsagePower Query MText.Remove(\"a,b;c\", {\",\",\";\"})Output\"abc\"",
                    "pages": []
                },
                {
                    "title": "Text.RemoveRange",
                    "Syntax": "Text.RemoveRange(text as nullable text, offset as number, optional count as nullable number) as nullable text",
                    "About": "Returns a copy of the text value text with all the characters from position offset removed. An optional parameter, count can by used to specify the number of characters to remove. The default value of count is 1. Position values start at 0.",
                    "Explain": "Example 1Remove 1 character from the text value \"ABEFC\" at position 2.UsagePower Query MText.RemoveRange(\"ABEFC\", 2)Output\"ABFC\"Example 2Remove two characters from the text value \"ABEFC\" starting at position 2.UsagePower Query MText.RemoveRange(\"ABEFC\", 2, 2)Output\"ABC\"",
                    "pages": []
                },
                {
                    "title": "Text.Repeat",
                    "Syntax": "Text.Repeat(text as nullable text, count as number) as nullable text",
                    "About": "Returns a text value composed of the input text text repeated count times.",
                    "Explain": "Example 1Repeat the text \"a\" five times.UsagePower Query MText.Repeat(\"a\", 5)Output\"aaaaa\"Example 2Repeat the text \"helloworld\" three times.UsagePower Query MText.Repeat(\"helloworld.\", 3)Output\"helloworld.helloworld.helloworld.\"",
                    "pages": []
                },
                {
                    "title": "Text.Replace",
                    "Syntax": "Text.Replace(text as nullable text, old as text, new as text) as nullable text",
                    "About": "Returns the result of replacing all occurrences of text value old in text value text with text value new. This function is case sensitive.",
                    "Explain": "Replace every occurrence of \"the\" in a sentence with \"a\".UsagePower Query MText.Replace(\"the quick brown fox jumps over the lazy dog\", \"the\", \"a\")Output\"a quick brown fox jumps over a lazy dog\"",
                    "pages": []
                },
                {
                    "title": "Text.ReplaceRange",
                    "Syntax": "Text.ReplaceRange(text as nullable text, offset as number, count as number, newText as text) as nullable text",
                    "About": "Returns the result of removing a number of characters, count, from text value text beginning at position offset and then inserting the text value newText at the same position in text.",
                    "Explain": "Replace a single character at position 2 in text value \"ABGF\" with new text value \"CDE\".UsagePower Query MText.ReplaceRange(\"ABGF\", 2, 1, \"CDE\")Output\"ABCDEF\"",
                    "pages": []
                },
                {
                    "title": "Text.Reverse",
                    "Syntax": "Text.Reverse(text as nullable text) as nullable text",
                    "About": "Reverses the provided text.",
                    "Explain": "Reverse the text \"123\".UsagePower Query MText.Reverse(\"123\")Output\"321\"",
                    "pages": []
                },
                {
                    "title": "Text.Select",
                    "Syntax": "Text.Select(text as nullable text, selectChars as any) as nullable text",
                    "About": "Returns a copy of the text value text with all the characters not in selectChars removed.",
                    "Explain": "Select all characters in the range of 'a' to 'z' from the text value.UsagePower Query MText.Select(\"a,b;c\", {\"a\"..\"z\"})Output\"abc\"",
                    "pages": []
                },
                {
                    "title": "Text.Split",
                    "Syntax": "Text.Split(text as text, separator as text) as list",
                    "About": "Returns a list of text values resulting from the splitting a text value text based on the specified delimiter, separator.",
                    "Explain": "Create a list from the \"|\" delimited text value \"Name|Address|PhoneNumber\".UsagePower Query MText.Split(\"Name|Address|PhoneNumber\", \"|\")Output{\u00a0\u00a0\u00a0\u00a0\"Name\",\u00a0\u00a0\u00a0\u00a0\"Address\",\u00a0\u00a0\u00a0\u00a0\"PhoneNumber\"}",
                    "pages": []
                },
                {
                    "title": "Text.SplitAny",
                    "Syntax": "Text.SplitAny(text as text, separators as text) as list",
                    "About": "Returns a list of text values resulting from the splitting a text value text based on any character in the specified delimiter, separators.",
                    "Explain": "Create a list from the text value \"Jamie|Campbell|Admin|Adventure Works|www.adventure-works.com\".UsagePower Query MText.SplitAny(\"Jamie|Campbell|Admin|Adventure Works|www.adventure-works.com\", \"|\")Output{\u00a0\u00a0\u00a0\u00a0\"Jamie\",\u00a0\u00a0\u00a0\u00a0\"Campbell\",\u00a0\u00a0\u00a0\u00a0\"Admin\",\u00a0\u00a0\u00a0\u00a0\"Adventure Works\",\u00a0\u00a0\u00a0\u00a0\"www.adventure-works.com\"}",
                    "pages": []
                },
                {
                    "title": "Text.Start",
                    "Syntax": "Text.Start(text as nullable text, count as number) as nullable text",
                    "About": "Returns the first count characters of text as a text value.",
                    "Explain": "Get the first 5 characters of \"Hello, World\".UsagePower Query MText.Start(\"Hello, World\", 5)Output\"Hello\"",
                    "pages": []
                },
                {
                    "title": "Text.StartsWith",
                    "Syntax": "Text.StartsWith(text as nullable text, substring as text, optional comparer as nullable function) as nullable logical",
                    "About": "Returns true if text value text starts with text value substring.text: A text value which is to be searchedsubstring: A text value which is the substring to be searched for in substringcomparer: [Optional] A Comparer used for controlling the comparison. For example, Comparer.OrdinalIgnoreCase may be used to perform case-insensitive searchescomparer is a Comparer which is used to control the comparison. Comparers can be used to provide case-insensitive or culture and locale-aware comparisons.The following built-in comparers are available in the formula language:Comparer.Ordinal: Used to perform an exact ordinal comparisonComparer.OrdinalIgnoreCase: Used to perform an exact ordinal case-insensitive comparisonComparer.FromCulture: Used to perform a culture-aware comparison",
                    "Explain": "Example 1Check if the text \"Hello, World\" starts with the text \"hello\".UsagePower Query MText.StartsWith(\"Hello, World\", \"hello\")OutputfalseExample 2Check if the text \"Hello, World\" starts with the text \"Hello\".UsagePower Query MText.StartsWith(\"Hello, World\", \"Hello\")Outputtrue",
                    "pages": []
                },
                {
                    "title": "Text.ToBinary",
                    "Syntax": "Text.ToBinary(text as nullable text, optional encoding as nullable number, optional includeByteOrderMark as nullable logical) as nullable binary",
                    "About": "Encodes the given text value, text, into a binary value using the specified encoding.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Text.ToList",
                    "Syntax": "Text.ToList(text as text) as list",
                    "About": "Returns a list of character values from the given text value text.",
                    "Explain": "Create a list of character values from the text \"Hello World\".UsagePower Query MText.ToList(\"Hello World\")Output{\u00a0\u00a0\u00a0\"H\",\u00a0\u00a0\u00a0\u00a0\"e\",\u00a0\u00a0\u00a0\u00a0\"l\",\u00a0\u00a0\u00a0\u00a0\"l\",\u00a0\u00a0\u00a0\u00a0\"o\",\u00a0\u00a0\u00a0\u00a0\" \",\u00a0\u00a0\u00a0\u00a0\"W\",\u00a0\u00a0\u00a0\u00a0\"o\",\u00a0\u00a0\u00a0\u00a0\"r\",\u00a0\u00a0\u00a0\u00a0\"l\",\u00a0\u00a0\u00a0\u00a0\"d\"}",
                    "pages": []
                },
                {
                    "title": "Text.Trim",
                    "Syntax": "Text.Trim(text as nullable text, optional trim as any) as nullable text",
                    "About": "Returns the result of removing all leading and trailing whitespace from text value text.",
                    "Explain": "Remove leading and trailing whitespace from \" a b c d \".UsagePower Query MText.Trim(\" \u00a0 \u00a0 a b c d\u00a0 \u00a0 \")Output\"a b c d\"",
                    "pages": []
                },
                {
                    "title": "Text.TrimEnd",
                    "Syntax": "Text.TrimEnd(text as nullable text, optional trim as any) as nullable text",
                    "About": "Removes any occurrences of the characters specified in trimChars from the end of the original text value.",
                    "Explain": "Remove trailing whitespace from \" a b c d \".UsagePower Query MText.TrimEnd(\" \u00a0 \u00a0 a b c d\u00a0 \u00a0 \")Output\" \u00a0 \u00a0 a b c d\"",
                    "pages": []
                },
                {
                    "title": "Text.TrimStart",
                    "Syntax": "Text.TrimStart(text as nullable text, optional trim as any) as nullable text",
                    "About": "Removes any occurrences of the characters in trimChars from the start of the original text value.",
                    "Explain": "Remove leading whitespace from \" a b c d \".Usage**Power Query MText.TrimStart(\" \u00a0 a b c d\u00a0 \u00a0 \")Output\"a b c d\u00a0 \u00a0 \"",
                    "pages": []
                },
                {
                    "title": "Text.Upper",
                    "Syntax": "Text.Upper(text as nullable text, optional culture as nullable text) as nullable text",
                    "About": "Returns the result of converting all characters in text to uppercase. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": "Get the uppercase version of \"aBcD\".UsagePower Query MText.Upper(\"aBcD\")Output\"ABCD\"",
                    "pages": []
                }
            ]
        },
        {
            "title": "Time functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Time.EndOfHour",
                    "Syntax": "Time.EndOfHour(dateTime as any) as any",
                    "About": "Returns the end of the hour represented by dateTime, including fractional seconds. Time zone information is preserved.dateTime: A time, datetime, or datetimezone value from which the end of the hour is calculated.",
                    "Explain": "Example 1Get the end of the hour for 5/14/2011 05:00:00 PM.UsagePower Query MTime.EndOfHour(#datetime(2011, 5, 14, 17, 0, 0))Output#datetime(2011, 5, 14, 17, 59, 59.9999999)Example 2Get the end of the hour for 5/17/2011 05:00:00 PM -7:00.UsagePower Query MTime.EndOfHour(#datetimezone(2011, 5, 17, 5, 0, 0, -7, 0))Output#datetimezone(2011, 5, 17, 5, 59, 59.9999999, -7, 0)",
                    "pages": []
                },
                {
                    "title": "Time.From",
                    "Syntax": "Time.From(value as any, optional culture as nullable text) as nullable time",
                    "About": "Returns a time value from the given value. An optional culture may also be provided (for example, \"en-US\"). If the given value is null, Time.From returns null. If the given value is time, value is returned. Values of the following types can be converted to a time value:text: A time value from textual representation. Refer to Time.FromText for details.datetime: The time component of the value.datetimezone: The time component of the local datetime equivalent of value.number: A time equivalent to the number of fractional days expressed by value. If value is negative or greater or equal to 1, an error is returned.If value is of any other type, an error is returned.",
                    "Explain": "Example 1Convert 0.7575 to a time value.UsagePower Query MTime.From(0.7575)Output#time(18, 10, 48)Example 2Convert #datetime(1899, 12, 30, 06, 45, 12) to a time value.UsagePower Query MTime.From(#datetime(1899, 12, 30, 06, 45, 12))Output#time(06, 45, 12)",
                    "pages": []
                },
                {
                    "title": "Time.FromText",
                    "Syntax": "Time.FromText(text as nullable text, optional options as any) as nullable time",
                    "About": "Creates a time value from a textual representation, text. An optional record parameter, options, may be provided to specify additional properties. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in parsing the time using a best effort.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"tt\" is \"AM\" or \"PM\", while in \"ar-EG\" \"tt\" is \"\u0635\" or \"\u0645\". When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options may also be a text value. This has the same behavior as if options = [Format = null, Culture = options].",
                    "Explain": "Example 1Convert \"10:12:31am\" into a Time value.UsagePower Query MTime.FromText(\"10:12:31am\")Output#time(10, 12, 31)Example 2Convert \"1012\" into a Time value.UsagePower Query MTime.FromText(\"1012\")Output#time(10, 12, 00)Example 3Convert \"10\" into a Time value.UsagePower Query MTime.FromText(\"10\")Output#time(10, 00, 00)",
                    "pages": []
                },
                {
                    "title": "Time.Hour",
                    "Syntax": "Time.Hour(dateTime as any) as nullable number",
                    "About": "Returns the hour component of the provided time, datetime, or datetimezone value, dateTime.",
                    "Explain": "Find the hour in #datetime(2011, 12, 31, 9, 15, 36).UsagePower Query MTime.Hour(#datetime(2011, 12, 31, 9, 15, 36))Output9",
                    "pages": []
                },
                {
                    "title": "Time.Minute",
                    "Syntax": "Time.Minute(dateTime as any) as nullable number",
                    "About": "Returns the minute component of the provided time, datetime, or datetimezone value, dateTime.",
                    "Explain": "Find the minute in #datetime(2011, 12, 31, 9, 15, 36).UsagePower Query MTime.Minute(#datetime(2011, 12, 31, 9, 15, 36))Output15",
                    "pages": []
                },
                {
                    "title": "Time.Second",
                    "Syntax": "Time.Second(dateTime as any) as nullable number",
                    "About": "Returns the second component of the provided time, datetime, or datetimezone value, dateTime.",
                    "Explain": "Find the second value from a datetime value.UsagePower Query MTime.Second(#datetime(2011, 12, 31, 9, 15, 36.5))Output36.5",
                    "pages": []
                },
                {
                    "title": "Time.StartOfHour",
                    "Syntax": "Time.StartOfHour(dateTime as any) as any",
                    "About": "Returns the start of the hour represented by dateTime. dateTime must be a time, datetime or datetimezone value.",
                    "Explain": "Find the start of the hour for October 10th, 2011, 8:10:32AM.UsagePower Query MTime.StartOfHour(#datetime(2011, 10, 10, 8, 10, 32))Output#datetime(2011, 10, 10, 8, 0, 0)",
                    "pages": []
                },
                {
                    "title": "Time.ToRecord",
                    "Syntax": "Time.ToRecord(time as time) as record",
                    "About": "Returns a record containing the parts of the given Time value, time.time: A time value for from which the record of its parts is to be calculated.",
                    "Explain": "Convert the #time(11, 56, 2) value into a record containing Time values.UsagePower Query MTime.ToRecord(#time(11, 56, 2))Output[\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hour = 11,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Minute = 56,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Second = 2]",
                    "pages": []
                },
                {
                    "title": "Time.ToText",
                    "Syntax": "Time.ToText(time as nullable time, optional options as any, optional culture as nullable text) as nullable text",
                    "About": "Returns a textual representation of time. An optional record parameter, options, may be provided to specify additional properties. culture is only used for legacy workflows. The record can contain the following fields:Format: A text value indicating the format to use. For more details, go to https://go.microsoft.com/fwlink/?linkid=2180104 and https://go.microsoft.com/fwlink/?linkid=2180105. Omitting this field or providing null will result in formatting the date using the default defined by Culture.Culture: When Format is not null, Culture controls some format specifiers. For example, in \"en-US\" \"tt\" is \"AM\" or \"PM\", while in \"ar-EG\" \"tt\" is \"\u0635\" or \"\u0645\". When Format is null, Culture controls the default format to use. When Culture is null or omitted, Culture.Current is used.To support legacy workflows, options and culture may also be text values. This has the same behavior as if options = [Format = options, Culture = culture].",
                    "Explain": "Example 1Convert #time(01, 30, 25) into a text value. Result output may vary depending on current culture.UsagePower Query MTime.ToText(#time(11, 56, 2))Output\"11:56 AM\"Example 2Convert using a custom format and the German culture.UsagePower Query MTime.ToText(#time(11, 56, 2), [Format=\"hh:mm\", Culture=\"de-DE\"])Output\"11:56\"Example 3Convert using standard time format.UsagePower Query MTime.ToText(#time(11, 56, 2), [Format=\"T\", Culture=\"de-DE\"])Output\"11:56:02\"",
                    "pages": []
                },
                {
                    "title": "#time",
                    "Syntax": "#time(hour as number, minute as number, second as number) as time",
                    "About": "Creates a time value from numbers representing the hour, minute, and (fractional) second. Raises an error if these conditions are not true:0 \u2264 hour \u2264 240 \u2264 minute \u2264 590 \u2264 second < 60if hour is 24, then minute and second must be 0",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Type functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Type.AddTableKey",
                    "Syntax": "Type.AddTableKey(table as type, columns as list, isPrimary as logical) as type",
                    "About": "Adds a key to the given table type.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.ClosedRecord",
                    "Syntax": "Type.ClosedRecord(type as type) as type",
                    "About": "The given type must be a record type returns a closed version of the given record type (or the same type, if it is already closed)",
                    "Explain": "Create a closed version of type [ A = number,\u2026].UsagePower Query MType.ClosedRecord(type [A = number, ...])Outputtype [A = number]",
                    "pages": []
                },
                {
                    "title": "Type.Facets",
                    "Syntax": "Type.Facets(type as type) as record",
                    "About": "Returns a record containing the facets of type.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.ForFunction",
                    "Syntax": "Type.ForFunction(signature as record, min as number) as type",
                    "About": "Creates a function type from signature, a record of ReturnType and Parameters, and min, the minimum number of arguments required to invoke the function.",
                    "Explain": "Creates the type for a function that takes a number parameter named X and returns a number.UsagePower Query MType.ForFunction([ReturnType = type number, Parameters = [X = type number]], 1)Outputtype function (X as number) as number",
                    "pages": []
                },
                {
                    "title": "Type.ForRecord",
                    "Syntax": "Type.ForRecord(fields as record, open as logical) as type",
                    "About": "Returns a type that represents records with specific type constraints on fields.",
                    "Explain": "Dynamically generate a table type.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0columnNames = {\"Name\", \"Score\"},\u00a0\u00a0\u00a0\u00a0columnTypes = {type text, type number},\u00a0\u00a0\u00a0\u00a0rowColumnTypes = List.Transform(columnTypes, (t) => [Type = t, Optional = false]),\u00a0\u00a0\u00a0\u00a0rowType = Type.ForRecord(Record.FromList(rowColumnTypes, columnNames), false)in\u00a0\u00a0\u00a0\u00a0#table(type table rowType, {{\"Betty\", 90.3}, {\"Carl\", 89.5}})Output#table(\u00a0\u00a0\u00a0\u00a0type table [Name = text, Score = number],\u00a0\u00a0\u00a0\u00a0{{\"Betty\", 90.3}, {\"Carl\", 89.5}})",
                    "pages": []
                },
                {
                    "title": "Type.FunctionParameters",
                    "Syntax": "Type.FunctionParameters(type as type) as record",
                    "About": "Returns a record with field values set to the name of the parameters of type, and their values set to their corresponding types.",
                    "Explain": "Find the types of the parameters to the function (x as number, y as text).UsagePower Query MType.FunctionParameters(type function (x as number, y as text) as any)Output[x = type number, y = type text]",
                    "pages": []
                },
                {
                    "title": "Type.FunctionRequiredParameters",
                    "Syntax": "Type.FunctionRequiredParameters(type as type) as number",
                    "About": "Returns a number indicating the minimum number of parameters required to invoke the input type of function.",
                    "Explain": "Find the number of required parameters to the function (x as number, optional y as text).UsagePower Query MType.FunctionRequiredParameters(type function (x as number, optional y as text) as any)Output1",
                    "pages": []
                },
                {
                    "title": "Type.FunctionReturn",
                    "Syntax": "Type.FunctionReturn(type as type) as type",
                    "About": "Returns a type returned by a function type.",
                    "Explain": "Find the return type of () as any).UsagePower Query MType.FunctionReturn(type function () as any)Outputtype any",
                    "pages": []
                },
                {
                    "title": "Type.Is",
                    "Syntax": "Type.Is(type1 as type, type2 as type) as logical",
                    "About": "Determines if a value of type1 is always compatible with type2.",
                    "Explain": "Example 1Determine if a value of type number can always also be treated as type any.UsagePower Query MType.Is(type number, type any)OutputtrueExample 2Determine if a value of type any can always also be treated as type number.UsagePower Query MType.Is(type any, type number)Outputfalse",
                    "pages": []
                },
                {
                    "title": "Type.IsNullable",
                    "Syntax": "Type.IsNullable(type as type) as logical",
                    "About": "Returns true if a type is a nullable type; otherwise, false.",
                    "Explain": "Example 1Determine if number is nullable.UsagePower Query MType.IsNullable(type number)OutputfalseExample 2Determine if type nullable number is nullable.UsagePower Query MType.IsNullable(type nullable number)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Type.IsOpenRecord",
                    "Syntax": "Type.IsOpenRecord(type as type) as logical",
                    "About": "Returns a logical indicating whether a record type is open.",
                    "Explain": "Determine if the record type [ A = number, ...] is open.UsagePower Query MType.IsOpenRecord(type [A = number, ...])Outputtrue",
                    "pages": []
                },
                {
                    "title": "Type.ListItem",
                    "Syntax": "Type.ListItem(type as type) as type",
                    "About": "Returns an item type from a list type.",
                    "Explain": "Find item type from the list {number}.UsagePower Query MType.ListItem(type {number})Outputtype number",
                    "pages": []
                },
                {
                    "title": "Type.NonNullable",
                    "Syntax": "Type.NonNullable(type as type) as type",
                    "About": "Returns the non nullable type from the type.",
                    "Explain": "Return the non nullable type of type nullable number.UsagePower Query MType.NonNullable(type nullable number)Outputtype number",
                    "pages": []
                },
                {
                    "title": "Type.OpenRecord",
                    "Syntax": "Type.OpenRecord(type as type) as type",
                    "About": "Returns an opened version of the given record type (or the same type, if it is already opened).",
                    "Explain": "Create an opened version of type [ A = number].UsagePower Query MType.OpenRecord(type [A = number])Outputtype [A = number, ...]",
                    "pages": []
                },
                {
                    "title": "Type.RecordFields",
                    "Syntax": "Type.RecordFields(type as type) as record",
                    "About": "Returns a record describing the fields of a record type. Each field of the returned record type has a corresponding name and a value, in the form of a record [ Type = type, Optional = logical ].",
                    "Explain": "Find the name and value of the record [ A = number, optional B = any].UsagePower Query MType.RecordFields(type [A = number, optional B = any])Output[\u00a0\u00a0\u00a0\u00a0A = [Type = type number, Optional = false],\u00a0\u00a0\u00a0\u00a0B = [Type = type any, Optional = true]]",
                    "pages": []
                },
                {
                    "title": "Type.ReplaceFacets",
                    "Syntax": "Type.ReplaceFacets(type as type, facets as record) as type",
                    "About": "Replaces the facets of type with the facets contained in the record facets.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.ReplaceTableKeys",
                    "Syntax": "Type.ReplaceTableKeys(tableType as type, keys as list) as type",
                    "About": "Returns a new table type with all keys replaced by the specified list of keys.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.TableColumn",
                    "Syntax": "Type.TableColumn(tableType as type, column as text) as type",
                    "About": "Returns the type of the column column in the table type tableType.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.TableKeys",
                    "Syntax": "Type.TableKeys(tableType as type) as list",
                    "About": "Returns the possibly empty list of keys for the given table type.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.TableRow",
                    "Syntax": "Type.TableRow(table as type) as type",
                    "About": "Returns the row type of the specified table type. The result will always be a record type.",
                    "Explain": "Return the row type information for a simple table.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0tableRowType = Type.TableRow(Value.Type(#table({\"Column1\"}, {})))in\u00a0\u00a0\u00a0\u00a0Type.RecordFields(tableRowType)Output[Column1 = [Type = type any, Optional = false]]",
                    "pages": []
                },
                {
                    "title": "Type.TableSchema",
                    "Syntax": "Type.TableSchema(tableType as type) as table",
                    "About": "Returns a table describing the columns of tableType.Refer to the documentation for Table.Schema for a description of the resulting table.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Type.Union",
                    "Syntax": "Type.Union(types as list) as type",
                    "About": "Returns the union of the types in types.",
                    "Explain": null,
                    "pages": []
                }
            ]
        },
        {
            "title": "Uri functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "Uri functions",
                    "Syntax": "Uri.BuildQueryString(query as record) as text",
                    "About": "Assemble the record query into a URI query string, escaping characters as necessary.",
                    "Explain": "Encode a query string which contains some special characters.UsagePower Query MUri.BuildQueryString([a = \"1\", b = \"+$\"])Output\"a=1&b=%2B%24\"",
                    "pages": []
                },
                {
                    "title": "Uri.Combine",
                    "Syntax": "Uri.Combine(baseUri as text, relativeUri as text) as text",
                    "About": "Returns an absolute URI that is the combination of the input baseUri and relativeUri.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Uri.EscapeDataString",
                    "Syntax": "Uri.EscapeDataString(data as text) as text",
                    "About": "Encodes special characters in the input data according to the rules of RFC 3986.",
                    "Explain": "Encode the special characters in \"+money$\".UsagePower Query MUri.EscapeDataString(\"+money$\")Output\"%2Bmoney%24\"",
                    "pages": []
                },
                {
                    "title": "Uri.Parts",
                    "Syntax": "Uri.Parts(absoluteUri as text) as record",
                    "About": "Returns the parts of the input absoluteUri as a record, containing values such as Scheme, Host, Port, Path, Query, Fragment, UserName and Password.",
                    "Explain": "Example 1Find the parts of the absolute URI \"www.adventure-works.com\".UsagePower Query MUri.Parts(\"www.adventure-works.com\")Output[\u00a0\u00a0\u00a0\u00a0Scheme = \"http\",\u00a0\u00a0\u00a0\u00a0Host = \"www.adventure-works.com\",\u00a0\u00a0\u00a0\u00a0Port = 80,\u00a0\u00a0\u00a0\u00a0Path = \"/\",\u00a0\u00a0\u00a0\u00a0Query = [],\u00a0\u00a0\u00a0\u00a0Fragment = \"\",\u00a0\u00a0\u00a0\u00a0UserName = \"\",\u00a0\u00a0\u00a0\u00a0Password = \"\"]Example 2Decode a percent-encoded string.UsagePower Query Mlet\u00a0\u00a0\u00a0\u00a0UriUnescapeDataString = (data as text) as text => Uri.Parts(\"http://contoso?a=\" & data)[Query][a]in\u00a0\u00a0\u00a0\u00a0UriUnescapeDataString(\"%2Bmoney%24\")Output\"+money$\"",
                    "pages": []
                }
            ]
        },
        {
            "title": "Value functions",
            "Syntax": null,
            "About": null,
            "pages": [
                {
                    "title": "DirectQueryCapabilities.From",
                    "Syntax": "DirectQueryCapabilities.From(value as any) as table",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Embedded.Value",
                    "Syntax": "Embedded.Value(value as any, path as text) as any",
                    "About": "Accesses a value by name in an embedded mashup.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Excel.ShapeTable",
                    "Syntax": "Excel.ShapeTable(table as table, optional options as nullable record) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Graph.Nodes",
                    "Syntax": "Graph.Nodes(graph as record) as list",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Progress.DataSourceProgress",
                    "Syntax": "Progress.DataSourceProgress() as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SqlExpression.SchemaFrom",
                    "Syntax": "SqlExpression.SchemaFrom(schema as any) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "SqlExpression.ToExpression",
                    "Syntax": "SqlExpression.ToExpression(sql as text, environment as record) as text",
                    "About": "Converts the provided sql query to M code, with the available identifiers defined by environment. This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Add",
                    "Syntax": "Value.Add(value1 as any, value2 as any, optional precision as nullable number) as any",
                    "About": "Returns the sum of value1 and value2. An optional precision parameter may be specified, by default Precision.Double is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Alternates",
                    "Syntax": "Value.Alternates(alternates as list) as any",
                    "About": "Expresses alternate query plans within a query plan expression obtained through Value.Expression(Value.Optimize(...)). Not intended for other uses.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.As",
                    "Syntax": "Value.As(value as any, type as type) as any",
                    "About": "Returns the value if it's compatible with the specified type. This is equivalent to the \"as\" operator in M, with the exception that it can accept identifier type references such as Number.Type.",
                    "Explain": "Example 1Cast a number to a number.UsagePower Query MValue.As(123, Number.Type)Output123Example 2Attempt to cast a text value to a number.UsagePower Query MValue.As(\"abc\", type number)Output[Expression.Error] We cannot convert the value \"abc\" to type Number.",
                    "pages": []
                },
                {
                    "title": "Value.Compare",
                    "Syntax": "Value.Compare(value1 as any, value2 as any, optional precision as nullable number) as number",
                    "About": "Returns 1, 0, or -1 based on value1 being greater than, equal to, or less than the value2. An optional comparer function can be provided.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Divide",
                    "Syntax": "Value.Divide(value1 as any, value2 as any, optional precision as nullable number) as any",
                    "About": "Returns the result of dividing value1 by value2. An optional precision parameter may be specified, by default Precision.Double is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Equals",
                    "Syntax": "Value.Equals(value1 as any, value2 as any, optional precision as nullable number) as logical",
                    "About": "Returns true if value value1 is equal to value value2, false otherwise.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Expression",
                    "Syntax": "Value.Expression(value as any) as nullable record",
                    "About": "Returns an abstract syntax tree (AST) that represents the value's expression.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Firewall",
                    "Syntax": "Value.Firewall(key as text) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.FromText",
                    "Syntax": "Value.FromText(text as any, optional culture as nullable text) as any",
                    "About": "Decodes a value from a textual representation, text, and interprets it as a value with an appropriate type. Value.FromText takes a text value and returns a number, a logical value, a null value, a datetime value, a duration value, or a text value. The empty text value is interpreted as a null value. An optional culture may also be provided (for example, \"en-US\").",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Is",
                    "Syntax": "Value.Is(value as any, type as type) as logical",
                    "About": "Determines whether a value is compatible with the specified type. This is equivalent to the \"is\" operator in M, with the exception that it can accept identifier type references such as Number.Type.",
                    "Explain": "Compare two ways of determining if a number is compatible with type number.UsagePower Query MValue.Is(123, Number.Type) = (123 is number)Outputtrue",
                    "pages": []
                },
                {
                    "title": "Value.Lineage",
                    "Syntax": "Value.Lineage(value as any) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Metadata",
                    "Syntax": "Value.Metadata(value as any) as any",
                    "About": "Returns a record containing the input's metadata.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Multiply",
                    "Syntax": "Value.Multiply(value1 as any, value2 as any, optional precision as nullable number) as any",
                    "About": "Returns the product of multiplying value1 by value2. An optional precision parameter may be specified, by default Precision.Double is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.NativeQuery",
                    "Syntax": "Value.NativeQuery(target as any, query as text, optional parameters as any, optional options as nullable record) as any",
                    "About": "Evaluates query against target using the parameters specified in parameters and the options specified in options.The output of the query is defined by target.target provides the context for the operation described by query.query describes the query to be executed against target. query is expressed in a manner specific to target (for example, a T-SQL statement).The optional parameters value may contain either a list or record as appropriate to supply the parameter values expected by query.The optional options record may contain options that affect the evaluation behavior of query against target. These options are specific to target.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.NullableEquals",
                    "Syntax": "Value.NullableEquals(value1 as any, value2 as any, optional precision as nullable number) as nullable logical",
                    "About": "Returns null if either argument value1, value2 is null, otherwise equivalent to Value.Equals.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Optimize",
                    "Syntax": "Value.Optimize(value as any) as any",
                    "About": "When used within Value.Expression, if value represents a query that can be optimized, this function indicates that the optimized expression should be returned. Otherwise, value will be passed through with no effect.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.RemoveMetadata",
                    "Syntax": "Value.RemoveMetadata(value as any, optional metaValue as any) as any",
                    "About": "Removes the metadata on the value and returns the original value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.ReplaceMetadata",
                    "Syntax": "Value.ReplaceMetadata(value as any, metaValue as any) as any",
                    "About": "Replaces the metadata on a value with the new metadata record provided and returns the original value with the new metadata attached.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.ReplaceType",
                    "Syntax": "Value.ReplaceType(value as any, type as type) as any",
                    "About": "Replaces the value's type with the provided type.",
                    "Explain": "Replace the default type of a record with a more specific type.UsagePower Query MType.RecordFields(\u00a0\u00a0\u00a0\u00a0Value.Type(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Value.ReplaceType(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[Column1 = 123],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type [Column1 = number]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\u00a0\u00a0\u00a0\u00a0))[Column1][Type]Outputtype number",
                    "pages": []
                },
                {
                    "title": "Value.Subtract",
                    "Syntax": "Value.Subtract(value1 as any, value2 as any, optional precision as nullable number) as any",
                    "About": "Returns the difference of value1 and value2. An optional precision parameter may be specified, by default Precision.Double is used.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Traits",
                    "Syntax": "Value.Traits(value as any) as table",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Type",
                    "Syntax": "Value.Type(value as any) as type",
                    "About": "Returns the type of the given value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.VersionIdentity",
                    "Syntax": "Value.VersionIdentity(value as any) as any",
                    "About": "Returns the version identity of the value, or null if it doesn't have a version.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.Versions",
                    "Syntax": "Value.Versions(value as any) as table",
                    "About": "Returns a navigation table containing the available versions of value.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.ViewError",
                    "Syntax": "Value.ViewError(errorRecord as record) as record",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Value.ViewFunction",
                    "Syntax": "Value.ViewFunction(function as function) as function",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                },
                {
                    "title": "Variable.Value",
                    "Syntax": "Variable.Value(identifier as text) as any",
                    "About": "This function is intended for internal use only.",
                    "Explain": null,
                    "pages": []
                }
            ]
        }
    ]
}
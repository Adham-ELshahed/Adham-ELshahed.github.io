import fs from 'fs';

// Load the processed functions
const functionsData = JSON.parse(fs.readFileSync('processed-functions.json', 'utf8'));

console.log('Fixing specific list function formatting issues...\n');

let fixedCount = 0;

// Process list functions that need specific fixes
functionsData.forEach((func, index) => {
  if (func.category !== 'list') return;
  
  let wasFixed = false;
  
  // Fix List.Sort - format the comparison criteria with bullet points
  if (func.name === 'List.Sort') {
    console.log(`Fixing List.Sort comparison criteria formatting`);
    
    func.description = `Sorts a list of data, list, according to the optional criteria specified. An optional parameter, comparisonCriteria, can be specified as the comparison criterion. This can take the following values:

  • To control the order, the comparison criterion can be an Order enum value (Order.Descending, Order.Ascending)
  • To compute a key to be used for sorting, a function of 1 argument can be used
  • To both select a key and control order, comparison criterion can be a list containing the key and order ({each 1 / _, Order.Descending})
  • To completely control the comparison, a function of 2 arguments can be used. This function will be passed two items from the list (any two items, in any order). The function should return one of the following values:
    • -1: The first item is less than the second item
    • 0: The items are equal
    • 1: The first item is greater than the second item

Value.Compare is a method that can be used to delegate this logic.`;
    
    wasFixed = true;
  }
  
  // Check List.Generate for formatting improvements
  if (func.name === 'List.Generate') {
    console.log(`Checking List.Generate for formatting improvements`);
    
    // Check if the description needs better parameter flow explanation
    if (func.description && func.description.includes('initial function generates')) {
      func.description = `Generates a list of values using the provided functions. The initial function generates a starting candidate value, which is then tested against condition. If the candidate value is approved, then it's returned as part of the resulting list, and the next candidate value is generated by passing the newly approved value to next. Once a candidate value fails to match condition, the list generation process stops.

An optional parameter, selector, may also be provided to transform the items in the resulting list.`;
      wasFixed = true;
    }
  }
  
  // Check List.Accumulate for formatting improvements
  if (func.name === 'List.Accumulate') {
    console.log(`Checking List.Accumulate for formatting improvements`);
    
    // The description looks clean and simple, no major formatting needed
    if (func.description && !func.description.includes('\n')) {
      // No changes needed - it's a clear, concise description
    }
  }
  
  // Check functions with join kinds
  if (func.description && func.description.includes('JoinKind')) {
    console.log(`Fixing JoinKind formatting for ${func.name}`);
    
    // Format JoinKind options with proper bullet points
    func.description = func.description.replace(
      /JoinKind\.([A-Za-z]+)\s*:\s*([^.]+\.)/g,
      '\n  • JoinKind.$1: $2'
    );
    wasFixed = true;
  }
  
  // Check functions with sort order options
  if (func.description && func.description.includes('Order.')) {
    console.log(`Checking Order enum formatting for ${func.name}`);
    
    // These are usually already handled by the main formatter
    // Just ensure consistency
  }
  
  // Check for multi-line option descriptions that need splitting
  if (func.description && func.description.includes('This can take the following values:') && func.name !== 'List.Sort') {
    console.log(`Fixing option values formatting for ${func.name}`);
    
    // Add line break before option descriptions
    func.description = func.description.replace(
      'This can take the following values:',
      'This can take the following values:\n\n'
    );
    wasFixed = true;
  }
  
  if (wasFixed) {
    fixedCount++;
  }
});

// Write the updated data back
fs.writeFileSync('processed-functions.json', JSON.stringify(functionsData, null, 2));

console.log(`\nCompleted fixing specific list function formatting issues`);
console.log(`${fixedCount} list functions had additional formatting improvements`);
console.log('All list functions now have consistent formatting with proper line breaks and bullet points');